{
    "sparse_table.cpp": {
        "prefix": "sparse_table.cpp",
        "body": [
            "#define oper min",
            "int st[K][1<<K];int n;  // K such that 2^K>n",
            "void st_init(int *a){",
            "\tfore(i,0,n)st[0][i]=a[i];",
            "\tfore(k,1,K)fore(i,0,n-(1<<k)+1)",
            "\t\tst[k][i]=oper(st[k-1][i],st[k-1][i+(1<<(k-1))]);",
            "}",
            "int st_query(int s, int e){",
            "\tint k=31-__builtin_clz(e-s);",
            "\treturn oper(st[k][s],st[k][e-(1<<k)]);",
            "}"
        ],
        "description": "Snippet for sparse_table.cpp"
    },
    "persistent_segtree.cpp": {
        "prefix": "persistent_segtree.cpp",
        "body": [
            "struct STree { // persistent segment tree for min over integers",
            "\tvi st, L, R; int n,tam,rt;",
            "\tSTree(int n): st(1,NEUT),L(1,0),R(1,0),n(n),rt(0),tam(1){}",
            "\tint new_node(int v, int l=0, int r=0){",
            "\t\tint ks=sz(st); st.pb(v); L.pb(l); R.pb(r); return ks;",
            "\t}",
            "\tint upd(int k, int s, int e, int p, int v){",
            "\t\tint ks=new_node(st[k],L[k],R[k]);",
            "\t\tif(s+1==e){st[ks]=v;return ks;}",
            "\t\tint m=(s+e)/2,ps;",
            "\t\tif(p<m)ps=upd(L[ks],s,m,p,v),L[ks]=ps;",
            "\t\telse ps=upd(R[ks],m,e,p,v),R[ks]=ps;",
            "\t\tst[ks]=oper(st[L[ks]],st[R[ks]]);",
            "\t\treturn ks;",
            "\t}",
            "\tint query(int k, int s, int e, int a, int b){",
            "\t\tif(e<=a||b<=s)return NEUT;",
            "\t\tif(a<=s&&e<=b)return st[k];",
            "\t\tint m=(s+e)/2;",
            "\t\treturn oper(query(L[k],s,m,a,b),query(R[k],m,e,a,b));",
            "\t}",
            "\tint upd(int k, int p, int v){return rt=upd(k,0,n,p,v);}",
            "\tint upd(int p, int v){return upd(rt,p,v);} // update on last root",
            "\tint query(int k,int a, int b){return query(k,0,n,a,b);};",
            "};"
        ],
        "description": "Snippet for persistent_segtree.cpp"
    },
    "bigint.cpp": {
        "prefix": "bigint.cpp",
        "body": [
            "/*",
            "  ######################################################################",
            "  #######################   THE   BIG   INT   ##########################",
            "*/",
            "const int base = 1000000000;",
            "const int base_digits = 9;",
            "struct bigint {",
            "    vector<int> a;",
            "    int sign;",
            "    /*<arpa>*/",
            "    int size(){",
            "\tif(a.empty())return 0;",
            "\tint ans=(a.size()-1)*base_digits;",
            "\tint ca=a.back();",
            "\twhile(ca)",
            "\t    ans++,ca/=10;",
            "\treturn ans;",
            "    }",
            "    bigint operator ^(const bigint &v){",
            "\tbigint ans=1,a=*this,b=v;",
            "\twhile(!b.isZero()){",
            "\t    if(b%2)",
            "\t\tans*=a;",
            "\t    a*=a,b/=2;",
            "\t}",
            "\treturn ans;",
            "    }",
            "    string to_string(){",
            "\tstringstream ss;",
            "\tss << *this;",
            "\tstring s;",
            "\tss >> s;",
            "\treturn s;",
            "    }",
            "    int sumof(){",
            "\tstring s = to_string();",
            "\tint ans = 0;",
            "\tfor(auto c : s)  ans += c - '0';",
            "\treturn ans;",
            "    }",
            "    /*</arpa>*/",
            "    bigint() :",
            "\tsign(1) {",
            "    }",
            "",
            "    bigint(long long v) {",
            "\t*this = v;",
            "    }",
            "",
            "    bigint(const string &s) {",
            "\tread(s);",
            "    }",
            "",
            "    void operator=(const bigint &v) {",
            "\tsign = v.sign;",
            "\ta = v.a;",
            "    }",
            "",
            "    void operator=(long long v) {",
            "\tsign = 1;",
            "\ta.clear();",
            "\tif (v < 0)",
            "\t    sign = -1, v = -v;",
            "\tfor (; v > 0; v = v / base)",
            "\t    a.push_back(v % base);",
            "    }",
            "",
            "    bigint operator+(const bigint &v) const {",
            "\tif (sign == v.sign) {",
            "\t    bigint res = v;",
            "",
            "\t    for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
            "\t\tif (i == (int) res.a.size())",
            "\t\t    res.a.push_back(0);",
            "\t\tres.a[i] += carry + (i < (int) a.size() ? a[i] : 0);",
            "\t\tcarry = res.a[i] >= base;",
            "\t\tif (carry)",
            "\t\t    res.a[i] -= base;",
            "\t    }",
            "\t    return res;",
            "\t}",
            "\treturn *this - (-v);",
            "    }",
            "",
            "    bigint operator-(const bigint &v) const {",
            "\tif (sign == v.sign) {",
            "\t    if (abs() >= v.abs()) {",
            "\t\tbigint res = *this;",
            "\t\tfor (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
            "\t\t    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
            "\t\t    carry = res.a[i] < 0;",
            "\t\t    if (carry)",
            "\t\t\tres.a[i] += base;",
            "\t\t}",
            "\t\tres.trim();",
            "\t\treturn res;",
            "\t    }",
            "\t    return -(v - *this);",
            "\t}",
            "\treturn *this + (-v);",
            "    }",
            "",
            "    void operator*=(int v) {",
            "\tif (v < 0)",
            "\t    sign = -sign, v = -v;",
            "\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
            "\t    if (i == (int) a.size())",
            "\t\ta.push_back(0);",
            "\t    long long cur = a[i] * (long long) v + carry;",
            "\t    carry = (int) (cur / base);",
            "\t    a[i] = (int) (cur % base);",
            "\t    //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
            "\t}",
            "\ttrim();",
            "    }",
            "",
            "    bigint operator*(int v) const {",
            "\tbigint res = *this;",
            "\tres *= v;",
            "\treturn res;",
            "    }",
            "",
            "    void operator*=(long long v) {",
            "\tif (v < 0)",
            "\t    sign = -sign, v = -v;",
            "\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
            "\t    if (i == (int) a.size())",
            "\t\ta.push_back(0);",
            "\t    long long cur = a[i] * (long long) v + carry;",
            "\t    carry = (int) (cur / base);",
            "\t    a[i] = (int) (cur % base);",
            "\t    //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
            "\t}",
            "\ttrim();",
            "    }",
            "",
            "    bigint operator*(long long v) const {",
            "\tbigint res = *this;",
            "\tres *= v;",
            "\treturn res;",
            "    }",
            "",
            "    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
            "\tint norm = base / (b1.a.back() + 1);",
            "\tbigint a = a1.abs() * norm;",
            "\tbigint b = b1.abs() * norm;",
            "\tbigint q, r;",
            "\tq.a.resize(a.a.size());",
            "",
            "\tfor (int i = a.a.size() - 1; i >= 0; i--) {",
            "\t    r *= base;",
            "\t    r += a.a[i];",
            "\t    int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
            "\t    int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
            "\t    int d = ((long long) base * s1 + s2) / b.a.back();",
            "\t    r -= b * d;",
            "\t    while (r < 0)",
            "\t\tr += b, --d;",
            "\t    q.a[i] = d;",
            "\t}",
            "",
            "\tq.sign = a1.sign * b1.sign;",
            "\tr.sign = a1.sign;",
            "\tq.trim();",
            "\tr.trim();",
            "\treturn make_pair(q, r / norm);",
            "    }",
            "",
            "    bigint operator/(const bigint &v) const {",
            "\treturn divmod(*this, v).first;",
            "    }",
            "",
            "    bigint operator%(const bigint &v) const {",
            "\treturn divmod(*this, v).second;",
            "    }",
            "",
            "    void operator/=(int v) {",
            "\tif (v < 0)",
            "\t    sign = -sign, v = -v;",
            "\tfor (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
            "\t    long long cur = a[i] + rem * (long long) base;",
            "\t    a[i] = (int) (cur / v);",
            "\t    rem = (int) (cur % v);",
            "\t}",
            "\ttrim();",
            "    }",
            "",
            "    bigint operator/(int v) const {",
            "\tbigint res = *this;",
            "\tres /= v;",
            "\treturn res;",
            "    }",
            "",
            "    int operator%(int v) const {",
            "\tif (v < 0)",
            "\t    v = -v;",
            "\tint m = 0;",
            "\tfor (int i = a.size() - 1; i >= 0; --i)",
            "\t    m = (a[i] + m * (long long) base) % v;",
            "\treturn m * sign;",
            "    }",
            "",
            "    void operator+=(const bigint &v) {",
            "\t*this = *this + v;",
            "    }",
            "    void operator-=(const bigint &v) {",
            "\t*this = *this - v;",
            "    }",
            "    void operator*=(const bigint &v) {",
            "\t*this = *this * v;",
            "    }",
            "    void operator/=(const bigint &v) {",
            "\t*this = *this / v;",
            "    }",
            "",
            "    bool operator<(const bigint &v) const {",
            "\tif (sign != v.sign)",
            "\t    return sign < v.sign;",
            "\tif (a.size() != v.a.size())",
            "\t    return a.size() * sign < v.a.size() * v.sign;",
            "\tfor (int i = a.size() - 1; i >= 0; i--)",
            "\t    if (a[i] != v.a[i])",
            "\t\treturn a[i] * sign < v.a[i] * sign;",
            "\treturn false;",
            "    }",
            "",
            "    bool operator>(const bigint &v) const {",
            "\treturn v < *this;",
            "    }",
            "    bool operator<=(const bigint &v) const {",
            "\treturn !(v < *this);",
            "    }",
            "    bool operator>=(const bigint &v) const {",
            "\treturn !(*this < v);",
            "    }",
            "    bool operator==(const bigint &v) const {",
            "\treturn !(*this < v) && !(v < *this);",
            "    }",
            "    bool operator!=(const bigint &v) const {",
            "\treturn *this < v || v < *this;",
            "    }",
            "",
            "    void trim() {",
            "\twhile (!a.empty() && !a.back())",
            "\t    a.pop_back();",
            "\tif (a.empty())",
            "\t    sign = 1;",
            "    }",
            "",
            "    bool isZero() const {",
            "\treturn a.empty() || (a.size() == 1 && !a[0]);",
            "    }",
            "",
            "    bigint operator-() const {",
            "\tbigint res = *this;",
            "\tres.sign = -sign;",
            "\treturn res;",
            "    }",
            "",
            "    bigint abs() const {",
            "\tbigint res = *this;",
            "\tres.sign *= res.sign;",
            "\treturn res;",
            "    }",
            "",
            "    long long longValue() const {",
            "\tlong long res = 0;",
            "\tfor (int i = a.size() - 1; i >= 0; i--)",
            "\t    res = res * base + a[i];",
            "\treturn res * sign;",
            "    }",
            "",
            "    friend bigint gcd(const bigint &a, const bigint &b) {",
            "\treturn b.isZero() ? a : gcd(b, a % b);",
            "    }",
            "    friend bigint lcm(const bigint &a, const bigint &b) {",
            "\treturn a / gcd(a, b) * b;",
            "    }",
            "",
            "    void read(const string &s) {",
            "\tsign = 1;",
            "\ta.clear();",
            "\tint pos = 0;",
            "\twhile (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
            "\t    if (s[pos] == '-')",
            "\t\tsign = -sign;",
            "\t    ++pos;",
            "\t}",
            "\tfor (int i = s.size() - 1; i >= pos; i -= base_digits) {",
            "\t    int x = 0;",
            "\t    for (int j = max(pos, i - base_digits + 1); j <= i; j++)",
            "\t\tx = x * 10 + s[j] - '0';",
            "\t    a.push_back(x);",
            "\t}",
            "\ttrim();",
            "    }",
            "",
            "    friend istream& operator>>(istream &stream, bigint &v) {",
            "\tstring s;",
            "\tstream >> s;",
            "\tv.read(s);",
            "\treturn stream;",
            "    }",
            "",
            "    friend ostream& operator<<(ostream &stream, const bigint &v) {",
            "\tif (v.sign == -1)",
            "\t    stream << '-';",
            "\tstream << (v.a.empty() ? 0 : v.a.back());",
            "\tfor (int i = (int) v.a.size() - 2; i >= 0; --i)",
            "\t    stream << setw(base_digits) << setfill('0') << v.a[i];",
            "\treturn stream;",
            "    }",
            "",
            "    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
            "\tvector<long long> p(max(old_digits, new_digits) + 1);",
            "\tp[0] = 1;",
            "\tfor (int i = 1; i < (int) p.size(); i++)",
            "\t    p[i] = p[i - 1] * 10;",
            "\tvector<int> res;",
            "\tlong long cur = 0;",
            "\tint cur_digits = 0;",
            "\tfor (int i = 0; i < (int) a.size(); i++) {",
            "\t    cur += a[i] * p[cur_digits];",
            "\t    cur_digits += old_digits;",
            "\t    while (cur_digits >= new_digits) {",
            "\t\tres.push_back(int(cur % p[new_digits]));",
            "\t\tcur /= p[new_digits];",
            "\t\tcur_digits -= new_digits;",
            "\t    }",
            "\t}",
            "\tres.push_back((int) cur);",
            "\twhile (!res.empty() && !res.back())",
            "\t    res.pop_back();",
            "\treturn res;",
            "    }",
            "",
            "    typedef vector<long long> vll;",
            "",
            "    static vll karatsubaMultiply(const vll &a, const vll &b) {",
            "\tint n = a.size();",
            "\tvll res(n + n);",
            "\tif (n <= 32) {",
            "\t    for (int i = 0; i < n; i++)",
            "\t\tfor (int j = 0; j < n; j++)",
            "\t\t    res[i + j] += a[i] * b[j];",
            "\t    return res;",
            "\t}",
            "",
            "\tint k = n >> 1;",
            "\tvll a1(a.begin(), a.begin() + k);",
            "\tvll a2(a.begin() + k, a.end());",
            "\tvll b1(b.begin(), b.begin() + k);",
            "\tvll b2(b.begin() + k, b.end());",
            "",
            "\tvll a1b1 = karatsubaMultiply(a1, b1);",
            "\tvll a2b2 = karatsubaMultiply(a2, b2);",
            "",
            "\tfor (int i = 0; i < k; i++)",
            "\t    a2[i] += a1[i];",
            "\tfor (int i = 0; i < k; i++)",
            "\t    b2[i] += b1[i];",
            "",
            "\tvll r = karatsubaMultiply(a2, b2);",
            "\tfor (int i = 0; i < (int) a1b1.size(); i++)",
            "\t    r[i] -= a1b1[i];",
            "\tfor (int i = 0; i < (int) a2b2.size(); i++)",
            "\t    r[i] -= a2b2[i];",
            "",
            "\tfor (int i = 0; i < (int) r.size(); i++)",
            "\t    res[i + k] += r[i];",
            "\tfor (int i = 0; i < (int) a1b1.size(); i++)",
            "\t    res[i] += a1b1[i];",
            "\tfor (int i = 0; i < (int) a2b2.size(); i++)",
            "\t    res[i + n] += a2b2[i];",
            "\treturn res;",
            "    }",
            "",
            "    bigint operator*(const bigint &v) const {",
            "\tvector<int> a6 = convert_base(this->a, base_digits, 6);",
            "\tvector<int> b6 = convert_base(v.a, base_digits, 6);",
            "\tvll a(a6.begin(), a6.end());",
            "\tvll b(b6.begin(), b6.end());",
            "\twhile (a.size() < b.size())",
            "\t    a.push_back(0);",
            "\twhile (b.size() < a.size())",
            "\t    b.push_back(0);",
            "\twhile (a.size() & (a.size() - 1))",
            "\t    a.push_back(0), b.push_back(0);",
            "\tvll c = karatsubaMultiply(a, b);",
            "\tbigint res;",
            "\tres.sign = sign * v.sign;",
            "\tfor (int i = 0, carry = 0; i < (int) c.size(); i++) {",
            "\t    long long cur = c[i] + carry;",
            "\t    res.a.push_back((int) (cur % 1000000));",
            "\t    carry = (int) (cur / 1000000);",
            "\t}",
            "\tres.a = convert_base(res.a, 6, base_digits);",
            "\tres.trim();",
            "\treturn res;",
            "    }",
            "};",
            "/*",
            "  #######################   THE   BIG   INT   ##########################",
            "  ######################################################################",
            "*/",
            ""
        ],
        "description": "Snippet for bigint.cpp"
    },
    "treap_implicit.cpp": {
        "prefix": "treap_implicit.cpp",
        "body": [
            "// example that supports range reverse and addition updates, and range sum query",
            "// (commented parts are specific to this  problem)",
            "typedef struct item *pitem;",
            "struct item {",
            "\tint pr,cnt,val;",
            "//\tint sum; // (paramters for range query)",
            "//\tbool rev;int add; // (parameters for lazy prop)",
            "\tpitem l,r;",
            "\titem(int val): pr(rand()),cnt(1),val(val),l(0),r(0)/*,sum(val),rev(0),add(0)*/ {}",
            "};",
            "void push(pitem it){",
            "\tif(it){",
            "\t\t/*if(it->rev){",
            "\t\t\tswap(it->l,it->r);",
            "\t\t\tif(it->l)it->l->rev^=true;",
            "\t\t\tif(it->r)it->r->rev^=true;",
            "\t\t\tit->rev=false;",
            "\t\t}",
            "\t\tit->val+=it->add;it->sum+=it->cnt*it->add;",
            "\t\tif(it->l)it->l->add+=it->add;",
            "\t\tif(it->r)it->r->add+=it->add;",
            "\t\tit->add=0;*/",
            "\t}",
            "}",
            "int cnt(pitem t){return t?t->cnt:0;}",
            "// int sum(pitem t){return t?push(t),t->sum:0;}",
            "void upd_cnt(pitem t){",
            "\tif(t){",
            "\t\tt->cnt=cnt(t->l)+cnt(t->r)+1;",
            "\t\t// t->sum=t->val+sum(t->l)+sum(t->r);",
            "\t}",
            "}",
            "void merge(pitem& t, pitem l, pitem r){",
            "\tpush(l);push(r);",
            "\tif(!l||!r)t=l?l:r;",
            "\telse if(l->pr>r->pr)merge(l->r,l->r,r),t=l;",
            "\telse merge(r->l,l,r->l),t=r;",
            "\tupd_cnt(t);",
            "}",
            "void split(pitem t, pitem& l, pitem& r, int sz){ // sz:desired size of l",
            "\tif(!t){l=r=0;return;}",
            "\tpush(t);",
            "\tif(sz<=cnt(t->l))split(t->l,l,t->l,sz),r=t;",
            "\telse split(t->r,t->r,r,sz-1-cnt(t->l)),l=t;",
            "\tupd_cnt(t);",
            "}",
            "void output(pitem t){ // useful for debugging",
            "\tif(!t)return;",
            "\tpush(t);",
            "\toutput(t->l);printf(\" %d\",t->val);output(t->r);",
            "}",
            "// use merge and split for range updates and queries"
        ],
        "description": "Snippet for treap_implicit.cpp"
    },
    "fenwick_tree_2D.cpp": {
        "prefix": "fenwick_tree_2D.cpp",
        "body": [
            "int ft[MAXN+1][MAXN+1];",
            "void upd(int i0, int j0, int v){",
            "\tfor(int i=i0+1;i<=MAXN;i+=i&-i)",
            "\tfor(int j=j0+1;j<=MAXN;j+=j&-j)",
            "\t\tft[i][j]+=v;",
            "}",
            "int get(int i0, int j0){",
            "\tint r=0;",
            "\tfor(int i=i0;i;i-=i&-i)",
            "\tfor(int j=j0;j;j-=j&-j)",
            "\t\tr+=ft[i][j];",
            "\treturn r;",
            "}",
            "int get_sum(int i0, int j0, int i1, int j1){",
            "\treturn get(i1,j1)-get(i1,j0)-get(i0,j1)+get(i0,j0);",
            "}"
        ],
        "description": "Snippet for fenwick_tree_2D.cpp"
    },
    "lazy_segtree.cpp": {
        "prefix": "lazy_segtree.cpp",
        "body": [
            "struct LazySegtree{",
            "  #define mid (l + r) / 2",
            "  #define left(u) (u + 1)",
            "  #define right(u) (u + ((mid - l + 1) << 1))",
            "  struct Node{",
            "    lli s, lazy;",
            "    Node(lli s = 0, lli lazy = 0): s(s), lazy(lazy) {}",
            "    Node operator + (const Node &n){",
            "      return Node(s + n.s);",
            "    }",
            "  };",
            "  vector<Node> st;",
            "  LazySegtree(int n): st(2 * n) {}",
            "  void push(int u, int l, int r){",
            "    if(st[u].lazy){",
            "      if(l < r){",
            "        st[left(u)].lazy += st[u].lazy;",
            "        st[right(u)].lazy += st[u].lazy;",
            "      }",
            "      st[u].s += st[u].lazy * (r - l + 1);",
            "      st[u].lazy = 0;",
            "    }",
            "  }",
            "  void update(int u, int l, int r, int ll, int rr, lli val){ // O(logN)",
            "    push(u, l, r);",
            "    if(l > r or r < ll or l > rr) return;",
            "    if(ll <= l and r <= rr){",
            "      st[u].lazy += val;",
            "      push(u, l, r);",
            "      return;",
            "    }",
            "    update(left(u), l, mid, ll, rr, val);",
            "    update(right(u), mid + 1, r, ll, rr, val);",
            "    st[u] = st[left(u)] + st[right(u)];",
            "  }",
            "  Node query(int u, int l, int r, int ll, int rr){ // O(logN)",
            "    push(u, l, r);",
            "    if(l > r or r < ll or l > rr) return Node();",
            "    if(ll <= l and r <= rr) return st[u];",
            "    return query(left(u), l, mid, ll, rr) + query(right(u), mid + 1, r, ll, rr);",
            "  }",
            "};",
            ""
        ],
        "description": "Snippet for lazy_segtree.cpp"
    },
    "sparse_lazy_segtree.cpp": {
        "prefix": "sparse_lazy_segtree.cpp",
        "body": [
            "#define mid l + (r - l) / 2",
            "struct Node{",
            "  lli s, z;",
            "  Node(lli s = 0, lli z = 0): s(s), z(z) {};",
            "  Node operator + (const Node& n) {",
            "    return Node(s + n.s);",
            "  }",
            "};",
            "struct ST {",
            "\tNode data;",
            "\tlli l, r;",
            "  // ST(Node data = Node()): data(data), l(0), r(0) {}",
            "};",
            "ST st[MAXN];",
            "lli curst = 1; // 0 = NULL",
            "lli newST(){",
            "  st[curst].data = Node();",
            "  st[curst].l = 0;",
            "  st[curst].r = 0;",
            "  return curst++;",
            "}",
            "Node data(lli u){return u ? st[u].data : Node();}",
            "void pull(lli u){st[u].data = data(st[u].l) + data(st[u].r);}",
            "void push(lli u, lli l, lli r){",
            "  if(!st[u].l) st[u].l = newST();",
            "  if(!st[u].r) st[u].r = newST();",
            "  if(st[u].data.z){",
            "    if(l < r){",
            "      st[st[u].l].data.z += st[u].data.z;",
            "      st[st[u].r].data.z += st[u].data.z;",
            "    }",
            "    st[u].data.s += (r - l + 1ll) * st[u].data.z;",
            "    st[u].data.z = 0;",
            "  }",
            "}",
            "void update(lli u, lli l, lli r, lli ll, lli rr, lli val){",
            "  push(u, l, r);",
            "  if(l > r or r < ll or l > rr or ll > rr) return;",
            "  if(ll <= l and r <= rr){",
            "    st[u].data.z += val;",
            "    push(u, l, r);",
            "    return;",
            "  }",
            "  update(st[u].l, l, mid, ll, rr, val);",
            "  update(st[u].r, mid + 1, r, ll, rr, val);",
            "  pull(u);",
            "}",
            "Node query(lli u, lli l, lli r, lli ll, lli rr){",
            "  push(u, l, r);",
            "  if(!u or l > r or r < ll or l > rr) return Node();",
            "  if(ll <= l and r <= rr) return st[u].data;",
            "  return query(st[u].l, l, mid, ll, rr) + query(st[u].r, mid + 1, r, ll, rr);",
            "}",
            ""
        ],
        "description": "Snippet for sparse_lazy_segtree.cpp"
    },
    "disjoint_set.cpp": {
        "prefix": "disjoint_set.cpp",
        "body": [
            "struct DSU{",
            "  vector<int> pr, rank;",
            "  stack<pair<int,int>> what;",
            "  DSU(int n): pr(n), rank(n, 1){ // O(N)",
            "    iota(all(pr), 0);",
            "  }",
            "  int find(int u){ // O(1)",
            "    return pr[u] == u ? u: pr[u] = find(pr[u]);",
            "  }",
            "  void unite(int u, int v){ // O(1)",
            "    u = find(u), v = find(v);",
            "    if(u != v){",
            "      if(rank[u] < rank[v]) swap(u, v);",
            "      rank[u] += rank[v];",
            "      pr[v] = u;",
            "      what.push({u, v});",
            "    }else what.push({-1, -1});",
            "  }",
            "  pair<int,int> rollback(){ // O(1)",
            "    pair<int,int> last = what.top();",
            "    what.pop();",
            "    int u = last.f, v = last.s;",
            "    if(u != -1){",
            "      rank[u] -= rank[v];",
            "      pr[v] = v;",
            "    }",
            "    return last;",
            "  }",
            "};",
            ""
        ],
        "description": "Snippet for disjoint_set.cpp"
    },
    "gain_cost_set.cpp": {
        "prefix": "gain_cost_set.cpp",
        "body": [
            "// stores pairs (benefit,cost) (erases non-optimal pairs)",
            "struct GCS {",
            "\tset<pair<int,int> > s;",
            "\tvoid add(int g, int c){",
            "\t\tpair<int,int> x={g,c};",
            "\t\tauto p=s.lower_bound(x);",
            "\t\tif(p!=s.end()&&p->s<=x.s)return;",
            "\t\tif(p!=s.begin()){ // erase pairs with less benefit",
            "\t\t\t--p;            // and more cost",
            "\t\t\twhile(p->s>=x.s){",
            "\t\t\t\tif(p==s.begin()){s.erase(p);break;}",
            "\t\t\t\ts.erase(p--);",
            "\t\t\t}",
            "\t\t}",
            "\t\ts.insert(x);",
            "\t}",
            "\tint get(int gain){ // min cost for some benefit",
            "\t\tauto p=s.lower_bound((pair<int,int>){gain,-INF});",
            "\t\tint r=p==s.end()?INF:p->s;",
            "\t\treturn r;",
            "\t}",
            "};"
        ],
        "description": "Snippet for gain_cost_set.cpp"
    },
    "link_cut_tree_crystal.cpp": {
        "prefix": "link_cut_tree_crystal.cpp",
        "body": [
            "struct SplayTree {",
            "  struct Node {",
            "    int ch[2] = {0, 0}, p = 0;",
            "    long long self = 0, path = 0;        // Path aggregates",
            "    long long sub = 0, vir = 0;          // Subtree aggregates",
            "    bool flip = 0;                       // Lazy tags",
            "  };",
            "  vector<Node> T;",
            "",
            "  SplayTree(int n) : T(n + 1) {}",
            "",
            "  void push(int x) {",
            "    if (!x || !T[x].flip) return;",
            "    int l = T[x].ch[0], r = T[x].ch[1];",
            "",
            "    T[l].flip ^= 1, T[r].flip ^= 1;",
            "    swap(T[x].ch[0], T[x].ch[1]);",
            "    T[x].flip = 0;",
            "  }",
            "",
            "  void pull(int x) {",
            "    int l = T[x].ch[0], r = T[x].ch[1]; push(l); push(r);",
            "",
            "    T[x].path = T[l].path + T[x].self + T[r].path;",
            "    T[x].sub = T[x].vir + T[l].sub + T[r].sub + T[x].self;",
            "  }",
            "",
            "  void set(int x, int d, int y) {",
            "    T[x].ch[d] = y; T[y].p = x; pull(x);",
            "  }",
            "",
            "  void splay(int x) {",
            "    auto dir = [&](int x) {",
            "      int p = T[x].p; if (!p) return -1;",
            "      return T[p].ch[0] == x ? 0 : T[p].ch[1] == x ? 1 : -1;",
            "    };",
            "    auto rotate = [&](int x) {",
            "      int y = T[x].p, z = T[y].p, dx = dir(x), dy = dir(y);",
            "      set(y, dx, T[x].ch[!dx]);",
            "      set(x, !dx, y);",
            "      if (~dy) set(z, dy, x);",
            "      T[x].p = z;",
            "    };",
            "    for (push(x); ~dir(x); ) {",
            "      int y = T[x].p, z = T[y].p;",
            "      push(z); push(y); push(x);",
            "      int dx = dir(x), dy = dir(y);",
            "      if (~dy) rotate(dx != dy ? x : y);",
            "      rotate(x);",
            "    }",
            "  }",
            "};",
            "",
            "struct LinkCut : SplayTree {",
            "  LinkCut(int n) : SplayTree(n) {}",
            "",
            "  int access(int x) {",
            "    int u = x, v = 0;",
            "    for (; u; v = u, u = T[u].p) {",
            "      splay(u);",
            "      int& ov = T[u].ch[1];",
            "      T[u].vir += T[ov].sub;",
            "      T[u].vir -= T[v].sub;",
            "      ov = v; pull(u);",
            "    }",
            "    return splay(x), v;",
            "  }",
            "",
            "  void reroot(int x) {",
            "    access(x); T[x].flip ^= 1; push(x);",
            "  }",
            "",
            "  void Link(int u, int v) {",
            "    reroot(u); access(v);",
            "    T[v].vir += T[u].sub;",
            "    T[u].p = v; pull(v);",
            "  }",
            "",
            "  void Cut(int u, int v) {",
            "    reroot(u); access(v);",
            "    T[v].ch[0] = T[u].p = 0; pull(v);",
            "  }",
            "",
            "  // Rooted tree LCA. Returns 0 if u and v arent connected.",
            "  int LCA(int u, int v) {",
            "    if (u == v) return u;",
            "    access(u); int ret = access(v);",
            "    return T[u].p ? ret : 0;",
            "  }",
            "",
            "  // Query subtree of u where v is outside the subtree.",
            "  long long Subtree(int u, int v) {",
            "    reroot(v); access(u); return T[u].vir + T[u].self;",
            "  }",
            "",
            "  // Query path [u..v]",
            "  long long Path(int u, int v) {",
            "    reroot(u); access(v); return T[v].path;",
            "  }",
            "",
            "  // Update vertex u with value v",
            "  void Update(int u, long long v) {",
            "    access(u); T[u].self = v; pull(u);",
            "  }",
            "};",
            ""
        ],
        "description": "Snippet for link_cut_tree_crystal.cpp"
    },
    "convexhull_trick_dynamic.cpp": {
        "prefix": "convexhull_trick_dynamic.cpp",
        "body": [
            "typedef lli tc;",
            "const tc is_query=-(1LL<<62); // special value for query",
            "struct Line {",
            "\ttc m,b;",
            "\tmutable multiset<Line>::iterator it,end;",
            "\tconst Line* succ(multiset<Line>::iterator it) const {",
            "\t\treturn (++it==end? NULL : &*it);}",
            "\tbool operator<(const Line& rhs) const {",
            "\t\tif(rhs.b!=is_query)return m<rhs.m;",
            "\t\tconst Line *s=succ(it);",
            "\t\tif(!s)return 0;",
            "\t\treturn b-s->b<(s->m-m)*rhs.m;",
            "\t}",
            "};",
            "struct HullDynamic : public multiset<Line> { // for maximum",
            "\tbool bad(iterator y){",
            "\t\titerator z=next(y);",
            "\t\tif(y==begin()){",
            "\t\t\tif(z==end())return false;",
            "\t\t\treturn y->m==z->m&&y->b<=z->b;",
            "\t\t}",
            "\t\titerator x=prev(y);",
            "\t\tif(z==end())return y->m==x->m&&y->b<=x->b;",
            "\t\treturn (x->b-y->b)*(z->m-y->m)>=(y->b-z->b)*(y->m-x->m);",
            "\t}",
            "\titerator next(iterator y){return ++y;}",
            "\titerator prev(iterator y){return --y;}",
            "\tvoid add(tc m, tc b){",
            "\t\titerator y=insert((Line){m,b});",
            "\t\ty->it=y;y->end=end();",
            "\t\tif(bad(y)){erase(y);return;}",
            "\t\twhile(next(y)!=end()&&bad(next(y)))erase(next(y));",
            "\t\twhile(y!=begin()&&bad(prev(y)))erase(prev(y));",
            "\t}",
            "\ttc eval(tc x){",
            "\t\tLine l=*lower_bound((Line){x,is_query});",
            "\t\treturn l.m*x+l.b;",
            "\t}",
            "};"
        ],
        "description": "Snippet for convexhull_trick_dynamic.cpp"
    },
    "minmax_queue.cpp": {
        "prefix": "minmax_queue.cpp",
        "body": [
            "struct qiu{",
            "\tstack<ii> s1,s2;",
            "\tint query(){",
            "\t\tint minimum;",
            "\t\tif (s1.empty() || s2.empty()) minimum = s1.empty() ? s2.top().second : s1.top().second;",
            "\t\telse minimum = min(s1.top().second, s2.top().second);",
            "\t\treturn minimum;",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tif (s2.empty())while (!s1.empty()) {",
            "        int element = s1.top().first;",
            "        s1.pop();",
            "        int minimum = s2.empty() ? element : min(element, s2.top().second);",
            "        s2.push({element, minimum});",
            "    \t}",
            "\t\tint remove_element = s2.top().first;",
            "\t\ts2.pop();",
            "\t}",
            "",
            "\tvoid add(int new_element){",
            "\t\tint minimum = s1.empty() ? new_element : min(new_element, s1.top().second);",
            "\t\ts1.push({new_element, minimum});",
            "\t}",
            "};",
            "",
            ""
        ],
        "description": "Snippet for minmax_queue.cpp"
    },
    "disjoint_intervals.cpp": {
        "prefix": "disjoint_intervals.cpp",
        "body": [
            "// stores disjoint intervals as [first, second)",
            "struct disjoint_intervals {",
            "\tset<pair<int,int> > s;",
            "\tvoid insert(pair<int,int> v){",
            "\t\tif(v.f>=v.s) return;",
            "\t\tauto at=s.lower_bound(v);auto it=at;",
            "\t\tif(at!=s.begin()&&(--at)->s>=v.f)v.f=at->f,--it;",
            "\t\tfor(;it!=s.end()&&it->f<=v.s;s.erase(it++))",
            "\t\t\tv.s=max(v.s,it->s);",
            "\t\ts.insert(v);",
            "\t}",
            "};"
        ],
        "description": "Snippet for disjoint_intervals.cpp"
    },
    "segtree2d.cpp": {
        "prefix": "segtree2d.cpp",
        "body": [
            "int n,m; int a[MAXN][MAXN],st[2*MAXN][2*MAXN];",
            "void build(){",
            "\tfore(i,0,n)fore(j,0,m)st[i+n][j+m]=a[i][j];",
            "\tfore(i,0,n)for(int j=m-1;j;--j)",
            "\t\tst[i+n][j]=op(st[i+n][j<<1],st[i+n][j<<1|1]);",
            "\tfor(int i=n-1;i;--i)fore(j,0,2*m)",
            "\t\tst[i][j]=op(st[i<<1][j],st[i<<1|1][j]);",
            "}",
            "void upd(int x, int y, int v){",
            "\tst[x+n][y+m]=v;",
            "\tfor(int j=y+m;j>1;j>>=1)st[x+n][j>>1]=op(st[x+n][j],st[x+n][j^1]);",
            "\tfor(int i=x+n;i>1;i>>=1)for(int j=y+m;j;j>>=1)",
            "\t\tst[i>>1][j]=op(st[i][j],st[i^1][j]);",
            "}",
            "int query(int x0, int x1, int y0, int y1){",
            "\tint r=NEUT;",
            "\tfor(int i0=x0+n,i1=x1+n;i0<i1;i0>>=1,i1>>=1){",
            "\t\tint t[4],q=0;",
            "\t\tif(i0&1)t[q++]=i0++;",
            "\t\tif(i1&1)t[q++]=--i1;",
            "\t\tfore(k,0,q)for(int j0=y0+m,j1=y1+m;j0<j1;j0>>=1,j1>>=1){",
            "\t\t\tif(j0&1)r=op(r,st[t[k]][j0++]);",
            "\t\t\tif(j1&1)r=op(r,st[t[k]][--j1]);",
            "\t\t}",
            "\t}",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for segtree2d.cpp"
    },
    "fenwick_tree.cpp": {
        "prefix": "fenwick_tree.cpp",
        "body": [
            "int ft[MAXN+1]; // for more dimensions, make ft multi-dimensional",
            "void upd(int i0, int v){ // add v to i0th element (0-based)",
            "\t// add extra fors for more dimensions",
            "\tfor(int i=i0+1;i<=MAXN;i+=i&-i)ft[i]+=v;",
            "}",
            "int get(int i0){ // get sum of range [0,i0)",
            "\tint r=0;",
            "\t// add extra fors for more dimensions",
            "\tfor(int i=i0;i;i-=i&-i)r+=ft[i];",
            "\treturn r;",
            "}",
            "int get_sum(int i0, int i1){ // get sum of range [i0,i1) (0-based)",
            "\treturn get(i1)-get(i0);",
            "}"
        ],
        "description": "Snippet for fenwick_tree.cpp"
    },
    "convexhull_trick.cpp": {
        "prefix": "convexhull_trick.cpp",
        "body": [
            "typedef lli tc;",
            "struct Line{tc m,h;};",
            "struct CHT { // for minimum (for maximum just change the sign of lines)",
            "\tvector<Line> c;",
            "\tint pos=0;",
            "\ttc in(Line a, Line b){",
            "\t\ttc x=b.h-a.h,y=a.m-b.m;",
            "\t\treturn x/y+(x%y?!((x>0)^(y>0)):0); // ==ceil(x/y)",
            "\t}",
            "\tvoid add(tc m, tc h){ // m's should be non increasing",
            "\t\tLine l=(Line){m,h};",
            "\t\tif(c.size()&&m==c.back().m){",
            "\t\t\tl.h=min(h,c.back().h);c.pop_back();if(pos)pos--;",
            "\t\t}",
            "\t\twhile(c.size()>1&&in(c.back(),l)<=in(c[c.size()-2],c.back())){",
            "\t\t\tc.pop_back();if(pos)pos--;",
            "\t\t}",
            "\t\tc.pb(l);",
            "\t}",
            "\tinline bool fbin(tc x, int m){return in(c[m],c[m+1])>x;}",
            "\ttc eval(tc x){",
            "\t\t// O(log n) query:",
            "\t\tint s=0,e=c.size();",
            "\t\twhile(e-s>1){int m=(s+e)/2;",
            "\t\t\tif(fbin(x,m-1))e=m;",
            "\t\t\telse s=m;",
            "\t\t}",
            "\t\treturn c[s].m*x+c[s].h;",
            "\t\t// O(1) query (for ordered x's):",
            "\t\twhile(pos>0&&fbin(x,pos-1))pos--;",
            "\t\twhile(pos<c.size()-1&&!fbin(x,pos))pos++;",
            "\t\treturn c[pos].m*x+c[pos].h;",
            "\t}",
            "};"
        ],
        "description": "Snippet for convexhull_trick.cpp"
    },
    "wavelet_tree.cpp": {
        "prefix": "wavelet_tree.cpp",
        "body": [
            "struct WT {",
            "\tvector<int> wt[1<<20];int n;",
            "\tvoid init(int k, int s, int e){",
            "\t\tif(s+1==e)return;",
            "\t\twt[k].clear();wt[k].pb(0);",
            "\t\tint m=(s+e)/2;",
            "\t\tinit(2*k,s,m);init(2*k+1,m,e);",
            "\t}",
            "\tvoid add(int k, int s, int e, int v){",
            "\t\tif(s+1==e)return;",
            "\t\tint m=(s+e)/2;",
            "\t\tif(v<m)wt[k].pb(wt[k].back()),add(2*k,s,m,v);",
            "\t\telse wt[k].pb(wt[k].back()+1),add(2*k+1,m,e,v);",
            "\t}",
            "\tint query0(int k, int s, int e, int a, int b, int i){",
            "\t\tif(s+1==e)return s;",
            "\t\tint m=(s+e)/2;",
            "\t\tint q=(b-a)-(wt[k][b]-wt[k][a]);",
            "\t\tif(i<q)return query0(2*k,s,m,a-wt[k][a],b-wt[k][b],i);",
            "\t\telse return query0(2*k+1,m,e,wt[k][a],wt[k][b],i-q);",
            "\t}",
            "\tvoid upd(int k, int s, int e, int i){",
            "\t\tif(s+1==e)return;",
            "\t\tint m=(s+e)/2;",
            "\t\tint v0=wt[k][i+1]-wt[k][i],v1=wt[k][i+2]-wt[k][i+1];",
            "\t\tif(!v0&&!v1)upd(2*k,s,m,i-wt[k][i]);",
            "\t\telse if(v0&&v1)upd(2*k+1,m,e,wt[k][i]);",
            "\t\telse if(v0)wt[k][i+1]--;",
            "\t\telse wt[k][i+1]++;",
            "\t}",
            "\tvoid init(int _n){n=_n;init(1,0,n);} // (values in range [0,n))",
            "\tvoid add(int v){add(1,0,n,v);}",
            "\tint query0(int a, int b, int i){ // ith element in range [a,b)",
            "\t\treturn query0(1,0,n,a,b,i);    // (if it was sorted)",
            "\t}",
            "\tvoid upd(int i){ // swap positions i,i+1",
            "\t\tupd(1,0,n,i);",
            "\t}",
            "};"
        ],
        "description": "Snippet for wavelet_tree.cpp"
    },
    "linkcut2.cpp": {
        "prefix": "linkcut2.cpp",
        "body": [
            "const int N_DEL = 0, N_VAL = 0; //delta, value",
            "inline int mOp(int x, int y){return x+y;}//modify",
            "inline int qOp(int lval, int rval){return lval + rval;}//query",
            "inline int dOnSeg(int d, int len){return d==N_DEL ? N_DEL : d*len;}",
            "//mostly generic",
            "inline int joinD(int d1, int d2){",
            "  if(d1==N_DEL)return d2;if(d2==N_DEL)return d1;return mOp(d1, d2);}",
            "inline int joinVD(int v, int d){return d==N_DEL ? v : mOp(v, d);}",
            "struct Node_t{",
            "  int cnt, nVal, tVal, d;",
            "  bool rev;",
            "  Node_t *c[2], *p;",
            "  Node_t(int v) : cnt(1), nVal(v), tVal(v), d(N_DEL), rev(0), p(0){",
            "    c[0]=c[1]=0;",
            "  }",
            "  bool isRoot(){return !p || (p->c[0] != this && p->c[1] != this);}",
            "  void push(){",
            "    if(rev){",
            "      rev=0; swap(c[0], c[1]);",
            "      fore(x,0,2)if(c[x])c[x]->rev^=1;",
            "    }",
            "    nVal=joinVD(nVal, d); tVal=joinVD(tVal, dOnSeg(d, cnt));",
            "    fore(x,0,2)if(c[x])c[x]->d=joinD(c[x]->d, d);",
            "    d=N_DEL;",
            "  }",
            "  void upd();",
            "};",
            "typedef Node_t* Node;",
            "int getSize(Node r){return r ? r->cnt : 0;}",
            "int getPV(Node r){",
            "  return r ? joinVD(r->tVal, dOnSeg(r->d,r->cnt)) : N_VAL;}",
            "void Node_t::upd(){",
            "  tVal = qOp(qOp(getPV(c[0]), joinVD(nVal, d)), getPV(c[1]));",
            "  cnt = 1 + getSize(c[0]) + getSize(c[1]);",
            "}",
            "void conn(Node c, Node p, int il){if(c)c->p=p;if(il>=0)p->c[!il]=c;}",
            "void rotate(Node x){",
            "  Node p = x->p, g = p->p;",
            "  bool gCh=p->isRoot(), isl = x==p->c[0];",
            "  conn(x->c[isl],p,isl); conn(p,x,!isl);",
            "  conn(x,g,gCh?-1:(p==g->c[0])); p->upd();",
            "}",
            "void spa(Node x){//splay",
            "  while(!x->isRoot()){",
            "    Node p = x->p, g = p->p;",
            "    if(!p->isRoot())g->push();",
            "    p->push(); x->push();",
            "    if(!p->isRoot())rotate((x==p->c[0])==(p==g->c[0])? p : x);",
            "    rotate(x);",
            "  }",
            "  x->push(); x->upd();",
            "}",
            "Node exv(Node x){//expose",
            "  Node last=0;",
            "  for(Node y=x; y; y=y->p)spa(y),y->c[0]=last,y->upd(),last=y;",
            "  spa(x);",
            "  return last;",
            "}",
            "void mkR(Node x){exv(x);x->rev^=1;}//makeRoot",
            "Node getR(Node x){exv(x);while(x->c[1])x=x->c[1];spa(x);return x;}",
            "Node lca(Node x, Node y){exv(x); return exv(y);}",
            "bool connected(Node x, Node y){exv(x);exv(y); return x==y?1:x->p!=0;}",
            "void link(Node x, Node y){mkR(x); x->p=y;}",
            "void cut(Node x, Node y){mkR(x); exv(y); y->c[1]->p=0; y->c[1]=0;}",
            "Node father(Node x){",
            "\texv(x);",
            "\tNode r=x->c[1];",
            "\tif(!r)return 0;",
            "\twhile(r->c[0])r=r->c[0];",
            "\treturn r;",
            "}",
            "void cut(Node x){ // cuts x from father keeping tree root",
            "\texv(father(x));x->p=0;}",
            "int query(Node x, Node y){mkR(x); exv(y); return getPV(y);}",
            "void modify(Node x, Node y, int d){mkR(x);exv(y);y->d=joinD(y->d,d);}",
            "Node lift_rec(Node x, int t){",
            "\tif(!x)return 0;",
            "\tif(t==getSize(x->c[0])){spa(x);return x;}",
            "\tif(t<getSize(x->c[0]))return lift_rec(x->c[0],t);",
            "\treturn lift_rec(x->c[1],t-getSize(x->c[0])-1);",
            "}",
            "Node lift(Node x, int t){ // t-th ancestor of x (lift(x,1) is x's father)",
            "\texv(x);return lift_rec(x,t);}",
            "int depth(Node x){ // distance from x to its tree root",
            "\texv(x);return getSize(x)-1;}"
        ],
        "description": "Snippet for linkcut2.cpp"
    },
    "stl_rope.cpp": {
        "prefix": "stl_rope.cpp",
        "body": [
            "#include <ext/rope>",
            "using namespace __gnu_cxx;",
            "rope<int> s;",
            "// Sequence with O(log(n)) random access, insert, erase at any position",
            "// s.push_back(x);",
            "// s.insert(i,r) // insert rope r at position i",
            "// s.erase(i,k) // erase subsequence [i,i+k)",
            "// s.substr(i,k) // return new rope corresponding to subsequence [i,i+k)",
            "// s[i] // access ith element (cannot modify)",
            "// s.mutable_reference_at(i) // acces ith element (allows modification)",
            "// s.begin() and s.end() are const iterators (use mutable_begin(), mutable_end() to allow modification)"
        ],
        "description": "Snippet for stl_rope.cpp"
    },
    "treap.cpp": {
        "prefix": "treap.cpp",
        "body": [
            "typedef struct item *pitem;",
            "struct item {",
            "\tint pr,key,cnt;",
            "\tpitem l,r;",
            "\titem(int key):key(key),pr(rand()),cnt(1),l(0),r(0) {}",
            "};",
            "int cnt(pitem t){return t?t->cnt:0;}",
            "void upd_cnt(pitem t){if(t)t->cnt=cnt(t->l)+cnt(t->r)+1;}",
            "void split(pitem t, int key, pitem& l, pitem& r){ // l: < key, r: >= key",
            "\tif(!t)l=r=0;",
            "\telse if(key<t->key)split(t->l,key,l,t->l),r=t;",
            "\telse split(t->r,key,t->r,r),l=t;",
            "\tupd_cnt(t);",
            "}",
            "void insert(pitem& t, pitem it){",
            "\tif(!t)t=it;",
            "\telse if(it->pr>t->pr)split(t,it->key,it->l,it->r),t=it;",
            "\telse insert(it->key<t->key?t->l:t->r,it);",
            "\tupd_cnt(t);",
            "}",
            "void merge(pitem& t, pitem l, pitem r){",
            "\tif(!l||!r)t=l?l:r;",
            "\telse if(l->pr>r->pr)merge(l->r,l->r,r),t=l;",
            "\telse merge(r->l,l,r->l),t=r;",
            "\tupd_cnt(t);",
            "}",
            "void erase(pitem& t, int key){",
            "\tif(t->key==key)merge(t,t->l,t->r);",
            "\telse erase(key<t->key?t->l:t->r,key);",
            "\tupd_cnt(t);",
            "}",
            "void unite(pitem &t, pitem l, pitem r){",
            "\tif(!l||!r){t=l?l:r;return;}",
            "\tif(l->pr<r->pr)swap(l,r);",
            "\tpitem p1,p2;split(r,l->key,p1,p2);",
            "\tunite(l->l,l->l,p1);unite(l->r,l->r,p2);",
            "\tt=l;upd_cnt(t);",
            "}",
            "pitem kth(pitem t, int k){",
            "\tif(!t)return 0;",
            "\tif(k==cnt(t->l))return t;",
            "\treturn k<cnt(t->l)?kth(t->l,k):kth(t->r,k-cnt(t->l)-1);",
            "}",
            "pair<int,int> lb(pitem t, int key){ // position and value of lower_bound",
            "\tif(!t)return {0,1<<30}; // (special value)",
            "\tif(key>t->key){",
            "\t\tauto w=lb(t->r,key);w.f+=cnt(t->l)+1;return w;",
            "\t}",
            "\tauto w=lb(t->l,key);",
            "\tif(w.f==cnt(t->l))w.s=t->key;",
            "\treturn w;",
            "}",
            ""
        ],
        "description": "Snippet for treap.cpp"
    },
    "link_cut_tree.cpp": {
        "prefix": "link_cut_tree.cpp",
        "body": [
            "typedef struct item *pitem;",
            "struct item {",
            "\tint pr;bool rev;",
            "\tpitem l,r,f,d;",
            "\titem():pr(rand()),l(0),r(0),f(0),d(0),rev(0){}",
            "};",
            "void push(pitem t){",
            "\tif(t&&t->rev){",
            "\t\tswap(t->l,t->r);",
            "\t\tif(t->l)t->l->rev^=1;",
            "\t\tif(t->r)t->r->rev^=1;",
            "\t\tt->rev=0;",
            "\t}",
            "}",
            "void merge(pitem& t, pitem l, pitem r){",
            "\tpush(l);push(r);",
            "\tif(!l||!r)t=l?l:r;",
            "\telse if(l->pr>r->pr)merge(l->r,l->r,r),l->r->f=t=l;",
            "\telse merge(r->l,l,r->l),r->l->f=t=r;",
            "}",
            "void push_all(pitem t){",
            "\tif(t->f)push_all(t->f);",
            "\tpush(t);",
            "}",
            "void split(pitem t, pitem& l, pitem& r){",
            "\tpush_all(t);",
            "\tl=t->l;r=t->r;t->l=t->r=0;",
            "\twhile(t->f){",
            "\t\tpitem f=t->f;t->f=0;",
            "\t\tif(t==f->l){",
            "\t\t\tif(r)r->f=f;",
            "\t\t\tf->l=r;r=f;",
            "\t\t}",
            "\t\telse {",
            "\t\t\tif(l)l->f=f;",
            "\t\t\tf->r=l;l=f;",
            "\t\t}",
            "\t\tt=f;",
            "\t}",
            "\tif(l)l->f=0;",
            "\tif(r)r->f=0;",
            "}",
            "pitem path(pitem p){return p->f?path(p->f):p;}",
            "pitem tail(pitem p){push(p);return p->r?tail(p->r):p;}",
            "pitem expose(pitem p){",
            "\tpitem q,r,t;",
            "\tsplit(p,q,r);",
            "\tif(q)tail(q)->d=p;",
            "\tmerge(p,p,r);",
            "\twhile(t=tail(p),t->d){",
            "\t\tpitem d=t->d;t->d=0;",
            "\t\tsplit(d,q,r);",
            "\t\tif(q)tail(q)->d=d;",
            "\t\tmerge(p,p,d);merge(p,p,r);",
            "\t}",
            "\treturn p;",
            "}",
            "pitem root(pitem v){return tail(expose(v));}",
            "void evert(pitem v){expose(v)->rev^=1;v->d=0;}",
            "void link(pitem v, pitem w){ // make v son of w",
            "\tevert(v);",
            "\tpitem p=path(v);",
            "\tmerge(p,p,expose(w));",
            "}",
            "void cut(pitem v){ // cut v from its father",
            "\tpitem p,q;",
            "\texpose(v);split(v,p,q);v->d=0;",
            "}",
            "void cut(pitem v, pitem w){evert(w);cut(v);}"
        ],
        "description": "Snippet for link_cut_tree.cpp"
    },
    "stl_extended_set.cpp": {
        "prefix": "stl_extended_set.cpp",
        "body": [
            "#include<ext/pb_ds/assoc_container.hpp>",
            "#include<ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;",
            "// find_by_order(i) -> iterator to ith element",
            "// order_of_key(k) -> position (int) of lower_bound of k"
        ],
        "description": "Snippet for stl_extended_set.cpp"
    },
    "sparse_segtree.cpp": {
        "prefix": "sparse_segtree.cpp",
        "body": [
            "#define mid l + (r - l) / 2",
            "struct Node{",
            "  lli s, mx;",
            "  Node(lli s = 0, lli mx = -INF): s(s), mx(mx) {};",
            "  Node operator + (const Node& n) {",
            "    return Node(s + n.s, max(mx, n.mx));",
            "  }",
            "};",
            "struct ST {",
            "\tNode data;",
            "\tlli l, r;",
            "  // ST(Node data = Node()): data(data), l(0), r(0) {}",
            "};",
            "ST st[MAXN];",
            "lli curst = 1; // 0 = NULL",
            "lli newST(){",
            "  st[curst].data = Node();",
            "  st[curst].l = 0;",
            "  st[curst].r = 0;",
            "  return curst++;",
            "}",
            "Node data(lli u){return u ? st[u].data : Node();}",
            "void pull(lli u){st[u].data = data(st[u].l) + data(st[u].r);}",
            "void update(lli u, lli l, lli r, lli kth, Node val){",
            "  if(l == r){",
            "    st[u].data = val;",
            "    return;",
            "  }",
            "  if(kth <= mid){",
            "    if(!st[u].l) st[u].l = newST();",
            "    update(st[u].l, l, mid, kth, val);",
            "  }",
            "  else {",
            "    if(!st[u].r) st[u].r = newST();",
            "    update(st[u].r, mid + 1, r, kth, val);",
            "  }",
            "  pull(u);",
            "}",
            "Node query(lli u, lli l, lli r, lli ll, lli rr){",
            "  if(!u or l > r or r < ll or l > rr) return Node();",
            "  if(ll <= l and r <= rr) return st[u].data;",
            "  return query(st[u].l, l, mid, ll, rr) + query(st[u].r, mid + 1, r, ll, rr);",
            "}"
        ],
        "description": "Snippet for sparse_segtree.cpp"
    },
    "sqrt_descomposition.cpp": {
        "prefix": "sqrt_descomposition.cpp",
        "body": [
            "const int N = 1e5 + 5;",
            "lli sq[320];",
            "int a[N], who[N];",
            "int block; // sqrt(N)",
            "int n;",
            "",
            "template <class T>",
            "T query(int l, int r){ // O(sqrtN)",
            "  T ans = {};",
            "  while( l <= r ){",
            "    if( l % block == 0 && l + block - 1 <= r ){",
            "      ans += sq[who[l]];",
            "      l += block;",
            "    }else{",
            "      ans += a[l++];",
            "    }",
            "  }",
            "  return ans;",
            "}",
            "",
            "void do_sqrt_descomposition(){ // O(N)",
            "  block = sqrt(n);",
            "  Forn(i, n){",
            "    who[i] = i / block;",
            "    sq[who[i]] += a[i];",
            "  }",
            "}",
            ""
        ],
        "description": "Snippet for sqrt_descomposition.cpp"
    },
    "segtree.cpp": {
        "prefix": "segtree.cpp",
        "body": [
            "struct Segtree{",
            "  #define mid (l + r) / 2",
            "  #define left(u) (u + 1)",
            "  #define right(u) (u + ((mid - l + 1) << 1))",
            "  struct Node{",
            "    lli s, mx;",
            "    Node(lli s = 0, lli mx = -INF): s(s), mx(mx) {}",
            "    Node operator + (const Node &n){",
            "      return Node(s + n.s, max(mx, n.mx));",
            "    }",
            "  };",
            "  vector<Node> st;",
            "  Segtree(int n): st(2 * n) {}",
            "  void update(int u, int l, int r, int kth, lli val){ // O(logN)",
            "    if(l == r){",
            "      st[u].s = val;",
            "      st[u].mx = val;",
            "      return;",
            "    }",
            "    if(kth <= mid) update(left(u), l, mid, kth, val);",
            "    else update(right(u), mid + 1, r, kth, val);",
            "    st[u] = st[left(u)] + st[right(u)];",
            "  }",
            "  Node query(int u, int l, int r, int ll, int rr){ // O(logN)",
            "    if(l > r or r < ll or l > rr) return Node();",
            "    if(ll <= l and r <= rr) return st[u];",
            "    return query(left(u), l, mid, ll, rr) + query(right(u), mid + 1, r, ll, rr);",
            "  }",
            "};",
            ""
        ],
        "description": "Snippet for segtree.cpp"
    },
    "lcp.cpp": {
        "prefix": "lcp.cpp",
        "body": [
            "vector<int> computeLCP(string& s, vector<int>& sa){",
            "\tint n=(int)s.size(),L=0;",
            "\tvector<int> lcp(n),plcp(n),phi(n);",
            "\tphi[sa[0]]=-1;",
            "\tfor(int i = 1; i < n; ++i) phi[sa[i]]=sa[i-1];",
            "\tfor(int i = 0; i < n; ++i){",
            "\t\tif(phi[i]<0){plcp[i]=0;continue;}",
            "\t\twhile(s[i+L]==s[phi[i]+L])L++;",
            "\t\tplcp[i]=L;",
            "\t\tL=max(L-1,0);",
            "\t}",
            "\tfor(int i = 0; i < n; ++i) lcp[i]=plcp[sa[i]];",
            "\treturn lcp; // lcp[i]=LCP(sa[i-1],sa[i])",
            "}"
        ],
        "description": "Snippet for lcp.cpp"
    },
    "manacher.cpp": {
        "prefix": "manacher.cpp",
        "body": [
            "const int MAXN = 1e6;",
            "int d1[MAXN];//d1[i] = max odd palindrome centered on i",
            "int d2[MAXN];//d2[i] = max even palindrome centered on i",
            "//s  aabbaacaabbaa",
            "//d1 1111117111111",
            "//d2 0103010010301",
            "void manacher(string& s){",
            "\tint l=0,r=-1,n=s.size();",
            "\tfor(int i = 0; i < n; ++i){",
            "\t\tint k=i>r?1:min(d1[l+r-i],r-i);",
            "\t\twhile(i+k<n&&i-k>=0&&s[i+k]==s[i-k])k++;",
            "\t\td1[i]=k--;",
            "\t\tif(i+k>r)l=i-k,r=i+k;",
            "\t}",
            "\tl=0;r=-1;",
            "\tfor(int i = 0; i < n; ++i){",
            "\t\tint k=i>r?0:min(d2[l+r-i+1],r-i+1);k++;",
            "\t\twhile(i+k<=n&&i-k>=0&&s[i+k-1]==s[i-k])k++;",
            "\t\td2[i]=--k;",
            "\t\tif(i+k-1>r)l=i-k,r=i+k-1;",
            "\t}",
            "}"
        ],
        "description": "Snippet for manacher.cpp"
    },
    "get_min_lex.cpp": {
        "prefix": "get_min_lex.cpp",
        "body": [
            "vi getminlex(vi s){",
            "\tint n=sz(s),k=0; fore(i,0,n) s.pb(s[i]);",
            "\tvi f(2*n,-1);",
            "\tfore(j,1,2*n){",
            "\t\tint i=f[j-k-1];",
            "\t\twhile(i>=0&&s[j]!=s[k+i+1]){",
            "\t\t\tif(s[j]<s[k+i+1]) k=j-i-1;",
            "\t\t\ti=f[i];",
            "\t\t}",
            "\t\tif(s[j]!=s[k+i+1]){",
            "\t\t\tif(s[j]<s[k])k=j;",
            "\t\t\tf[j-k]=-1;",
            "\t\t} else f[j-k]=i+1;",
            "\t}",
            "\tvi ans; fore(i,0,n) ans.pb(s[k+i]);",
            "\treturn ans;",
            "}"
        ],
        "description": "Snippet for get_min_lex.cpp"
    },
    "hash_128.cpp": {
        "prefix": "hash_128.cpp",
        "body": [
            "#define bint __int128",
            "struct Hash {",
            "\tbint MOD=212345678987654321LL,P=1777771,PI=106955741089659571LL;",
            "\tvector<bint> h,pi;",
            "\tHash(string& s){",
            "\t\tassert((P*PI)%MOD==1);",
            "\t\th.resize(s.size()+1);pi.resize(s.size()+1);",
            "\t\th[0]=0;pi[0]=1;",
            "\t\tbint p=1;",
            "\t\tfor(int i = 1; i < (int)(s.size()) + 1; ++i){",
            "\t\t\th[i]=(h[i-1]+p*s[i-1])%MOD;",
            "\t\t\tpi[i]=(pi[i-1]*PI)%MOD;",
            "\t\t\tp=(p*P)%MOD;",
            "\t\t}",
            "\t}",
            "\tlong long get(int s, int e){",
            "\t\treturn (((h[e]-h[s]+MOD)%MOD)*pi[s])%MOD;",
            "\t}",
            "};"
        ],
        "description": "Snippet for hash_128.cpp"
    },
    "suffix_automaton.cpp": {
        "prefix": "suffix_automaton.cpp",
        "body": [
            "struct state {int len,link;map<char,int> next;}; //clear next!!",
            "state st[100005];",
            "int sz,last;",
            "void sa_init(){",
            "\tlast=st[0].len=0;sz=1;",
            "\tst[0].link=-1;",
            "}",
            "void sa_extend(char c){",
            "\tint k=sz++,p;",
            "\tst[k].len=st[last].len+1;",
            "\tfor(p=last;p!=-1&&!st[p].next.count(c);p=st[p].link)st[p].next[c]=k;",
            "\tif(p==-1)st[k].link=0;",
            "\telse {",
            "\t\tint q=st[p].next[c];",
            "\t\tif(st[p].len+1==st[q].len)st[k].link=q;",
            "\t\telse {",
            "\t\t\tint w=sz++;",
            "\t\t\tst[w].len=st[p].len+1;",
            "\t\t\tst[w].next=st[q].next;st[w].link=st[q].link;",
            "\t\t\tfor(;p!=-1&&st[p].next[c]==q;p=st[p].link)st[p].next[c]=w;",
            "\t\t\tst[q].link=st[k].link=w;",
            "\t\t}",
            "\t}",
            "\tlast=k;",
            "}"
        ],
        "description": "Snippet for suffix_automaton.cpp"
    },
    "aho_corasick.cpp": {
        "prefix": "aho_corasick.cpp",
        "body": [
            "struct vertex {",
            "\tmap<char,int> next,go;",
            "\tint p,link;",
            "\tchar pch;",
            "\tvector<int> leaf;",
            "\tvertex(int p=-1, char pch=-1):p(p),pch(pch),link(-1){}",
            "};",
            "vector<vertex> t;",
            "void aho_init(){ //do not forget!!",
            "\tt.clear();t.push_back(vertex());",
            "}",
            "void add_string(string s, int id){",
            "\tint v=0;",
            "\tfor(char c:s){",
            "\t\tif(!t[v].next.count(c)){",
            "\t\t\tt[v].next[c]=t.size();",
            "\t\t\tt.push_back(vertex(v,c));",
            "\t\t}",
            "\t\tv=t[v].next[c];",
            "\t}",
            "\tt[v].leaf.push_back(id);",
            "}",
            "int go(int v, char c);",
            "int get_link(int v){",
            "\tif(t[v].link<0)",
            "\t\tif(!v||!t[v].p)t[v].link=0;",
            "\t\telse t[v].link=go(get_link(t[v].p),t[v].pch);",
            "\treturn t[v].link;",
            "}",
            "int go(int v, char c){",
            "\tif(!t[v].go.count(c))",
            "\t\tif(t[v].next.count(c))t[v].go[c]=t[v].next[c];",
            "\t\telse t[v].go[c]=v==0?0:go(get_link(v),c);",
            "\treturn t[v].go[c];",
            "}"
        ],
        "description": "Snippet for aho_corasick.cpp"
    },
    "suffix_array_slow.cpp": {
        "prefix": "suffix_array_slow.cpp",
        "body": [
            "const int MAXN = 1;",
            "pair<int, int> sf[MAXN];",
            "bool sacomp(int lhs, int rhs) {return sf[lhs]<sf[rhs];}",
            "vector<int> constructSA(string& s){ // O(n log^2(n))",
            "\tint n=s.size();                   // (sometimes fast enough)",
            "\tvector<int> sa(n),r(n);",
            "\tfor(int i = 0; i < n; ++i) r[i]=s[i];",
            "\tfor(int m=1;m<n;m*=2){",
            "\t\tfor(int i = 0; i < n; ++i) sa[i]=i,sf[i]={r[i],i+m<n?r[i+m]:-1};",
            "\t\tstable_sort(sa.begin(),sa.end(),sacomp);",
            "\t\tr[sa[0]]=0;",
            "\t\tfor(int i = 1; i < n; ++i) r[sa[i]]=sf[sa[i]]!=sf[sa[i-1]]?i:r[sa[i-1]];",
            "\t}",
            "\treturn sa;",
            "}"
        ],
        "description": "Snippet for suffix_array_slow.cpp"
    },
    "suffix_tree.cpp": {
        "prefix": "suffix_tree.cpp",
        "body": [
            "const int MAXN = 1e5;",
            "int INF = 1e9;",
            "struct SuffixTree {",
            "\tchar s[MAXN];",
            "\tmap<int,int> to[MAXN];",
            "\tint len[MAXN]={INF},fpos[MAXN],link[MAXN];",
            "\tint node,pos,sz=1,n=0;",
            "\tint make_node(int p, int l){",
            "\t\tfpos[sz]=p;len[sz]=l;return sz++;}",
            "\tvoid go_edge(){",
            "\t\twhile(pos>len[to[node][s[n-pos]]]){",
            "\t\t\tnode=to[node][s[n-pos]];",
            "\t\t\tpos-=len[node];",
            "\t\t}",
            "\t}",
            "\tvoid add(int c){",
            "\t\ts[n++]=c;pos++;",
            "\t\tint last=0;",
            "\t\twhile(pos>0){",
            "\t\t\tgo_edge();",
            "\t\t\tint edge=s[n-pos];",
            "\t\t\tint& v=to[node][edge];",
            "\t\t\tint t=s[fpos[v]+pos-1];",
            "\t\t\tif(v==0){",
            "\t\t\t\tv=make_node(n-pos,INF);",
            "\t\t\t\tlink[last]=node;last=0;",
            "\t\t\t}",
            "\t\t\telse if(t==c){link[last]=node;return;}",
            "\t\t\telse {",
            "\t\t\t\tint u=make_node(fpos[v],pos-1);",
            "\t\t\t\tto[u][c]=make_node(n-1,INF);",
            "\t\t\t\tto[u][t]=v;",
            "\t\t\t\tfpos[v]+=pos-1;len[v]-=pos-1;",
            "\t\t\t\tv=u;link[last]=u;last=u;",
            "\t\t\t}",
            "\t\t\tif(node==0)pos--;",
            "\t\t\telse node=link[node];",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "Snippet for suffix_tree.cpp"
    },
    "kmp.cpp": {
        "prefix": "kmp.cpp",
        "body": [
            "vector<int> kmppre(string& t){ // r[i]: longest border of t[0,i)",
            "\tvector<int> r(t.size()+1);r[0]=-1;",
            "\tint j=-1;",
            "\tfor(int i = 0; i < (int)(t.size()); ++i){",
            "\t\twhile(j>=0&&t[i]!=t[j])j=r[j];",
            "\t\tr[i+1]=++j;",
            "\t}",
            "\treturn r;",
            "}",
            "void kmp(string& s, string& t){ // find t in s",
            "\tint j=0;vector<int> b=kmppre(t);",
            "\tfor(int i = 0; i < (int)(s.size()); ++i){",
            "\t\twhile(j>=0&&s[i]!=t[j])j=b[j];",
            "\t\tif(++j==(int)t.size())printf(\"Match at %d\\n\",i-j+1),j=b[j];",
            "\t}",
            "}"
        ],
        "description": "Snippet for kmp.cpp"
    },
    "hash.cpp": {
        "prefix": "hash.cpp",
        "body": [
            "struct Hash {",
            "\tint P=1777771,MOD[2],PI[2];",
            "\tvector<int> h[2],pi[2];",
            "\tHash(string& s){",
            "\t\tMOD[0]=999727999;MOD[1]=1070777777;",
            "\t\tPI[0]=325255434;PI[1]=10018302;",
            "\t\tfor(int k = 0; k < 2; ++k)h[k].resize(s.size()+1),pi[k].resize(s.size()+1);",
            "\t\tfor(int k = 0; k < 2; ++k){",
            "\t\t\th[k][0]=0;pi[k][0]=1;",
            "\t\t\tlong long p=1;",
            "\t\t\tfor(int i = 1; i < (int)(s.size()) + 1; ++i){",
            "\t\t\t\th[k][i]=(h[k][i-1]+p*s[i-1])%MOD[k];",
            "\t\t\t\tpi[k][i]=(1LL*pi[k][i-1]*PI[k])%MOD[k];",
            "\t\t\t\tp=(p*P)%MOD[k];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tlong long get(int s, int e){",
            "\t\tlong long h0=(h[0][e]-h[0][s]+MOD[0])%MOD[0];",
            "\t\th0=(1LL*h0*pi[0][s])%MOD[0];",
            "\t\tlong long h1=(h[1][e]-h[1][s]+MOD[1])%MOD[1];",
            "\t\th1=(1LL*h1*pi[1][s])%MOD[1];",
            "\t\treturn (h0<<32)|h1;",
            "\t}",
            "};"
        ],
        "description": "Snippet for hash.cpp"
    },
    "palindromic_tree.cpp": {
        "prefix": "palindromic_tree.cpp",
        "body": [
            "struct palindromic_tree{",
            "    static const int SIGMA=26;",
            "    struct Node{",
            "        int len, link, to[SIGMA];",
            "        long long cnt;",
            "        Node(int len, int link=0, long long cnt=1):len(len),link(link),cnt(cnt){",
            "            memset(to,0,sizeof(to));",
            "        }",
            "    };",
            "    vector<Node> ns;",
            "    int last;",
            "    palindromic_tree():last(0){ns.push_back(Node(-1));ns.push_back(Node(0));}",
            "    void add(int i, string &s){",
            "        int p=last, c=s[i]-'a';",
            "        while(s[i-ns[p].len-1]!=s[i])p=ns[p].link;",
            "        if(ns[p].to[c]){",
            "            last=ns[p].to[c];",
            "            ns[last].cnt++;",
            "        }else{",
            "            int q=ns[p].link;",
            "            while(s[i-ns[q].len-1]!=s[i])q=ns[q].link;",
            "            q=max(1,ns[q].to[c]);",
            "            last=ns[p].to[c]=(int)(ns.size());",
            "            ns.push_back(Node(ns[p].len+2,q,1));",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for palindromic_tree.cpp"
    },
    "aho_crystal.cpp": {
        "prefix": "aho_crystal.cpp",
        "body": [
            "const int A = 26;",
            "struct vertex {",
            "\tvi next,go,leaf;",
            "\tint p,link,nl;",
            "\tchar pch;",
            "\tvertex(int p=-1, char pch=-1):p(p),pch(pch),link(-1),nl(-1), next(A,-1),go(A,0){}",
            "};",
            "vector<vertex> t;",
            "void aho_ini(){t.clear();t.pb(vertex());}",
            "void add(string s, int id){",
            "\tint v=0;",
            "\tfor(auto x:s){",
            "\t\tint c = x-'a';",
            "\t\tif(t[v].next[c]==-1){",
            "\t\t\tt[v].next[c]=t[v].go[c]=sz(t);",
            "\t\t\tt.pb(vertex(v,c));",
            "\t\t}",
            "\t\tv=t[v].next[c];",
            "\t}",
            "\tt[v].leaf.pb(id);",
            "}",
            "int go(int v, int c){return t[v].go[c];}",
            "void BFS(){",
            "\tqueue<int>q;",
            "\tq.push(0);",
            "\tt[0].link=t[0].nl=0;",
            "\twhile(!q.empty()){",
            "\t\tint x = q.front(); q.pop();",
            "\t\tfore(c,0,A){",
            "\t\t\tif(t[x].next[c]==-1)continue;",
            "\t\t\tint y = t[x].next[c];",
            "\t\t\tt[y].link=x?t[t[x].link].go[c]:0;",
            "\t\t\tint link = t[y].link;",
            "\t\t\tt[y].nl = sz(t[link].leaf)?link:t[link].nl;",
            "\t\t\tfor(int i = 0; i<A; i++)if(t[y].next[i]==-1)t[y].go[i]=t[link].go[i];",
            "\t\t\tq.push(y);",
            "\t\t}",
            "\t}",
            "}",
            ""
        ],
        "description": "Snippet for aho_crystal.cpp"
    },
    "z_function.cpp": {
        "prefix": "z_function.cpp",
        "body": [
            "vector<int> z_function(string& s){",
            "\tint l=0,r=0,n=s.size();",
            "\tvector<int> z(s.size(),0); // z[i] = max k: s[0,k) == s[i,i+k)",
            "\tfor(int i = 1; i < n; ++i){",
            "\t\tif(i<=r)z[i]=min(r-i+1,z[i-l]);",
            "\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;",
            "\t\tif(i+z[i]-1>r)l=i,r=i+z[i]-1;",
            "\t}",
            "\treturn z;",
            "}"
        ],
        "description": "Snippet for z_function.cpp"
    },
    "suffix_array.cpp": {
        "prefix": "suffix_array.cpp",
        "body": [
            "  ",
            "#define RB(x) (x<n?r[x]:0)",
            "void csort(vector<int>& sa, vector<int>& r, int k){",
            "\tint n=sa.size();",
            "\tvector<int> f(max(255,n),0),t(n);",
            "\tfore(i,0,n)f[RB(i+k)]++;",
            "\tint sum=0;",
            "\tfore(i,0,max(255,n))f[i]=(sum+=f[i])-f[i];",
            "\tfore(i,0,n)t[f[RB(sa[i]+k)]++]=sa[i];",
            "\tsa=t;",
            "}",
            "vector<int> constructSA(string& s){ // O(n logn)",
            "\tint n=s.size(),rank;",
            "\tvector<int> sa(n),r(n),t(n);",
            "\tfore(i,0,n)sa[i]=i,r[i]=s[i];",
            "\tfor(int k=1;k<n;k*=2){",
            "\t\tcsort(sa,r,k);csort(sa,r,0);",
            "\t\tt[sa[0]]=rank=0;",
            "\t\tfore(i,1,n){",
            "\t\t\tif(r[sa[i]]!=r[sa[i-1]]||RB(sa[i]+k)!=RB(sa[i-1]+k))rank++;",
            "\t\t\tt[sa[i]]=rank;",
            "\t\t}",
            "\t\tr=t;",
            "\t\tif(r[sa[n-1]]==n-1)break;",
            "\t}",
            "\treturn sa;",
            "}"
        ],
        "description": "Snippet for suffix_array.cpp"
    },
    "mos_algorithm.cpp": {
        "prefix": "mos_algorithm.cpp",
        "body": [
            "int n,sq,nq; // array size, sqrt(array size), #queries",
            "struct qu{int l,r,id;};",
            "qu qs[MAXN]; lli ans[MAXN]; // ans[i] = answer to ith query",
            "bool qcomp(const qu &a, const qu &b){",
            "    if(a.l/sq!=b.l/sq) return a.l<b.l;",
            "    return (a.l/sq)&1?a.r<b.r:a.r>b.r;",
            "}",
            "void mos(){",
            "    fore(i,0,nq)qs[i].id=i;",
            "    sq=sqrt(n)+.5; sort(qs,qs+nq,qcomp); int l=0,r=0; init();",
            "    fore(i,0,nq){",
            "        qu q=qs[i];",
            "        while(l>q.l)add(--l);",
            "        while(r<q.r)add(r++);",
            "        while(l<q.l)remove(l++);",
            "        while(r>q.r)remove(--r);",
            "        ans[q.id]=get_ans();",
            "    }",
            "}"
        ],
        "description": "Snippet for mos_algorithm.cpp"
    },
    "cpp_stuff.cpp": {
        "prefix": "cpp_stuff.cpp",
        "body": [
            "// double inf",
            "const double DINF=numeric_limits<double>::infinity();",
            "// Custom comparator for set/map",
            "struct comp {",
            "\tbool operator()(const double& a, const double& b) const {",
            "\t\treturn a+EPS<b;}",
            "};",
            "set<double,comp> w; // or map<double,int,comp>",
            "// Iterate over non empty subsets of bitmask",
            "for(int s=m;s;s=(s-1)&m) // Decreasing order",
            "for (int s=0;s=s-m&m;) \t // Increasing order",
            "// Return the numbers the numbers of 1-bit in x",
            "int __builtin_popcount (unsigned int x)",
            "// Returns the number of trailing 0-bits in x. x=0 is undefined.",
            "int __builtin_ctz (unsigned int x)",
            "// Returns the number of leading 0-bits in x. x=0 is undefined.",
            "int __builtin_clz (unsigned int x)",
            "// x of type long long just add 'll' at the end of the function.",
            "int __builtin_popcountll (unsigned long long x)",
            "// Get the value of the least significant bit that is one.",
            "v=(x&(-x))",
            ""
        ],
        "description": "Snippet for cpp_stuff.cpp"
    },
    "dates.cpp": {
        "prefix": "dates.cpp",
        "body": [
            "int dateToInt(int y, int m, int d){",
            "\treturn 1461*(y+4800+(m-14)/12)/4+367*(m-2-(m-14)/12*12)/12-",
            "\t\t3*((y+4900+(m-14)/12)/100)/4+d-32075;",
            "}",
            "void intToDate(int jd, int& y, int& m, int& d){",
            "\tint x,n,i,j;x=jd+68569;",
            "\tn=4*x/146097;x-=(146097*n+3)/4;",
            "\ti=(4000*(x+1))/1461001;x-=1461*i/4-31;",
            "\tj=80*x/2447;d=x-2447*j/80;",
            "\tx=j/11;m=j+2-12*x;y=100*(n-49)+i+x;",
            "}",
            "int DayOfWeek(int d, int m, int y){\t//starting on Sunday",
            "\tstatic int ttt[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};",
            "\ty-=m<3;",
            "\treturn (y+y/4-y/100+y/400+ttt[m-1]+d)%7;",
            "}",
            ""
        ],
        "description": "Snippet for dates.cpp"
    },
    "cute_lis.cpp": {
        "prefix": "cute_lis.cpp",
        "body": [
            "//This assumes no duplicates in array.",
            "set<lli> s; // multiset, for duplicate.",
            "fore(i, 0, n){",
            "  s.insert(a[i]);",
            "  auto it = s.upper_bound(a[i]);",
            "  if(it != s.end()) s.erase(it);",
            "}",
            "// Longest Strictly Increasing Subsequence.",
            "multiset<lli> s;",
            "fore(i, 0, n){",
            "  s.insert(a[i]);",
            "  auto it = s.lower_bound(a[i]);",
            "  it++;",
            "  if(it != s.end()) s.erase(it);",
            "}",
            "cout << s.size() << endl;",
            ""
        ],
        "description": "Snippet for cute_lis.cpp"
    },
    "matrix_chain_multiplication.cpp": {
        "prefix": "matrix_chain_multiplication.cpp",
        "body": [
            "lli calc(int l, int r){ // O(N ^ 3) // TODO: agregar version iterativa en O(N ^ 2)",
            "  if( l >= r ){",
            "    return 0ll;",
            "  }",
            "  lli &ans = dp[l][r];",
            "  if( ans == -1 ){",
            "    ans = inf;",
            "    For(k, l, r, +1){",
            "      ans = min(ans, calc(l, k) + calc(k + 1, r) + inc()));",
            "    }",
            "  }",
            "  return ans;",
            "}",
            ""
        ],
        "description": "Snippet for matrix_chain_multiplication.cpp"
    },
    "crt.cpp": {
        "prefix": "crt.cpp",
        "body": [
            "//Needs gcd",
            "",
            "pair<long long,long long> extendedEuclid (long long a, long long b){ //a * x + b * y = gcd(a,b)",
            "\tlong long x,y;",
            "\tif (b==0) return {1,0};",
            "\tauto p=extendedEuclid(b,a%b);",
            "\tx=p.second;",
            "\ty=p.first-(a/b)*x;",
            "\tif(a*x+b*y==-gcd(a,b)) x=-x, y=-y;",
            "\treturn {x,y};",
            "}",
            "pair<pair<long long,long long>,pair<long long,long long> > diophantine(long long a,long long b, long long r) {",
            "\t//a*x+b*y=r where r is multiple of gcd(a,b);",
            "\tlong long d=gcd(a,b);",
            "\ta/=d; b/=d; r/=d;",
            "\tauto p = extendedEuclid(a,b);",
            "\tp.first*=r; p.second*=r;",
            "\tassert(a*p.first+b*p.second==r);",
            "\treturn {p,{-b,a}}; // solutions: p+t*ans.snd",
            "}",
            "",
            "long long inv(long long a, long long m) {",
            "\tassert(gcd(a,m)==1);",
            "\tlong long x = diophantine(a,m,1).first.first;",
            "\treturn ((x%m)+m)%m;",
            "}",
            "",
            "#define mod(a,m) (((a)%m+m)%m)",
            "pair<long long,long long> sol(tuple<long long,long long,long long> c){ //requires inv, diophantine",
            "    long long a=get<0>(c), x1=get<1>(c), m=get<2>(c), d=gcd(a,m);",
            "    if(d==1) return {mod(x1*inv(a,m),m), m};",
            "    else return x1%d ? pair<long long, long long>({-1LL,-1LL}) : sol(make_tuple(a/d,x1/d,m/d));",
            "}",
            "pair<long long,long long> crt(vector< tuple<long long,long long,long long> > cond) { // returns: (sol, lcm)",
            "\tlong long x1=0,m1=1,x2,m2;",
            "\tfor(auto t:cond){",
            "\t\ttie(x2,m2)=sol(t);",
            "\t\tif((x1-x2)%gcd(m1,m2))return {-1,-1};",
            "\t\tif(m1==m2)continue;",
            "\t\tlong long k=diophantine(m2,-m1,x1-x2).first.second,l=m1*(m2/gcd(m1,m2));",
            "\t\tx1=mod((__int128)m1*k+x1,l);m1=l;",
            "\t}",
            "\treturn sol(make_tuple(1,x1,m1));",
            "} //cond[i]={ai,bi,mi} ai*xi=bi (mi); assumes lcm fits in ll",
            ""
        ],
        "description": "Snippet for crt.cpp"
    },
    "matrix_fast_pow.cpp": {
        "prefix": "matrix_fast_pow.cpp",
        "body": [
            "typedef vector<vector<long long> > Matrix;",
            "long long mod = 1e9 + 7;",
            "Matrix ones(int n) {",
            "Matrix r(n,vector<long long>(n));",
            "\tfor(int i = 0; i < n; ++i) r[i][i] = 1;",
            "\treturn r;",
            "}",
            "Matrix operator*(Matrix &a, Matrix &b) {",
            "\tint n=(int)(a.size()),m=(int)(b[0].size()),z=(int)(a[0].size());",
            "\tMatrix r(n,vector<long long>(m));",
            "\tfor(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) for(int k = 0; k < z; ++k)",
            "\t\tr[i][j]+=a[i][k]*b[k][j],r[i][j]%=mod;",
            "\treturn r;",
            "}",
            "Matrix be(Matrix b, long long e) {",
            "\tMatrix r=ones((int)(b.size()));",
            "\twhile(e){if(e&1LL)r=r*b;b=b*b;e/=2;}",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for matrix_fast_pow.cpp"
    },
    "simplex.cpp": {
        "prefix": "simplex.cpp",
        "body": [
            "vector<int> X,Y;",
            "vector<vector<double> > A;",
            "vector<double> b,c;",
            "double z;",
            "int n,m;",
            "double EPS = 1e-6;",
            "void pivot(int x,int y){",
            "\tswap(X[y],Y[x]);",
            "\tb[x]/=A[x][y];",
            "\tfor(int i = 0; i < m; ++i)if(i!=y)A[x][i]/=A[x][y];",
            "\tA[x][y]=1/A[x][y];",
            "\tfor(int i = 0; i < n; ++i)if(i!=x&&abs(A[i][y])>EPS){",
            "\t\tb[i]-=A[i][y]*b[x];",
            "\t\tfor(int j = 0; j < m; ++j)if(j!=y)A[i][j]-=A[i][y]*A[x][j];",
            "\t\tA[i][y]=-A[i][y]*A[x][y];",
            "\t}",
            "\tz+=c[y]*b[x];",
            "\tfor(int i = 0; i < m; ++i)if(i!=y)c[i]-=c[y]*A[x][i];",
            "\tc[y]=-c[y]*A[x][y];",
            "}",
            "pair<double,vector<double> > simplex( // maximize c^T x s.t. Ax<=b, x>=0",
            "\t\tvector<vector<double> > _A, vector<double> _b, vector<double> _c){",
            "\t// returns pair (maximum value, solution vector)",
            "\tA=_A;b=_b;c=_c;",
            "\tn=b.size();m=c.size();z=0.;",
            "\tX=vector<int>(m);Y=vector<int>(n);",
            "\tfor(int i = 0; i < m; ++i) X[i]=i;",
            "\tfor(int i = 0; i < n; ++i) Y[i]=i+m;",
            "\twhile(1){",
            "\t\tint x=-1,y=-1;",
            "\t\tdouble mn=-EPS;",
            "\t\tfor(int i = 0; i < n; ++i) if(b[i]<mn)mn=b[i],x=i;",
            "\t\tif(x<0)break;",
            "\t\tfor(int i = 0; i < m; ++i) if(A[x][i]<-EPS){y=i;break;}",
            "\t\tassert(y>=0); // no solution to Ax<=b",
            "\t\tpivot(x,y);",
            "\t}",
            "\twhile(1){",
            "\t\tdouble mx=EPS;",
            "\t\tint x=-1,y=-1;",
            "\t\tfor(int i = 0; i < m; ++i) if(c[i]>mx)mx=c[i],y=i;",
            "\t\tif(y<0)break;",
            "\t\tdouble mn=1e200;",
            "\t\tfor(int i = 0; i < n; ++i) if(A[i][y]>EPS&&b[i]/A[i][y]<mn)mn=b[i]/A[i][y],x=i;",
            "\t\tassert(x>=0); // c^T x is unbounded",
            "\t\tpivot(x,y);",
            "\t}",
            "\tvector<double> r(m);",
            "\tfor(int i = 0; i < n; ++i) if(Y[i]<m)r[Y[i]]=b[i];",
            "\treturn {z,r};",
            "}"
        ],
        "description": "Snippet for simplex.cpp"
    },
    "matrix_reduce.cpp": {
        "prefix": "matrix_reduce.cpp",
        "body": [
            "double reduce(vector<vector<double> >& x){ // returns determinant",
            "\tint n=x.size(),m=x[0].size();",
            "\tint i=0,j=0;double r=1.;",
            "\twhile(i<n&&j<m){",
            "\t\tint l=i;",
            "\t\tfore(k,i+1,n)if(abs(x[k][j])>abs(x[l][j]))l=k;",
            "\t\tif(abs(x[l][j])<EPS){j++;r=0.;continue;}",
            "\t\tif(l!=i){r=-r;swap(x[i],x[l]);}",
            "\t\tr*=x[i][j];",
            "\t\tfor(int k=m-1;k>=j;k--)x[i][k]/=x[i][j];",
            "\t\tfore(k,0,n){",
            "\t\t\tif(k==i)continue;",
            "\t\t\tfor(int l=m-1;l>=j;l--)x[k][l]-=x[k][j]*x[i][l];",
            "\t\t}",
            "\t\ti++;j++;",
            "\t}",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for matrix_reduce.cpp"
    },
    "linear_rec.cpp": {
        "prefix": "linear_rec.cpp",
        "body": [
            "//Needs MOD and LOG",
            "struct LinearRec{",
            "  typedef vector<int> vi;",
            "  int n; vi terms, trans; vector<vi> bin;",
            "  vi add(vi &a, vi &b){",
            "    vi res(n*2+1);",
            "    for(int i = 0; i < n + 1; ++i) for(int j = 0; j < n + 1; ++j) res[i+j]=(res[i+j]*1LL+(long long)a[i]*b[j])%MOD;",
            "    for(int i=2*n; i>n; --i){",
            "      for(int j = 0; j < n; ++j) res[i-1-j]=(res[i-1-j]*1LL+(long long)res[i]*trans[j])%MOD;",
            "      res[i]=0;",
            "    }",
            "    res.erase(res.begin()+n+1,res.end());",
            "    return res;",
            "  }",
            "  LinearRec(vi &terms, vi &trans):terms(terms),trans(trans){",
            "    n=(int)(trans.size());vi a(n+1);a[1]=1;",
            "    bin.push_back(a);",
            "    for(int i = 1; i < LOG; ++i) bin.push_back(add(bin[i-1],bin[i-1]));",
            "  }",
            "  int calc(int k){",
            "    vi a(n+1);a[0]=1;",
            "    for(int i = 0; i < LOG; ++i) if((k>>i)&1)a=add(a,bin[i]);",
            "    int ret=0;",
            "    for(int i = 0 ; i < n ; ++i) ret=((long long)ret+(long long)a[i+1]*terms[i])%MOD;",
            "    return ret;",
            "  }",
            "};"
        ],
        "description": "Snippet for linear_rec.cpp"
    },
    "number_theory.cpp": {
        "prefix": "number_theory.cpp",
        "body": [
            "struct number_theory{",
            "\tint SZ;",
            "\tvector<int> lpf, prime, mu, phi; // least prime factor, primes, mobius function, totient function, number of multiples",
            "\tnumber_theory(int SZ): SZ(SZ), lpf(SZ + 1), mu(SZ + 1, 1), phi(SZ + 1, 1){ // O(SZ)",
            "\t\tlpf[0] = lpf[1] = numeric_limits<int>::max() / 2;",
            "\t\tfor(int i = 2; i <= SZ; ++ i){",
            "\t\t\tif(!lpf[i]) lpf[i] = i, prime.push_back(i);",
            "\t\t\tif(i / lpf[i] % lpf[i]) mu[i] = -mu[i / lpf[i]], phi[i] = phi[i / lpf[i]] * (lpf[i] - 1);",
            "\t\t\telse mu[i] = 0, phi[i] = phi[i / lpf[i]] * lpf[i];",
            "\t\t\tfor(int j = 0; j < (int)prime.size() && prime[j] <= lpf[i] && prime[j] * i <= SZ; ++ j) lpf[prime[j] * i] = prime[j];",
            "\t\t}",
            "\t} ",
            "\tint mu_large(long long x){ // O(sqrt(x))",
            "\t\tint res = 1;",
            "\t\tfor(long long i = 2; i * i <= x; ++ i) if(x % i == 0){",
            "\t\t\tif(x / i % i) return 0;",
            "\t\t\tx /= i, res = -res;",
            "\t\t}",
            "\t\tif(x > 1) res = -res;",
            "\t\treturn res;",
            "\t}",
            "\tlong long phi_large(long long x){ // O(sqrt(x))",
            "\t\tlong long res = x;",
            "\t\tfor(long long i = 2; i * i <= x; ++ i) if(x % i == 0){",
            "\t\t\twhile(x % i == 0) x /= i;",
            "\t\t\tres -= res / i;",
            "\t\t}",
            "\t\tif(x > 1) res -= res / x;",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class T> // O(n log n)",
            "\tvector<T> convolute(const vector<T> &a, const vector<T> &b){",
            "\t\tint n = (int)a.size();",
            "\t\tassert(n == (int)b.size());",
            "\t\tvector<T> res(n);",
            "\t\tfor(int x = 1; x < n; ++ x) for(int y = 1; x * y < n; ++ y) res[x * y] += a[x] * b[y];",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class T> // O(n log n log k)",
            "\tvector<T> conv_exp(const vector<T> &a, long long e){",
            "\t\tint n = (int)a.size();",
            "\t\tvector<T> res(n), p(a.begin(), a.end());",
            "\t\tres[1] = 1;",
            "\t\tfor(; e; e >>= 1, p = convolute(a, a)) if(e & 1) res = convolute(res, p);",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class T> // O(n log n)",
            "\tvector<T> mobius_transform(const vector<T> &a){",
            "\t\tint n = (int)a.size();",
            "\t\tvector<T> res(n);",
            "\t\tfor(int x = 1; x < n; ++ x) for(int mx = x; mx < n; mx += x) res[mx] += a[x];",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class T> // O(n log n)",
            "\tvector<T> inverse_transform(const vector<T> &a){",
            "\t\tint n = (int)a.size();",
            "\t\tvector<T> res(n);",
            "\t\tfor(int x = 1; x < n; ++ x) for(int y = 1; x * y < n; ++ y) res[x * y] += a[x] * mu[y];",
            "\t\treturn res;",
            "\t}",
            "\tvector<int> mul_cnt;",
            "\tbool mul_cnt_ready = false;",
            "\ttemplate<class T> // O(SZ log SZ)",
            "\tvoid init_mul_cnt(const vector<int> &a){",
            "\t\tmul_cnt_ready = true;",
            "\t\tvector<int> cnt(SZ + 1);",
            "\t\tmul_cnt.assign(SZ + 1, 0);",
            "\t\tfor(auto x: a) ++ cnt[x];",
            "\t\tfor(int x = 1; x <= SZ; ++ x) for(int mx = x; mx <= SZ; mx += x) mul_cnt[x] += cnt[mx];",
            "\t}",
            "\ttemplate<class T> // Requires Z_p, O((SZ / g) log k)",
            "\tT count_tuples_with_gcd(int k, int g = 1){",
            "\t\tassert(mul_cnt_ready);",
            "\t\tT res = 0;",
            "\t\tfor(int x = SZ / g; x >= 1; -- x) res += mu[x] * (T(mul_cnt[x * g]) ^ k);",
            "\t\treturn res;",
            "\t}",
            "};",
            ""
        ],
        "description": "Snippet for number_theory.cpp"
    },
    "fft.cpp": {
        "prefix": "fft.cpp",
        "body": [
            "// MAXN must be power of 2 !!",
            "// MOD-1 needs to be a multiple of MAXN !!",
            "// big mod and primitive root for NTT:",
            "typedef long long tf;",
            "typedef vector<tf> poly;",
            "const tf MOD=2305843009255636993,RT=5;",
            "// FFT",
            "struct CD {",
            "\tdouble r,i;",
            "\tCD(double r=0, double i=0):r(r),i(i){}",
            "\tdouble real()const{return r;}",
            "\tvoid operator/=(const int c){r/=c, i/=c;}",
            "};",
            "CD operator*(const CD& a, const CD& b){",
            "\treturn CD(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}",
            "CD operator+(const CD& a, const CD& b){return CD(a.r+b.r,a.i+b.i);}",
            "CD operator-(const CD& a, const CD& b){return CD(a.r-b.r,a.i-b.i);}",
            "const double pi=acos(-1.0);",
            "// NTT",
            "/*",
            "struct CD {",
            "\ttf x;",
            "\tCD(tf x):x(x){}",
            "\tCD(){}",
            "};",
            "CD operator*(const CD& a, const CD& b){return CD(mulmod(a.x,b.x));}",
            "CD operator+(const CD& a, const CD& b){return CD(addmod(a.x,b.x));}",
            "CD operator-(const CD& a, const CD& b){return CD(submod(a.x,b.x));}",
            "vector<tf> rts(MAXN+9,-1);",
            "CD root(int n, bool inv){",
            "\ttf r=rts[n]<0?rts[n]=pm(RT,(MOD-1)/n):rts[n];",
            "\treturn CD(inv?pm(r,MOD-2):r);",
            "}",
            "*/",
            "const int MAXN = 1;",
            "CD cp1[MAXN+9],cp2[MAXN+9];",
            "int R[MAXN+9];",
            "void dft(CD* a, int n, bool inv){",
            "\tfor(int i = 0; i < n; ++i) if(R[i]<i)swap(a[R[i]],a[i]);",
            "\tfor(int m=2;m<=n;m*=2){",
            "\t\tdouble z=2*pi/m*(inv?-1:1); // FFT",
            "\t\tCD wi=CD(cos(z),sin(z)); // FFT",
            "\t\t// CD wi=root(m,inv); // NTT",
            "\t\tfor(int j=0;j<n;j+=m){",
            "\t\t\tCD w(1);",
            "\t\t\tfor(int k=j,k2=j+m/2;k2<j+m;k++,k2++){",
            "\t\t\t\tCD u=a[k];CD v=a[k2]*w;a[k]=u+v;a[k2]=u-v;w=w*wi;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif(inv) for(int i = 0; i < n; ++i) a[i]/=n; // FFT",
            "\t//if(inv){ // NTT",
            "\t//\tCD z(pm(n,MOD-2)); // pm: modular exponentiation",
            "\t//\tfore(i,0,n)a[i]=a[i]*z;",
            "\t//}",
            "}",
            "poly multiply(poly& p1, poly& p2){",
            "\tint n=(int)p1.size()+(int)p2.size()+1;",
            "\tint m=1,cnt=0;",
            "\twhile(m<=n)m+=m,cnt++;",
            "\tfor(int i = 0; i < m; ++i){R[i]=0;for(int j = 0; j < cnt; ++j)R[i]=(R[i]<<1)|((i>>j)&1);}",
            "\tfor(int i = 0; i < m; ++i)cp1[i]=0,cp2[i]=0;",
            "\tfor(int i = 0; i < (int)(p1.size()); ++i)cp1[i]=p1[i];",
            "\tfor(int i = 0; i < (int)(p2.size()); ++i)cp2[i]=p2[i];",
            "\tdft(cp1,m,false);dft(cp2,m,false);",
            "\tfor(int i = 0; i < m; ++i)cp1[i]=cp1[i]*cp2[i];",
            "\tdft(cp1,m,true);",
            "\tpoly res;",
            "\tn-=2;",
            "\tfor(int i = 0; i < n; ++i)res.push_back((tf)floor(cp1[i].real()+0.5)); // FFT",
            "\t//fore(i,0,n)res.pb(cp1[i].x); // NTT",
            "\treturn res;",
            "}"
        ],
        "description": "Snippet for fft.cpp"
    },
    "baby_step.cpp": {
        "prefix": "baby_step.cpp",
        "body": [
            "lli baby_step(lli a, lli b, lli p){",
            "  a %= p;",
            "  b %= p;",
            "  if(b == 1) return 0;",
            "  int cnt = 0;",
            "  int tmp = 1;",
            "  for(int g = gcd(a,p); g != 1; g = gcd(a,p)){",
            "    if(b%g)return -1;",
            "    p /= g; b /= g;",
            "    tmp = tmp * a / g%p;",
            "    cnt++;",
            "    if(b == tmp)return cnt;",
            "  }",
            "",
            "  unordered_map<lli, int> baby;",
            "  lli N = ceil(sqrt(p));",
            "  lli base = b;",
            "  fore(i,0,N){",
            "    baby[base]=i;",
            "    base= base * a % p;",
            "  }",
            "  base = powm(a,N,p);",
            "  lli key = tmp;",
            "  fore(i,1,N+2){",
            "    key = base * key % p;",
            "    if(baby.count(key))return i*N-baby[key]+cnt;",
            "  }",
            "  return -1;",
            "}",
            ""
        ],
        "description": "Snippet for baby_step.cpp"
    },
    "karatsuba.cpp": {
        "prefix": "karatsuba.cpp",
        "body": [
            "typedef long long tp;",
            "#define add(n,s,d,k) for(int i = 0; i < n; ++i) (d)[i]+=(s)[i]*k",
            "tp* ini(int n){tp *r=new tp[n];fill(r,r+n,0);return r;}",
            "void karatsura(int n, tp* p, tp* q, tp* r){",
            "\tif(n<=0)return;",
            "\tif(n<35)for(int i = 0; i < n; ++i)for(int j = 0; j < n; ++j)r[i+j]+=p[i]*q[j];",
            "\telse {",
            "\t\tint nac=n/2,nbd=n-n/2;",
            "\t\ttp *a=p,*b=p+nac,*c=q,*d=q+nac;",
            "\t\ttp *ab=ini(nbd+1),*cd=ini(nbd+1),*ac=ini(nac*2),*bd=ini(nbd*2);",
            "\t\tadd(nac,a,ab,1);add(nbd,b,ab,1);",
            "\t\tadd(nac,c,cd,1);add(nbd,d,cd,1);",
            "\t\tkaratsura(nac,a,c,ac);karatsura(nbd,b,d,bd);",
            "\t\tadd(nac*2,ac,r+nac,-1);add(nbd*2,bd,r+nac,-1);",
            "\t\tadd(nac*2,ac,r,1);add(nbd*2,bd,r+nac*2,1);",
            "\t\tkaratsura(nbd+1,ab,cd,r+nac);",
            "\t\tfree(ab);free(cd);free(ac);free(bd);",
            "\t}",
            "}",
            "vector<tp> multiply(vector<tp> p0, vector<tp> p1){",
            "\tint n=max(p0.size(),p1.size());",
            "\ttp *p=ini(n),*q=ini(n),*r=ini(2*n);",
            "\tfor(int i = 0; i < (int)(p0.size()); ++i) p[i]=p0[i];",
            "\tfor(int i = 0; i < (int)(p1.size()); ++i) q[i]=p1[i];",
            "\tkaratsura(n,p,q,r);",
            "\tvector<tp> rr(r,r+p0.size()+p1.size()-1);",
            "\tfree(p);free(q);free(r);",
            "\treturn rr;",
            "}"
        ],
        "description": "Snippet for karatsuba.cpp"
    },
    "simpson.cpp": {
        "prefix": "simpson.cpp",
        "body": [
            "double integrate(double f(double), double a, double b, int n=10000){",
            "\tdouble r=0,h=(b-a)/n,fa=f(a),fb;",
            "\tfor(int i = 0; i < n; ++i){fb=f(a+h*(i+1));r+=fa+4*f(a+h*(i+0.5))+fb;fa=fb;}",
            "\treturn r*h/6.;",
            "}"
        ],
        "description": "Snippet for simpson.cpp"
    },
    "bairsow.cpp": {
        "prefix": "bairsow.cpp",
        "body": [
            "// Needs a const ITER",
            "typedef double tp; // type of polynomial",
            "template<class T=tp>",
            "struct poly {  // poly<> : 1 variable, poly<poly<>>: 2 variables, etc.",
            "\tvector<T> c;",
            "\tT& operator[](int k){return c[k];}",
            "\tpoly(vector<T>& c):c(c){}",
            "\tpoly(initializer_list<T> c):c(c){}",
            "\tpoly(int k):c(k){}",
            "\tpoly(){}",
            "\tpoly operator+(poly<T> o){",
            "\t\tint m=c.size(),n=o.c.size();",
            "\t\tpoly res(max(m,n));",
            "\t\tfor(int i = 0; i < m; ++i)res[i]=res[i]+c[i];",
            "\t\tfor(int i = 0; i < n; ++i)res[i]=res[i]+o.c[i];",
            "\t\treturn res;",
            "\t}",
            "\tpoly operator*(tp k){",
            "\t\tpoly res(c.size());",
            "\t\tfor(int i = 0; i < (int)c.size(); ++i)res[i]=c[i]*k;",
            "\t\treturn res;",
            "\t}",
            "\tpoly operator*(poly o){",
            "\t\tint m=c.size(),n=o.c.size();",
            "\t\tpoly res(m+n-1);",
            "\t\tfor(int i = 0; i < m; ++i)for(int j = 0; j < n; ++j)res[i+j]=res[i+j]+c[i]*o.c[j];",
            "\t\treturn res;",
            "\t}",
            "\tpoly operator-(poly<T> o){return *this+(o*-1);}",
            "\tT operator()(tp v){",
            "\t\tT sum(0);",
            "\t\tfor(int i=c.size()-1;i>=0;--i)sum=sum*v+c[i];",
            "\t\treturn sum;",
            "\t}",
            "\tvoid print(){",
            "\t\twhile(!c.empty()&&abs(c.back())<EPS)c.pop_back();",
            "\t\tif(c.empty())puts(\" 0\");",
            "\t\telse {",
            "\t\t\tfor(auto x:c)printf(\" %.6lf\",x);",
            "\t\t\tputs(\"\");",
            "\t\t}",
            "\t}",
            "};",
            "// only for double polynomials",
            "pair<poly<>,poly<> > polydiv(poly<> p, poly<> q){ // returns pair (result,rem)",
            "\tint n=p.c.size()-q.c.size()+1;",
            "\tvector<tp> b(n);",
            "\tfor(int k=n-1;k>=0;--k){",
            "\t\tb[k]=p.c.back()/q.c.back();",
            "\t\tfor(int i = 0; i < (int)q.c.size(); ++i)p[i+k]-=b[k]*q[i];",
            "\t\tp.c.pop_back();",
            "\t}",
            "\twhile(!p.c.empty()&&abs(p.c.back())<EPS)p.c.pop_back();",
            "\treturn {poly<>(b),p};",
            "}",
            "",
            "double pget(poly<>& p, int k){return k<p.c.size()?p[k]:0;}",
            "poly<> bairstow(poly<> p){ // returns polynomial of degree 2 that",
            "\tint n=p.c.size()-1;    // divides p",
            "\tassert(n>=3&&abs(p.c.back())>EPS);",
            "\tdouble u=p[n-1]/p[n],v=p[n-2]/p[n];",
            "\tfor(int iter = 0; iter < ITER; ++iter){",
            "\t\tauto w=polydiv(p,{v,u,1});",
            "\t\tpoly<> q=w.first,r0=w.second;",
            "\t\tpoly<> r1=polydiv(q,{v,u,1}).second;",
            "\t\tdouble c=pget(r0,1),d=pget(r0,0),g=pget(r1,1),h=pget(r1,0);",
            "\t\tdouble det=1/(v*g*g+h*(h-u*g)),uu=u;",
            "\t\tu-=det*(-h*c+g*d);v-=det*(-g*v*c+(g*uu-h)*d);",
            "",
            "\t}",
            "\treturn {v,u,1};",
            "}",
            "void addr(vector<double>& r, poly<>& p){",
            "\tassert(p.c.size()<=3);",
            "\tif(p.c.size()<=1)return;",
            "\tif(p.c.size()==2)r.push_back(-p[0]/p[1]);",
            "\tif(p.c.size()==3){",
            "\t\tdouble a=p[2],b=p[1],c=p[0];",
            "\t\tdouble d=b*b-4*a*c;",
            "\t\tif(d<-0.1)return; // huge epsilon because of bad precision",
            "\t\td=d>0?sqrt(d):0;r.push_back((-b-d)/2/a);r.push_back((-b+d)/2/a);",
            "\t}",
            "}",
            "vector<double> roots(poly<> p){",
            "\twhile(!p.c.empty()&&abs(p.c.back())<EPS)p.c.pop_back();",
            "\tfor(int i = 0; i < (int)p.c.size(); ++i)p[i]/=p.c.back();",
            "\tvector<double> r;int n;",
            "\twhile((n=p.c.size()-1)>=3){",
            "\t\tpoly<> q=bairstow(p);addr(r,q);",
            "\t\tp=polydiv(p,q).first;",
            "\t\twhile((int)p.c.size()>n-1)p.c.pop_back();",
            "\t}",
            "\taddr(r,p);",
            "\treturn r;",
            "}",
            ""
        ],
        "description": "Snippet for bairsow.cpp"
    },
    "mobius.cpp": {
        "prefix": "mobius.cpp",
        "body": [
            "const int MAXN = 100;",
            "short mu[MAXN] = {0,1};",
            "void mobius(){",
            "\tfor(int i = 1; i < MAXN; ++i) if(mu[i])for(int j=i+i;j<MAXN;j+=i)mu[j]-=mu[i];",
            "}"
        ],
        "description": "Snippet for mobius.cpp"
    },
    "inversemod.cpp": {
        "prefix": "inversemod.cpp",
        "body": [
            "long long inv(long long a, long long mod) { //inverse of a modulo mod",
            "\tassert(gcd(a,mod)==1);",
            "\tpair<long long, long long> sol = extendedEuclid(a,mod);",
            "\treturn ((sol.first%mod)+mod)%mod;",
            "}"
        ],
        "description": "Snippet for inversemod.cpp"
    },
    "discrete_log.cpp": {
        "prefix": "discrete_log.cpp",
        "body": [
            "long long powm(long long a, long long b, long long mod){",
            "\tlong long res =1;",
            "\twhile(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }",
            "\treturn res;",
            "}",
            "long long discrete_log(long long a,long long b,long long m) {",
            "    a%=m, b%=m;",
            "    if(b == 1) return 0;",
            "    int cnt=0;",
            "    long long tmp=1;",
            "    for(int g=__gcd(a,m);g!=1;g=__gcd(a,m)) {",
            "        if(b%g) return -1;",
            "        m/=g, b/=g;",
            "        tmp = tmp*a/g%m;",
            "        ++cnt;",
            "        if(b == tmp) return cnt;",
            "    }",
            "    map<long long,int> w;",
            "    int s = ceil(sqrt(m));",
            "    long long base = b;",
            "    for(int i = 0; i < s; ++i) {",
            "        w[base] = i;",
            "        base=base*a%m;",
            "    }",
            "    base=powm(a,s,m);",
            "    long long key=tmp;",
            "    for(int i = 1; i < s + 2; ++i) {",
            "        key=base*key%m;",
            "        if(w.count(key)) return i*s-w[key]+cnt;",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Snippet for discrete_log.cpp"
    },
    "pollard_rho.cpp": {
        "prefix": "pollard_rho.cpp",
        "body": [
            "long long gcd(long long a, long long b){return a?gcd(b%a,a):b;}",
            "long long mulmod(long long a, long long b, long long m) {",
            "\tlong long r=a*b-(long long)((long double)a*b/m+.5)*m;",
            "\treturn r<0?r+m:r;",
            "}",
            "long long expmod(long long b, long long e, long long m){",
            "\tif(!e)return 1;",
            "\tlong long q=expmod(b,e/2,m);q=mulmod(q,q,m);",
            "\treturn e&1?mulmod(b,q,m):q;",
            "}",
            "bool is_prime_prob(long long n, long long a){",
            "\tif(n==a)return true;",
            "\tlong long s=0,d=n-1;",
            "\twhile(d%2==0)s++,d/=2;",
            "\tlong long x=expmod(a,d,n);",
            "\tif((x==1)||(x+1==n))return true;",
            "\tfor(int tt = 0; tt < s - 1; ++tt){",
            "\t\tx=mulmod(x,x,n);",
            "\t\tif(x==1)return false;",
            "\t\tif(x+1==n)return true;",
            "\t}",
            "\treturn false;",
            "}",
            "bool rabin(long long n){ // true iff n is prime",
            "\tif(n==1)return false;",
            "\tint ar[]={2,3,5,7,11,13,17,19,23};",
            "\tfor(int i = 0; i < 9; ++i)if(!is_prime_prob(n,ar[i]))return false;",
            "\treturn true;",
            "}",
            "long long rho(long long n){",
            "\tif(!(n&1))return 2;",
            "\tlong long x=2,y=2,d=1;",
            "\tlong long c=rand()%n+1;",
            "\twhile(d==1){",
            "\t\tx=(mulmod(x,x,n)+c)%n;",
            "\t\ty=(mulmod(y,y,n)+c)%n;",
            "\t\ty=(mulmod(y,y,n)+c)%n;",
            "\t\tif(x>=y)d=gcd(x-y,n);",
            "\t\telse d=gcd(y-x,n);",
            "\t}",
            "\treturn d==n?rho(n):d;",
            "}",
            "void fact(long long n, map<long long,int>& f){ //O (lg n)^3",
            "\tif(n==1)return;",
            "\tif(rabin(n)){f[n]++;return;}",
            "\tlong long q=rho(n);fact(q,f);fact(n/q,f);",
            "}",
            "// optimized version: replace rho and fact with the following:",
            "const int MAXP=1e6+1; // sieve size",
            "int sv[MAXP]; // sieve",
            "long long add(long long a, long long b, long long m){return (a+=b)<m?a:a-m;}",
            "long long rho(long long n){",
            "\tstatic long long s[MAXP];",
            "\twhile(1){",
            "\t\tlong long x=rand()%n,y=x,c=rand()%n;",
            "\t\tlong long *px=s,*py=s,v=0,p=1;",
            "\t\twhile(1){",
            "\t\t\t*py++=y=add(mulmod(y,y,n),c,n);",
            "\t\t\t*py++=y=add(mulmod(y,y,n),c,n);",
            "\t\t\tif((x=*px++)==y)break;",
            "\t\t\tlong long t=p;",
            "\t\t\tp=mulmod(p,abs(y-x),n);",
            "\t\t\tif(!p)return gcd(t,n);",
            "\t\t\tif(++v==26){",
            "\t\t\t\tif((p=gcd(p,n))>1&&p<n)return p;",
            "\t\t\t\tv=0;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(v&&(p=gcd(p,n))>1&&p<n)return p;",
            "\t}",
            "}",
            "void init_sv(){",
            "\tfor(int i = 2; i < MAXP; ++i)if(!sv[i])for(long long j=i;j<MAXP;j+=i)sv[j]=i;",
            "}",
            "void fact(long long n, map<long long,int>& f){ // call init_sv first!!!",
            "\tfor(auto&& p:f){",
            "\t\twhile(n%p.first==0){",
            "\t\t\tp.second++;",
            "\t\t\tn/=p.first;",
            "\t\t}",
            "\t}",
            "\tif(n<MAXP)while(n>1)f[sv[n]]++,n/=sv[n];",
            "\telse if(rabin(n))f[n]++;",
            "\telse {long long q=rho(n);fact(q,f);fact(n/q,f);}",
            "}"
        ],
        "description": "Snippet for pollard_rho.cpp"
    },
    "floor_division.cpp": {
        "prefix": "floor_division.cpp",
        "body": [
            "void floordiv(long long x, long long y, long long& q, long long& r) { // (for negative x)",
            "\tq=x/y;r=x%y;",
            "\tif((r!=0)&&((r<0)!=(y<0)))q--,r+=y;",
            "}"
        ],
        "description": "Snippet for floor_division.cpp"
    },
    "fht.cpp": {
        "prefix": "fht.cpp",
        "body": [
            "const int MAXN = 1;",
            "long long c1[MAXN+9],c2[MAXN+9];  // MAXN must be power of 2 !!",
            "void fht(long long* p, int n, bool inv){",
            "\tfor(int l=1;2*l<=n;l*=2)for(int i=0;i<n;i+=2*l)for(int j = 0; j < l; ++j){",
            "\t\tlong long u=p[i+j],v=p[i+l+j];",
            "\t\tif(!inv)p[i+j]=u+v,p[i+l+j]=u-v; // XOR",
            "\t\telse p[i+j]=(u+v)/2,p[i+l+j]=(u-v)/2;",
            "\t\t//if(!inv)p[i+j]=v,p[i+l+j]=u+v; // AND",
            "\t\t//else p[i+j]=-u+v,p[i+l+j]=u;",
            "\t\t//if(!inv)p[i+j]=u+v,p[i+l+j]=u; // OR",
            "\t\t//else p[i+j]=v,p[i+l+j]=u-v;",
            "\t}",
            "}",
            "// like polynomial multiplication, but XORing exponents",
            "// instead of adding them (also ANDing, ORing)",
            "vector<long long> multiply(vector<long long>& p1, vector<long long>& p2){",
            "\tint n=1<<(32-__builtin_clz(max((int)(p1.size()),(int)(p2.size())-1)));",
            "\tfor(int i = 0; i < n; ++i)c1[i]=0,c2[i]=0;",
            "\tfor(int i = 0; i < (int)(p1.size()); ++i) c1[i]=p1[i];",
            "\tfor(int i = 0; i < (int)(p2.size()); ++i) c2[i]=p2[i];",
            "\tfht(c1,n,false);fht(c2,n,false);",
            "\tfor(int i = 0; i < n; ++i) c1[i]*=c2[i];",
            "\tfht(c1,n,true);",
            "\treturn vector<long long>(c1,c1+n);",
            "}"
        ],
        "description": "Snippet for fht.cpp"
    },
    "modulo.cpp": {
        "prefix": "modulo.cpp",
        "body": [
            "using uint=unsigned;",
            "using ull=unsigned long long;",
            "struct modinfo{uint mod,root;};",
            "template<modinfo const&ref>",
            "struct modular{",
            "\tstatic constexpr uint const &mod=ref.mod;",
            "\tstatic modular root(){return modular(ref.root);}",
            "\tuint v;",
            "\t//modular(initializer_list<uint>ls):v(*ls.bg){}",
            "\tmodular(lli vv=0){s(vv%mod+mod);}",
            "\tmodular& s(uint vv){",
            "\t\tv=vv<mod?vv:vv-mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmodular operator-()const{return modular()-*this;}",
            "\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}",
            "\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}",
            "\tmodular&operator*=(const modular&rhs){",
            "\t\tv=ull(v)*rhs.v%mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}",
            "\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}",
            "\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}",
            "\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}",
            "\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}",
            "\tmodular pow(int n)const{",
            "\t\tmodular res(1),x(*this);",
            "\t\twhile(n){",
            "\t\t\tif(n&1)res*=x;",
            "\t\t\tx*=x;",
            "\t\t\tn>>=1;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tmodular inv()const{return pow(mod-2);}",
            "",
            "\tfriend modular operator+(int x,const modular&y){",
            "\t\treturn modular(x)+y;",
            "\t}",
            "\tfriend modular operator-(int x,const modular&y){",
            "\t\treturn modular(x)-y;",
            "\t}",
            "\tfriend modular operator*(int x,const modular&y){",
            "\t\treturn modular(x)*y;",
            "\t}",
            "\tfriend modular operator/(int x,const modular&y){",
            "\t\treturn modular(x)/y;",
            "\t}",
            "\tfriend ostream& operator<<(ostream&os,const modular&m){",
            "\t\treturn os<<m.v;",
            "\t}",
            "\tfriend istream& operator>>(istream&is,modular&m){",
            "\t\tlli x;is>>x;",
            "\t\tm=modular(x);",
            "\t\treturn is;",
            "\t}",
            "\tbool operator<(const modular&r)const{return v<r.v;}",
            "\tbool operator==(const modular&r)const{return v==r.v;}",
            "\tbool operator!=(const modular&r)const{return v!=r.v;}",
            "\texplicit operator bool()const{",
            "\t\treturn v;",
            "\t}",
            "};",
            "",
            "//extern constexpr modinfo base{998244353,3};",
            "extern constexpr modinfo base{1000000007,0};",
            "//modinfo base{1,0};",
            "using mint=modular<base>;",
            ""
        ],
        "description": "Snippet for modulo.cpp"
    },
    "matrices.cpp": {
        "prefix": "matrices.cpp",
        "body": [
            "",
            "template<typename T>",
            "struct Matrix{",
            "\tvector<vector<T>> a;",
            "\tMatrix(){}",
            "\tMatrix(size_t n, size_t m):a(n, vector<T>(m, 0)){}",
            "\tMatrix(size_t n):Matrix(n, n){}",
            "\tMatrix(vector<vector<T>> a):a(a){}",
            "",
            "\tsize_t height() const{ return a.size();}",
            "\tsize_t width() const{return a[0].size();}",
            "",
            "\tinline const vector<T> &operator[](size_t k) const{return a[k];}",
            "\tinline vector<T> &operator[](size_t k){return a[k];}",
            "",
            "\tstatic Matrix I(size_t n){",
            "\t\tMatrix mat(n);",
            "\t\tfor(int i=0; i<n; i++) mat[i][i]=1;",
            "\t\treturn mat;",
            "\t}",
            "",
            "\tMatrix &operator+=(const Matrix &b){",
            "\t\tsize_t n=height(), m=width();",
            "\t\tfor(int i=0; i<n; i++)for(int j=0; j<m; j++)(*this)[i][j]+=b[i][j];",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix &operator-=(const Matrix &b){",
            "\t\tsize_t n=height(), m=width();",
            "\t\tfor(int i=0; i<n; i++)for(int j=0; j<m; j++)(*this)[i][j]-=b[i][j];",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix &operator*=(const Matrix &b){",
            "\t\tsize_t n=height(), m=width(), l=b.width();",
            "\t\tvector<vector<T>> c(n, vector<T>(l, 0));",
            "\t\tfor(int i=0; i<n; i++)for(int j=0; j<l; j++)for(int k=0; k<m; k++)c[i][j]+=(*this)[i][k]*b[k][j];",
            "\t\ta.swap(c);",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix operator+(const Matrix &b) const{return (Matrix(*this)+=b);}",
            "\tMatrix operator-(const Matrix &b) const{return (Matrix(*this)-=b);}",
            "\tMatrix operator*(const Matrix &b) const{return (Matrix(*this)*=b);}",
            "",
            "\tMatrix pow(lli k) const{",
            "\t\tMatrix ap(a), ret=I(height());",
            "\t\twhile(k){",
            "\t\t\tif(k&1) ret*=ap;",
            "\t\t\tap*=ap;",
            "\t\t\tk>>=1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tstatic pair<Matrix, Matrix> Gauss_Jordan(const Matrix &a, const Matrix &b){",
            "\t\tsize_t n=a.height(), m=a.width(), l=b.width();",
            "\t\tMatrix c(n, m+l);",
            "\t\tfor(int i=0; i<n; i++) for(int j=0; j<m; j++) c[i][j]=a[i][j];",
            "\t\tfor(int i=0; i<n; i++) for(int j=0; j<l; j++) c[i][j+m]=b[i][j];",
            "\t\tint d=0;",
            "\t\tfor(int i=0; i<m; i++){",
            "\t\t\tint p=-1;",
            "\t\t\tfor(int j=d; j<n; j++)if(c[j][i]!=0){p=j; break;}",
            "\t\t\tif(p==-1) continue;",
            "\t\t\tswap(c[p], c[d]);",
            "\t\t\tT invc=T(1)/c[d][i];",
            "\t\t\tfor(int j=i; j<m+l; j++) c[d][j]*=invc;",
            "\t\t\tfor(int j=0; j<n; j++){",
            "\t\t\t\tif(j==d) continue;",
            "\t\t\t\tT c0=c[j][i];",
            "\t\t\t\tfor(int k=i; k<m+l; k++)c[j][k]-=c0*c[d][k];",
            "\t\t\t}",
            "\t\t\td++;",
            "\t\t}",
            "\t\tMatrix reta(n, m), retb(n, l);",
            "\t\tfor(int i=0; i<n; i++) for(int j=0; j<m; j++) reta[i][j]=c[i][j];",
            "\t\tfor(int i=0; i<n; i++) for(int j=0; j<l; j++) retb[i][j]=c[i][j+m];",
            "\t\treturn make_pair(reta, retb);",
            "\t}",
            "",
            "\tstatic pair<vector<T>, vector<vector<T>>> linear_equations(const Matrix &a, const vector<T> &b){",
            "\t\tint n=a.height(), m=a.width();",
            "\t\tMatrix B(n, 1);",
            "\t\tfor(int i=0; i<n; i++) B[i][0]=b[i];",
            "\t\tauto p=Gauss_Jordan(a, B);",
            "\t\tvector<int> myon(n,-1);",
            "\t\tvector<int> nuo(m, -1);",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tbool allzero=1;",
            "\t\t\tfor(int j=0; j<m; j++)if(p.first[i][j]!=0){",
            "\t\t\t\t\tallzero=0;",
            "\t\t\t\t\tmyon[i]=j;",
            "\t\t\t\t\tnuo[j]=i;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\tif(allzero && p.second[i][0]!=0){",
            "\t\t\t\tvector<T> retc;",
            "\t\t\t\tvector<vector<T>> retd;",
            "\t\t\t\treturn make_pair(retc, retd);",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<T> c(m);",
            "\t\tvector<vector<T>> d;",
            "\t\tfor(int i=0; i<m; i++){",
            "\t\t\tif(nuo[i]==-1){",
            "\t\t\t\tvector<T> v(m);",
            "\t\t\t\tv[i]=1;",
            "\t\t\t\tfor(int j=0; j<n; j++)if(myon[j]!=-1) v[myon[j]]=-p.first[j][i];",
            "\t\t\t\td.push_back(v);",
            "\t\t\t}else c[i]=p.second[nuo[i]][0];",
            "\t\t}",
            "\t\treturn make_pair(c, d);",
            "\t}",
            "",
            "\tMatrix inv() const{",
            "\t\tint n=height();",
            "\t\tMatrix b=I(n);",
            "\t\tauto p=Gauss_Jordan(*this, b);",
            "\t\tif(p.first[n-1][n-1]==0){",
            "\t\t\tMatrix ret(0);",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\treturn p.second;",
            "\t}",
            "",
            "\tint rank() const{",
            "\t\tint n=height(), m=width();",
            "\t\tMatrix b(n, 0);",
            "\t\tauto p=Gauss_Jordan(*this, b);",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tbool allzero=1;",
            "\t\t\tfor(int j=0; j<m; j++)if(p.first[i][j]!=0){",
            "\t\t\t\t\tallzero=0;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\tif(allzero) return i;",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "",
            "\tT det() const{",
            "\t\tsize_t n=height();",
            "\t\tMatrix A(a);",
            "\t\tT ret(1);",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tint p=-1;",
            "\t\t\tfor(int j=i; j<n; j++)if(A[j][i]!=0){",
            "\t\t\t\t\tp=j; break;",
            "\t\t\t\t}",
            "\t\t\tif(p==-1)return 0;",
            "\t\t\tif(p!=i) ret*=(-1);",
            "\t\t\tswap(A[p], A[i]);",
            "\t\t\tret*=A[i][i];",
            "\t\t\tT inva=T(1)/A[i][i];",
            "\t\t\tfor(int j=i+1; j<n; j++){",
            "\t\t\t\tT a0=A[j][i];",
            "\t\t\t\tfor(int k=i; k<n; k++)A[j][k]-=inva*a0*A[i][k];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "};",
            ""
        ],
        "description": "Snippet for matrices.cpp"
    },
    "frac.cpp": {
        "prefix": "frac.cpp",
        "body": [
            "struct frac {",
            "\ttemplate <typename T> static constexpr inline T gcd(const T a, const T b) { return (b == 0) ? a : gcd(b, a % b); }",
            "\t__int128_t q, p;",
            "\tinline constexpr void simplify() {",
            "\t\tif(p < 0) {",
            "\t\t\tp *= -1;",
            "\t\t\tq *= -1;",
            "\t\t}",
            "\t\tll g = gcd(q < 0 ? -q : q, p);",
            "\t\tif(g) {",
            "\t\t\tp /= g;",
            "\t\t\tq /= g;",
            "\t\t}",
            "\t}",
            "\tconstexpr frac(ll q = 0, ll p = 1) noexcept : q(q), p(p) { simplify(); }",
            "",
            "\tconstexpr bool operator<(const frac &r) const { return q * r.p < p * r.q; }",
            "\tconstexpr bool operator<=(const frac &r) const { return q * r.p <= p * r.q; }",
            "",
            "\tconstexpr bool operator>(const frac &r) const { return q * r.p > p * r.q; }",
            "\tconstexpr bool operator>=(const frac &r) const { return q * r.p >= p * r.q; }",
            "",
            "\ttemplate <class T> const bool operator<(const T &r) const { return *this < frac(r); }",
            "\ttemplate <class T> const bool operator>(const T &r) const { return *this > frac(r); }",
            "\tconstexpr bool operator!=(const frac &r) const { return q * r.p < p * r.q; }",
            "\tconstexpr bool operator==(const frac &r) const { return q * r.p == p * r.q; }",
            "\tconstexpr frac operator+(const frac r) const noexcept { return frac(*this) += r; }",
            "\tconstexpr frac operator-(const frac r) const noexcept { return frac(*this) -= r; }",
            "\tconstexpr frac operator*(const frac r) const noexcept { return frac(*this) *= r; }",
            "\tconstexpr frac operator/(const frac r) const noexcept { return frac(*this) /= r; }",
            "\tconstexpr frac &operator+=(const frac &r) noexcept {",
            "\t\t__int128_t g = 1;",
            "\t\tq = r.p / g * q + p / g * r.q;",
            "\t\tp = p / g * r.p;",
            "\t\t(*this).simplify();",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr frac &operator-=(const frac &r) noexcept {",
            "\t\t__int128_t g = 1;",
            "\t\tq = r.p / g * q - p / g * r.q;",
            "\t\tp = p / g * r.p;",
            "\t\t(*this).simplify();",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr frac &operator*=(const frac &r) noexcept {",
            "\t\tq *= r.q;",
            "\t\tp *= r.p;",
            "\t\t(*this).simplify();",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr frac &operator/=(const frac &r) noexcept {",
            "\t\tq *= r.p;",
            "\t\tp *= r.q;",
            "\t\t(*this).simplify();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tvoid print() {",
            "\t\tlong double tmp = (long double)q / (long double)p;",
            "\t\tcout << tmp;",
            "\t}",
            "};",
            ""
        ],
        "description": "Snippet for frac.cpp"
    },
    "berlekamp_massey.cpp": {
        "prefix": "berlekamp_massey.cpp",
        "body": [
            "long long MOD = 1e9 + 7;",
            "long long powm(long long a, long long b, long long mod){",
            "\tlong long res =1;",
            "\twhile(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }",
            "\treturn res;",
            "}",
            "vector<int> BM(vector<int> x){",
            "vector<int> ls,cur;int lf,ld;",
            "for(int i = 0; i < (int)(x.size()); ++i){",
            "\tlong long t=0;",
            "\tfor(int j = 0; j < (int)(cur.size()); ++j) t=(t+x[i-j-1]*(long long)cur[j])%MOD;",
            "\tif((t-x[i])%MOD==0)continue;",
            "\tif(!(int)cur.size()){cur.resize(i+1);lf=i;ld=(t-x[i])%MOD;continue;}",
            "\tlong long k=-(x[i]-t)*powm(ld,MOD-2, MOD)%MOD;",
            "\tvector<int> c(i-lf-1);c.push_back(k);",
            "\tfor(int j = 0; j < (int)(ls.size()); ++j) c.push_back(-ls[j]*k%MOD);",
            "\tif((int)c.size()<(int)(cur.size()))c.resize((int)(cur.size()));",
            "\tfor(int j = 0; j < (int)(cur.size()); ++j) c[j]=(c[j]+cur[j])%MOD;",
            "\tif(i-lf+(int)(ls.size())>=(int)(cur.size()))ls=cur,lf=i,ld=(t-x[i])%MOD;",
            "\tcur=c;",
            "}",
            "for(int i = 0; i < (int)(cur.size()); ++i) cur[i]=(cur[i]%MOD+MOD)%MOD;",
            "return cur;",
            "}"
        ],
        "description": "Snippet for berlekamp_massey.cpp"
    },
    "points_under_line.cpp": {
        "prefix": "points_under_line.cpp",
        "body": [
            "long long f(long long a, long long b, long long c){",
            "\tif(c<=0) return 0;",
            "\tif(a<b) swap(a, b);",
            "\tlong long m=c/a;",
            "\tif(a==b) return m*(m-1)/2;",
            "\tlong long k=(a-1)/b, h=(c-a*m)/b;",
            "\treturn f(b,a-b*k,c-b*(k*m+h))+k*m*(m-1)/2+m*h;",
            "}",
            "",
            "// # of lattice points s.t. ax+by<=c, 0<x<=X, 0<y<=Y (a,b is positive integer)",
            "long long g(long long a, long long b, long long c, long long X, long long Y){",
            "\tif(a*X+b*Y<=c) return X*Y;",
            "\treturn f(a,b,c)-f(a,b,c-a*X)-f(a,b,c-b*Y)+f(a,b,c-a*X-b*Y);",
            "}"
        ],
        "description": "Snippet for points_under_line.cpp"
    },
    "extended_euclid.cpp": {
        "prefix": "extended_euclid.cpp",
        "body": [
            "long long euclid(long long a, long long b, long long& x, long long& y){ // a*(x+k*(b/d))+b*(y-k*(a/d))=d",
            "if(!b){x=1;y=0;return a;}          // (for any k)",
            "long long d=euclid(b,a%b,x,y);",
            "long long t=y;y=x-(a/b)*y;x=t;",
            "return d;",
            "}"
        ],
        "description": "Snippet for extended_euclid.cpp"
    },
    "fft_operations.cpp": {
        "prefix": "fft_operations.cpp",
        "body": [
            "long long powm(long long a, long long b, long long mod){",
            "\tlong long res =1;",
            "\twhile(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }",
            "\treturn res;",
            "}",
            "long long inv(long long a, long long mod) {",
            "\treturn powm(a, mod - 2, mod);",
            "}",
            "// MAXN must be power of 2 !!",
            "// MOD-1 needs to be a multiple of MAXN !!",
            "// big mod and primitive root for NTT:",
            "typedef long long tf;",
            "typedef vector<tf> poly;",
            "const tf MOD=2305843009255636993,RT=5;",
            "// FFT",
            "struct CD {",
            "\tdouble r,i;",
            "\tCD(double r=0, double i=0):r(r),i(i){}",
            "\tdouble real()const{return r;}",
            "\tvoid operator/=(const int c){r/=c, i/=c;}",
            "};",
            "CD operator*(const CD& a, const CD& b){",
            "\treturn CD(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}",
            "CD operator+(const CD& a, const CD& b){return CD(a.r+b.r,a.i+b.i);}",
            "CD operator-(const CD& a, const CD& b){return CD(a.r-b.r,a.i-b.i);}",
            "const double pi=acos(-1.0);",
            "// NTT",
            "/*",
            "struct CD {",
            "\ttf x;",
            "\tCD(tf x):x(x){}",
            "\tCD(){}",
            "};",
            "CD operator*(const CD& a, const CD& b){return CD(mulmod(a.x,b.x));}",
            "CD operator+(const CD& a, const CD& b){return CD(addmod(a.x,b.x));}",
            "CD operator-(const CD& a, const CD& b){return CD(submod(a.x,b.x));}",
            "vector<tf> rts(MAXN+9,-1);",
            "CD root(int n, bool inv){",
            "\ttf r=rts[n]<0?rts[n]=pm(RT,(MOD-1)/n):rts[n];",
            "\treturn CD(inv?pm(r,MOD-2):r);",
            "}",
            "*/",
            "const int MAXN = 1;",
            "CD cp1[MAXN+9],cp2[MAXN+9];",
            "int R[MAXN+9];",
            "void dft(CD* a, int n, bool inv){",
            "\tfor(int i = 0; i < n; ++i) if(R[i]<i)swap(a[R[i]],a[i]);",
            "\tfor(int m=2;m<=n;m*=2){",
            "\t\tdouble z=2*pi/m*(inv?-1:1); // FFT",
            "\t\tCD wi=CD(cos(z),sin(z)); // FFT",
            "\t\t// CD wi=root(m,inv); // NTT",
            "\t\tfor(int j=0;j<n;j+=m){",
            "\t\t\tCD w(1);",
            "\t\t\tfor(int k=j,k2=j+m/2;k2<j+m;k++,k2++){",
            "\t\t\t\tCD u=a[k];CD v=a[k2]*w;a[k]=u+v;a[k2]=u-v;w=w*wi;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif(inv) for(int i = 0; i < n; ++i) a[i]/=n; // FFT",
            "\t//if(inv){ // NTT",
            "\t//\tCD z(pm(n,MOD-2)); // pm: modular exponentiation",
            "\t//\tfore(i,0,n)a[i]=a[i]*z;",
            "\t//}",
            "}",
            "poly multiply(poly& p1, poly& p2){",
            "\tint n=(int)p1.size()+(int)p2.size()+1;",
            "\tint m=1,cnt=0;",
            "\twhile(m<=n)m+=m,cnt++;",
            "\tfor(int i = 0; i < m; ++i){R[i]=0;for(int j = 0; j < cnt; ++j)R[i]=(R[i]<<1)|((i>>j)&1);}",
            "\tfor(int i = 0; i < m; ++i)cp1[i]=0,cp2[i]=0;",
            "\tfor(int i = 0; i < (int)(p1.size()); ++i)cp1[i]=p1[i];",
            "\tfor(int i = 0; i < (int)(p2.size()); ++i)cp2[i]=p2[i];",
            "\tdft(cp1,m,false);dft(cp2,m,false);",
            "\tfor(int i = 0; i < m; ++i)cp1[i]=cp1[i]*cp2[i];",
            "\tdft(cp1,m,true);",
            "\tpoly res;",
            "\tn-=2;",
            "\tfor(int i = 0; i < n; ++i)res.push_back((tf)floor(cp1[i].real()+0.5)); // FFT",
            "\t//fore(i,0,n)res.pb(cp1[i].x); // NTT",
            "\treturn res;",
            "}",
            "",
            "//Polynomial division: O(n*log(n))",
            "//Multi-point polynomial evaluation: O(n*log^2(n))",
            "//Polynomial interpolation: O(n*log^2(n))",
            "long long addmod(long long a, long long b) {",
            "\tif(a + b > MOD) return (a + b) - MOD;",
            "\treturn a + b;",
            "}",
            "long long submod(long long a, long long b) {",
            "\tif(a - b < 0) return (a - b) + MOD;",
            "\treturn a - b;",
            "}",
            "long long mulmod(long long a, long long b) {",
            "\treturn (a * b) % MOD;",
            "}",
            "//Works with NTT. For FFT, just replace addmod,submod,mulmod,inv",
            "poly add(poly &a, poly &b){",
            "\tint n=(int)a.size(),m=(int)b.size();",
            "\tpoly ans(max(n,m));",
            "\tfor(int i = 0; i < max(n, m); ++i){",
            "\t\tif(i<n) ans[i]=addmod(ans[i],a[i]);",
            "\t\tif(i<m) ans[i]=addmod(ans[i],b[i]);",
            "\t}",
            "\twhile((int)(ans.size())>1&&!ans.back())ans.pop_back();",
            "\treturn ans;",
            "}",
            "",
            "poly invert(poly &b, int d){",
            " poly c = {inv(b[0], MOD)};",
            " while((int)(c.size())<=d){",
            " \tint j=2*(int)(c.size());",
            "  auto bb=b; bb.resize(j);",
            "  poly cb=multiply(c,bb);",
            "  for(int i = 0; i < (int)(cb.size()); ++i) cb[i]=submod(0,cb[i]);",
            "  cb[0]=addmod(cb[0],2);",
            "  c=multiply(c,cb);",
            "  c.resize(j);",
            " }",
            " c.resize(d+1);",
            " return c;",
            "}",
            "",
            "pair<poly,poly> divslow(poly &a, poly &b){",
            "\tpoly q,r=a;",
            "\twhile((int)(r.size())>=(int)(b.size())){",
            "\t\tq.push_back(mulmod(r.back(),inv(b.back(), MOD)));",
            "\t\tif(q.back()) for(int i = 0; i < (int)(b.size()); ++i){",
            "\t\t\tr[(int)(r.size())-i-1]=submod(r[(int)(r.size())-i-1],mulmod(q.back(),b[(int)(b.size())-i-1]));",
            "\t\t}",
            "\t\tr.pop_back();",
            "\t}",
            "\treverse(q.begin(), q.end());",
            "\treturn {q,r};",
            "}",
            "",
            "pair<poly,poly> divide(poly &a, poly &b){\t//returns {quotient,remainder}",
            "\tint m=(int)(a.size()),n=(int)(b.size()),MAGIC=750;",
            "\tif(m<n) return {{0},a};",
            "\tif(min(m-n,n)<MAGIC)return divslow(a,b);",
            "\tpoly ap=a; reverse(ap.begin(), ap.end());",
            "\tpoly bp=b; reverse(bp.begin(), bp.end());",
            "\tbp=invert(bp,m-n);",
            "\tpoly q=multiply(ap,bp);",
            "\tq.resize((int)(q.size())+m-n-(int)(q.size())+1,0);",
            "\treverse(q.begin(), q.end());",
            "\tpoly bq=multiply(b,q);",
            "\tfor(int i = 0; i < (int)(bq.size()); ++i) bq[i]=submod(0,bq[i]);",
            "\tpoly r=add(a,bq);",
            "\treturn {q,r};",
            "}",
            "",
            "vector<poly> tree;",
            "",
            "void filltree(vector<tf> &x){",
            "\tint k=(int)(x.size());",
            "\ttree.resize(2*k);",
            "\tfor(int i = k; i < 2 * k; ++i)  tree[i]={submod(0,x[i-k]),1};",
            "\tfor(int i=k-1;i;i--) tree[i]=multiply(tree[2*i],tree[2*i+1]);",
            "}",
            "",
            "vector<tf> evaluate(poly &a, vector<tf> &x){",
            "\tfilltree(x);",
            "\tint k=(int)(x.size());",
            "\tvector<poly> ans(2*k);",
            "\tans[1]=divide(a,tree[1]).second;",
            "\tfor(int i = 2; i < 2 * k; ++i) ans[i]=divide(ans[i>>1],tree[i]).second;",
            "\tvector<tf> r; for(int i = 0; i < k; ++i) r.push_back(ans[i+k][0]);",
            "\treturn r;",
            "}",
            "",
            "poly derivate(poly &p){",
            "\tpoly ans((int)(p.size())-1);",
            "\tfor(int i = 1; i < (int)(p.size()); ++i) ans[i-1]=mulmod(p[i],i);",
            "\treturn ans;",
            "}",
            "",
            "poly interpolate(vector<tf> &x, vector<tf> &y){",
            "\tfilltree(x);",
            "\tpoly p=derivate(tree[1]);",
            "\tint k=(int)(y.size());",
            "\tvector<tf> d=evaluate(p,x);",
            "\tvector<poly> intree(2*k);",
            "\tfor(int i = k; i < 2 * k; ++i) intree[i]={mulmod(y[i-k],inv(d[i-k], MOD))};",
            "\tfor(int i=k-1;i;i--){",
            "\t\tpoly p1=multiply(tree[2*i],intree[2*i+1]);",
            "\t\tpoly p2=multiply(tree[2*i+1],intree[2*i]);",
            "\t\tintree[i]=add(p1,p2);",
            "\t}",
            "\treturn intree[1];",
            "}"
        ],
        "description": "Snippet for fft_operations.cpp"
    },
    "catalan.cpp": {
        "prefix": "catalan.cpp",
        "body": [
            "int catalan[MAX];",
            "void init() {",
            "    catalan[0] = catalan[1] = 1;",
            "    for (int i=2; i<=n; i++) {",
            "        catalan[i] = 0;",
            "        for (int j=0; j < i; j++) {",
            "            catalan[i] += (catalan[j] * catalan[i-j-1]) % MOD;",
            "            if (catalan[i] >= MOD) {",
            "                catalan[i] -= MOD;",
            "            }",
            "        }",
            "    }",
            "}",
            ""
        ],
        "description": "Snippet for catalan.cpp"
    },
    "double_cmp.cpp": {
        "prefix": "double_cmp.cpp",
        "body": [
            "typedef long double td;",
            "const td eps = 1e-9, inf = numeric_limits<ld>::max(), pi = acos(-1);",
            "// For use with integers, just set eps=0 and everything remains the same",
            "bool geq(td a, td b){return a-b >= -eps;}     //a >= b",
            "bool leq(td a, td b){return b-a >= -eps;}     //a <= b",
            "bool ge(td a, td b){return a-b > eps;}        //a > b",
            "bool le(td a, td b){return b-a > eps;}        //a < b",
            "bool eq(td a, td b){return abs(a-b) <= eps;}  //a == b",
            "bool neq(td a, td b){return abs(a-b) > eps;}  //a != b"
        ],
        "description": "Snippet for double_cmp.cpp"
    },
    "divisors.cpp": {
        "prefix": "divisors.cpp",
        "body": [
            "void div_rec(vector<long long>& r, vector<pair<long long,int> >& f, int k, long long c){",
            "\tif(k==(int)f.size()){r.push_back(c);return;}",
            "\tfor(int i = 0; i < f[k].second + 1; ++i) div_rec(r,f,k+1,c),c*=f[k].first;",
            "}",
            "vector<long long> divisors(vector<pair<long long,int> > f){",
            "\tvector<long long> r; // returns divisors given factorization",
            "\tdiv_rec(r,f,0,1);",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for divisors.cpp"
    },
    "diophantine.cpp": {
        "prefix": "diophantine.cpp",
        "body": [
            "//Need gcd",
            "pair<long long,long long> extendedEuclid (long long a, long long b){ //a * x + b * y = gcd(a,b)",
            "\tlong long x,y;",
            "\tif (b==0) return {1,0};",
            "\tauto p=extendedEuclid(b,a%b);",
            "\tx=p.second;",
            "\ty=p.first-(a/b)*x;",
            "\tif(a*x+b*y==-gcd(a,b)) x=-x, y=-y;",
            "\treturn {x,y};",
            "}",
            "pair<pair<long long,long long>,pair<long long,long long> > diophantine(long long a,long long b, long long r) {",
            "\t//a*x+b*y=r where r is multiple of gcd(a,b);",
            "\tlong long d=gcd(a,b);",
            "\ta/=d; b/=d; r/=d;",
            "\tauto p = extendedEuclid(a,b);",
            "\tp.first*=r; p.second*=r;",
            "\tassert(a*p.first+b*p.second==r);",
            "\treturn {p,{-b,a}}; // solutions: p+t*ans.snd",
            "}"
        ],
        "description": "Snippet for diophantine.cpp"
    },
    "tonelli_shanks.cpp": {
        "prefix": "tonelli_shanks.cpp",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "long long rnd(long long a, long long b){return uniform_int_distribution<long long>(a, b)(rng);}",
            "long long powm(long long a, long long b, long long mod){",
            "\tlong long res =1;",
            "\twhile(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }",
            "\treturn res;",
            "}",
            "long long legendre(long long a, long long p){",
            "  if(a%p==0)return 0; if(p==2)return 1;",
            "  return powm(a,(p-1)/2,p);",
            "}",
            "long long tonelli_shanks(long long n, long long p){\t// sqrt(n) mod p (p must be a prime)",
            "  assert(legendre(n,p)==1); if(p==2)return 1;",
            "  long long s=__builtin_ctzll(p-1), q=(p-1LL)>>s, z=rnd(1,p-1);",
            "  if(s==1)return powm(n,(p+1)/4LL,p);",
            "  while(legendre(z,p)!=p-1)z=rnd(1,p-1);",
            "  long long c=powm(z,q,p), r=powm(n,(q+1)/2,p), t=powm(n,q,p), m=s;",
            "  while(t!=1){",
            "    long long i=1, ts=(t*t)%p;",
            "    while(ts!=1)i++,ts=(ts*ts)%p;",
            "    long long b=c;",
            "    for(int tt = 0; tt < m - i - 1; ++tt) b=(b*b)%p;",
            "    r=r*b%p;c=b*b%p;t=t*c%p;m=i;",
            "  }",
            "  return r;",
            "}"
        ],
        "description": "Snippet for tonelli_shanks.cpp"
    },
    "polynomial.cpp": {
        "prefix": "polynomial.cpp",
        "body": [
            "///Needs a EPS",
            "typedef int tp; // type of polynomial",
            "template<class T=tp>",
            "struct poly {  // poly<> : 1 variable, poly<poly<>>: 2 variables, etc.",
            "\tvector<T> c;",
            "\tT& operator[](int k){return c[k];}",
            "\tpoly(vector<T>& c):c(c){}",
            "\tpoly(initializer_list<T> c):c(c){}",
            "\tpoly(int k):c(k){}",
            "\tpoly(){}",
            "\tpoly operator+(poly<T> o){",
            "\t\tint m=c.size(),n=o.c.size();",
            "\t\tpoly res(max(m,n));",
            "\t\tfor(int i = 0; i < m; ++i)res[i]=res[i]+c[i];",
            "\t\tfor(int i = 0; i < n; ++i)res[i]=res[i]+o.c[i];",
            "\t\treturn res;",
            "\t}",
            "\tpoly operator*(tp k){",
            "\t\tpoly res(c.size());",
            "\t\tfor(int i = 0; i < (int)c.size(); ++i)res[i]=c[i]*k;",
            "\t\treturn res;",
            "\t}",
            "\tpoly operator*(poly o){",
            "\t\tint m=c.size(),n=o.c.size();",
            "\t\tpoly res(m+n-1);",
            "\t\tfor(int i = 0; i < m; ++i) for(int j = 0; j < n; ++j)res[i+j]=res[i+j]+c[i]*o.c[j];",
            "\t\treturn res;",
            "\t}",
            "\tpoly operator-(poly<T> o){return *this+(o*-1);}",
            "\tT operator()(tp v){",
            "\t\tT sum(0);",
            "\t\tfor(int i=(int)c.size()-1;i>=0;--i)sum=sum*v+c[i];",
            "\t\treturn sum;",
            "\t}",
            "};",
            "// example: p(x,y)=2*x^2+3*x*y-y+4",
            "// poly<poly<>> p={{4,-1},{0,3},{2}}",
            "// printf(\"%d\\n\",p(2)(3)) // 27 (p(2,3))",
            "set<tp> roots(poly<> p){ // only for integer polynomials",
            "\tset<tp> r;",
            "\twhile(!p.c.empty()&&!p.c.back())p.c.pop_back();",
            "\tif(!p(0))r.insert(0);",
            "\tif(p.c.empty())return r;",
            "\ttp a0=0,an=abs(p[p.c.size()-1]);",
            "\tfor(int k=0;!a0;a0=abs(p[k++]));",
            "\tvector<tp> ps,qs;",
            "\tfor(int i = 1; i < sqrt(a0)+1; ++i)if(a0%i==0)ps.push_back(i),ps.push_back(a0/i);",
            "\tfor(int i = 1; i < sqrt(an)+1; ++i)if(an%i==0)qs.push_back(i),qs.push_back(an/i);",
            "\tfor(auto pt:ps)for(auto qt:qs)if(pt%qt==0){",
            "\t\ttp x=pt/qt;",
            "\t\tif(!p(x))r.insert(x);",
            "\t\tif(!p(-x))r.insert(-x);",
            "\t}",
            "\treturn r;",
            "}",
            "pair<poly<>,tp> ruffini(poly<> p, tp r){ // returns pair (result,rem)",
            "\tint n=p.c.size()-1;",
            "\tvector<tp> b(n);",
            "\tb[n-1]=p[n];",
            "\tfor(int k=n-2;k>=0;--k)b[k]=p[k+1]+r*b[k+1];",
            "\treturn {poly<>(b),p[0]+r*b[0]};",
            "}",
            "// only for double polynomials",
            "pair<poly<>,poly<> > polydiv(poly<> p, poly<> q){ // returns pair (result,rem)",
            "\tint n=p.c.size()-q.c.size()+1;",
            "\tvector<tp> b(n);",
            "\tfor(int k=n-1;k>=0;--k){",
            "\t\tb[k]=p.c.back()/q.c.back();",
            "\t\tfor(int i = 0; i < (int)q.c.size(); ++i)p[i+k]-=b[k]*q[i];",
            "\t\tp.c.pop_back();",
            "\t}",
            "\twhile(!p.c.empty()&&abs(p.c.back())<EPS)p.c.pop_back();",
            "\treturn {poly<>(b),p};",
            "}",
            "// only for double polynomials",
            "poly<> interpolate(vector<tp> x, vector<tp> y){ //TODO TEST",
            "\tpoly<> q={1},S={0};",
            "\tfor(tp a:x)q=poly<>({-a,1})*q;",
            "\tfor(int i = 0; i < (int)x.size(); ++i){",
            "\t\tpoly<> Li=ruffini(q,x[i]).first;",
            "\t\tLi=Li*(1.0/Li(x[i])); // change for int polynomials",
            "\t\tS=S+Li*y[i];",
            "\t}",
            "\treturn S;",
            "}"
        ],
        "description": "Snippet for polynomial.cpp"
    },
    "numeros_catalan.cpp": {
        "prefix": "numeros_catalan.cpp",
        "body": [
            "// Python Solution",
            "catalan = [0 for i in range(150 + 5)]",
            "def fcatalan(n):",
            "    catalan[0] = 1",
            "    catalan[1] = 1",
            "    for i in range(2, n + 1):",
            "        catalan[i] = 0",
            "        for j in range(i):",
            "            catalan[i] = catalan[i] + catalan[j] * catalan[i - j - 1]",
            "",
            "fcatalan(151)",
            ""
        ],
        "description": "Snippet for numeros_catalan.cpp"
    },
    "dijkstra.cpp": {
        "prefix": "dijkstra.cpp",
        "body": [
            "lli n;",
            "vector<vector<ii>> g;",
            "vi dijkstra(int u) {",
            "\tvi dist(n, -1);",
            "\tdist[u] = 0;",
            "\tpriority_queue<ii, vector<ii>, greater<ii>> pq;",
            "\tpq.push({0, u});",
            "\twhile(!pq.empty()) {",
            "\t\tii cur = pq.top(); ",
            "\t\tpq.pop();",
            "    for(auto it:g[cur.s]) {",
            "      if(dist[it.f] == -1 or dist[it.f] > (cur.f + it.s)) {",
            "        dist[it.f] = cur.f + it.s;",
            "        pq.push({dist[it.f], it.f});",
            "      }",
            "    }",
            "\t}",
            "  return dist;",
            "}",
            ""
        ],
        "description": "Snippet for dijkstra.cpp"
    },
    "parallel_dfs.cpp": {
        "prefix": "parallel_dfs.cpp",
        "body": [
            "struct Tree {",
            "\tint n,z[2];",
            "\tvector<vector<int>> g;",
            "\tvector<int> ex,ey,p,w,f,v[2];",
            "\tTree(int n):g(n),w(n),f(n){}",
            "\tvoid add_edge(int x, int y){",
            "\t\tp.pb(g[x].size());g[x].pb(ex.size());ex.pb(x);ey.pb(y);",
            "\t\tp.pb(g[y].size());g[y].pb(ex.size());ex.pb(y);ey.pb(x);",
            "\t}",
            "\tbool go(int k){ // returns true if it finds new node",
            "\t\tint& x=z[k];",
            "\t\twhile(x>=0&&",
            "\t\t\t(w[x]==g[x].size()||w[x]==g[x].size()-1&&(g[x].back()^1)==f[x]))",
            "\t\t\tx=f[x]>=0?ex[f[x]]:-1;",
            "\t\tif(x<0)return false;",
            "\t\tif((g[x][w[x]]^1)==f[x])w[x]++;",
            "\t\tint e=g[x][w[x]],y=ey[e];",
            "\t\tf[y]=e;w[x]++;w[y]=0;x=y;",
            "\t\tv[k].pb(x);",
            "\t\treturn true;",
            "\t}",
            "\tvector<int> erase_edge(int e){",
            "\t\te*=2; // erases eth edge, returns smaller component",
            "\t\tint x=ex[e],y=ey[e];",
            "\t\tp[g[x].back()]=p[e];",
            "\t\tg[x][p[e]]=g[x].back();g[x].pop_back();",
            "\t\tp[g[y].back()]=p[e^1];",
            "\t\tg[y][p[e^1]]=g[y].back();g[y].pop_back();",
            "\t\tf[x]=f[y]=-1;",
            "\t\tw[x]=w[y]=0;",
            "\t\tz[0]=x;z[1]=y;",
            "\t\tv[0]={x};v[1]={y};",
            "\t\tbool d0=true,d1=true;",
            "\t\twhile(d0 and d1)d0=go(0),d1=go(1);",
            "\t\tif(d1)return v[0];",
            "\t\treturn v[1];",
            "\t}",
            "};"
        ],
        "description": "Snippet for parallel_dfs.cpp"
    },
    "chu_liu.cpp": {
        "prefix": "chu_liu.cpp",
        "body": [
            "typedef int tw; ",
            "tw INF=1ll<<30;",
            "struct edge{int u,v,id;tw len;};",
            "struct ChuLiu{",
            "\tint n; ",
            "    vector<edge> e;",
            "\tvector<int> inc,dec,take,pre,num,id,vis;",
            "\tvector<tw> inw;",
            "\tvoid add_edge(int x, int y, tw w){",
            "\t\tinc.pb(0); dec.pb(0); take.pb(0);",
            "\t\te.pb({x,y,sz(e),w});",
            "\t}",
            "\tChuLiu(int n):n(n),pre(n),num(n),id(n),vis(n),inw(n){}",
            "\ttw doit(int root){",
            "\t\tauto e2=e;",
            "\t\ttw ans=0; int eg=sz(e)-1,pos=sz(e)-1;",
            "\t\twhile(1){",
            "\t\t\tfore(i,0,n) inw[i]=INF,id[i]=vis[i]=-1;",
            "\t\t\tfor(auto ed:e2) if(ed.len<inw[ed.v]){",
            "\t\t\t\tinw[ed.v]=ed.len; pre[ed.v]=ed.u;",
            "\t\t\t\tnum[ed.v]=ed.id;",
            "\t\t\t}",
            "\t\t\tinw[root]=0;",
            "\t\t\tfore(i,0,n) if(inw[i]==INF) return -1;",
            "\t\t\tint tot=-1;",
            "\t\t\tfore(i,0,n){",
            "\t\t\t\tans+=inw[i];",
            "\t\t\t\tif(i!=root)take[num[i]]++;",
            "\t\t\t\tint j=i;",
            "\t\t\t\twhile(vis[j]!=i&&j!=root&&id[j]<0)vis[j]=i,j=pre[j];",
            "\t\t\t\tif(j!=root&&id[j]<0){",
            "\t\t\t\t\tid[j]=++tot;",
            "\t\t\t\t\tfor(int k=pre[j];k!=j;k=pre[k]) id[k]=tot;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(tot<0)break;",
            "\t\t\tfore(i,0,n) if(id[i]<0)id[i]=++tot;",
            "\t\t\tn=tot+1; int j=0;",
            "\t\t\tfore(i,0,sz(e2)){",
            "\t\t\t\tint v=e2[i].v;",
            "\t\t\t\te2[j].v=id[e2[i].v];",
            "\t\t\t\te2[j].u=id[e2[i].u];",
            "\t\t\t\tif(e2[j].v!=e2[j].u){",
            "\t\t\t\t\te2[j].len=e2[i].len-inw[v];",
            "\t\t\t\t\tinc.pb(e2[i].id);",
            "\t\t\t\t\tdec.pb(num[v]);",
            "\t\t\t\t\ttake.pb(0);",
            "\t\t\t\t\te2[j++].id=++pos;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\te2.resize(j);",
            "\t\t\troot=id[root];",
            "\t\t}",
            "\t\twhile(pos>eg){",
            "\t\t\tif(take[pos]>0) take[inc[pos]]++, take[dec[pos]]--;",
            "\t\t\tpos--;",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "};"
        ],
        "description": "Snippet for chu_liu.cpp"
    },
    "tarjan_2sat.cpp": {
        "prefix": "tarjan_2sat.cpp",
        "body": [
            "// MAXN: max number of nodes or 2 * max number of variables (2SAT)",
            "bool truth[MAXN]; // truth[cmp[i]]=value of variable i (2SAT)",
            "int nvar;int neg(int x){return MAXN-1-x;} // (2SAT)",
            "vector<int> g[MAXN];",
            "int n,lw[MAXN],idx[MAXN],qidx,cmp[MAXN],qcmp;",
            "stack<int> st;",
            "void tjn(int u){",
            "\tlw[u]=idx[u]=++qidx;",
            "\tst.push(u);cmp[u]=-2;",
            "\tfor(int v:g[u]){",
            "\t\tif(!idx[v]||cmp[v]==-2){",
            "\t\t\tif(!idx[v]) tjn(v);",
            "\t\t\tlw[u]=min(lw[u],lw[v]);",
            "\t\t}",
            "\t}",
            "\tif(lw[u]==idx[u]){",
            "\t\tint x,l=-1;",
            "\t\tdo{x=st.top();st.pop();cmp[x]=qcmp;if(min(x,neg(x))<nvar)l=x;}",
            "\t\twhile(x!=u);",
            "\t\tif(l!=-1)truth[qcmp]=(cmp[neg(l)]<0); // (2SAT)",
            "\t\tqcmp++;",
            "\t}",
            "}",
            "void scc(){",
            "\tmemset(idx,0,sizeof(idx));qidx=0;",
            "\tmemset(cmp,-1,sizeof(cmp));qcmp=0;",
            "\tfore(i,0,n)if(!idx[i])tjn(i);",
            "}",
            "// Only for 2SAT:",
            "void addor(int a, int b){g[neg(a)].pb(b);g[neg(b)].pb(a);}",
            "bool satisf(int _nvar){",
            "\tnvar=_nvar;n=MAXN;scc();",
            "\tfore(i,0,nvar)if(cmp[i]==cmp[neg(i)])return false;",
            "\treturn true;",
            "}",
            ""
        ],
        "description": "Snippet for tarjan_2sat.cpp"
    },
    "lca.cpp": {
        "prefix": "lca.cpp",
        "body": [
            "vector<int> g[1<<K];int n;  // K such that 2^K>=n",
            "int F[K][1<<K],D[1<<K];",
            "void lca_dfs(int x){",
            "\tfore(i,0,g[x].size()){",
            "\t\tint y=g[x][i];if(y==F[0][x])continue;",
            "\t\tF[0][y]=x;D[y]=D[x]+1;lca_dfs(y);",
            "\t}",
            "}",
            "void lca_init(){",
            "\tD[0]=0;F[0][0]=-1;",
            "\tlca_dfs(0);",
            "\tfore(k,1,K)fore(x,0,n)",
            "\t\tif(F[k-1][x]<0)F[k][x]=-1;",
            "\t\telse F[k][x]=F[k-1][F[k-1][x]];",
            "}",
            "int lca(int x, int y){",
            "\tif(D[x]<D[y])swap(x,y);",
            "\tfor(int k=K-1;k>=0;--k)if(D[x]-(1<<k)>=D[y])x=F[k][x];",
            "\tif(x==y)return x;",
            "\tfor(int k=K-1;k>=0;--k)if(F[k][x]!=F[k][y])x=F[k][x],y=F[k][y];",
            "\treturn F[0][x];",
            "}",
            ""
        ],
        "description": "Snippet for lca.cpp"
    },
    "bellman.cpp": {
        "prefix": "bellman.cpp",
        "body": [
            "int n;",
            "vector<pair<int,int> > g[MAXN]; // u->[(v,cost)]",
            "long long dist[MAXN];",
            "void bford(int src){ // O(nm)",
            "\tfill(dist,dist+n,INF);dist[src]=0;",
            "\tfor(int i = 0; i<n; i+=1)fore(x,0,n)if(dist[x]!=INF)for(auto t:g[x]){",
            "\t\tdist[t.f]=min(dist[t.f],dist[x]+t.s);",
            "\t}",
            "\tfore(x,0,n)if(dist[x]!=INF)for(auto t:g[x]){",
            "\t\tif(dist[t.f]>dist[x]+t.s){",
            "\t\t\t// neg cycle: all nodes reachable from t.fst have -INF distance",
            "\t\t\t// to reconstruct neg cycle: save \"prev\" of each node, go up from t.fst until repeating a node. this node and all nodes between the two occurences form a neg cycle",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Snippet for bellman.cpp"
    },
    "eulerian_path.cpp": {
        "prefix": "eulerian_path.cpp",
        "body": [
            "// Directed version (uncomment commented code for undirected)",
            "struct edge {",
            "\tint y;",
            "//\tlist<edge>::iterator rev;",
            "\tedge(int y):y(y){}",
            "};",
            "list<edge> g[MAXN];",
            "void add_edge(int a, int b){",
            "\tg[a].push_front(edge(b));//auto ia=g[a].begin();",
            "//\tg[b].push_front(edge(a));auto ib=g[b].begin();",
            "//\tia->rev=ib;ib->rev=ia;",
            "}",
            "vector<int> p;",
            "void go(int x){",
            "\twhile(g[x].size()){",
            "\t\tint y=g[x].front().y;",
            "\t\t//g[y].erase(g[x].front().rev);",
            "\t\tg[x].pop_front();",
            "\t\tgo(y);",
            "\t}",
            "\tp.push_back(x);",
            "}",
            "vector<int> get_path(int x){ // get a path that begins in x",
            "// check that a path exists from x before calling to get_path!",
            "\tp.clear();go(x);",
            "    reverse(p.begin(),p.end());",
            "\treturn p;",
            "}"
        ],
        "description": "Snippet for eulerian_path.cpp"
    },
    "kruskal.cpp": {
        "prefix": "kruskal.cpp",
        "body": [
            "int uf[MAXN];",
            "void uf_init(){memset(uf,-1,sizeof(uf));}",
            "int uf_find(int x){return uf[x]<0?x:uf[x]=uf_find(uf[x]);}",
            "bool uf_join(int x, int y){",
            "\tx=uf_find(x);y=uf_find(y);",
            "\tif(x==y)return false;",
            "\tif(uf[x]>uf[y])swap(x,y);",
            "\tuf[x]+=uf[y];uf[y]=x;",
            "\treturn true;",
            "}",
            "vector<pair<long long,pair<int,int> > > es; // edges (cost,(u,v))",
            "long long kruskal(){  // assumes graph is connected",
            "\tsort(es.begin(),es.end());",
            "    uf_init();",
            "\tlong long r=0;",
            "\tfore(i,0,es.size()){",
            "\t\tint x=es[i].s.f,y=es[i].s.s;",
            "\t\tif(uf_join(x,y))r+=es[i].f; // (x,y,c) belongs to mst",
            "\t}",
            "\treturn r; // total cost",
            "}"
        ],
        "description": "Snippet for kruskal.cpp"
    },
    "art_bri_bic.cpp": {
        "prefix": "art_bri_bic.cpp",
        "body": [
            "vector<int> g[MAXN];int n;",
            "struct edge {int u,v,comp;bool bridge;};",
            "vector<edge> e;",
            "void add_edge(int u, int v){",
            "\tg[u].pb(e.size());g[v].pb(e.size());",
            "\te.pb((edge){u,v,-1,false});",
            "}",
            "int D[MAXN],B[MAXN],T;",
            "int nbc;  // number of biconnected components",
            "int art[MAXN];  // articulation point iff !=0",
            "stack<int> st;  // only for biconnected",
            "void dfs(int u,int pe){",
            "\tB[u]=D[u]=T++;",
            "\tfor(int ne:g[u])if(ne!=pe){",
            "\t\tint v=e[ne].u^e[ne].v^u;",
            "\t\tif(D[v]<0){",
            "\t\t\tst.push(ne);dfs(v,ne);",
            "\t\t\tif(B[v]>D[u])e[ne].bridge = true; // bridge",
            "\t\t\tif(B[v]>=D[u]){",
            "\t\t\t\tart[u]++; // articulation",
            "\t\t\t\tint last; // start biconnected",
            "\t\t\t\tdo {",
            "\t\t\t\t\tlast=st.top();st.pop();",
            "\t\t\t\t\te[last].comp=nbc;",
            "\t\t\t\t} while(last!=ne);",
            "\t\t\t\tnbc++;    // end biconnected",
            "\t\t\t}",
            "\t\t\tB[u]=min(B[u],B[v]);",
            "\t\t}",
            "\t\telse if(D[v]<D[u])st.push(ne),B[u]=min(B[u],D[v]);",
            "\t}",
            "}",
            "void doit(){",
            "\tmemset(D,-1,sizeof(D));",
            "    memset(art,0,sizeof(art));",
            "\tnbc=T=0;",
            "\tfore(i,0,n)if(D[i]<0)dfs(i,-1),art[i]--;",
            "}"
        ],
        "description": "Snippet for art_bri_bic.cpp"
    },
    "floyd.cpp": {
        "prefix": "floyd.cpp",
        "body": [
            "// g[i][j]: weight of edge (i, j) or INF if there's no edge",
            "// g[i][i]=0",
            "long long g[MAXN][MAXN];",
            "int n;",
            "void floyd(){ // O(n^3) . Replaces g with min distances",
            "\tfore(k,0,n)fore(i,0,n)if(g[i][k]<INF)fore(j,0,n)if(g[k][j]<INF)",
            "\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);",
            "}",
            "bool inNegCycle(int v){return g[v][v]<0;}",
            "bool hasNegCycle(int a, int b){ // true iff there's neg cycle in between",
            "\tfore(i,0,n)if(g[a][i]<INF&&g[i][b]<INF&&g[i][i]<0)return true;",
            "\treturn false;",
            "}",
            ""
        ],
        "description": "Snippet for floyd.cpp"
    },
    "topo_sort.cpp": {
        "prefix": "topo_sort.cpp",
        "body": [
            "vector<int> g[MAXN];int n;",
            "vector<int> tsort(){  // lexicographically smallest topological sort",
            "\tvector<int> r;",
            "    priority_queue<int> q;",
            "\tvector<int> d(2*n,0);",
            "\tfore(i,0,n)fore(j,0,g[i].size())d[g[i][j]]++;",
            "\tfore(i,0,n)if(!d[i])q.push(-i);",
            "\twhile(!q.empty()){",
            "\t\tint x=-q.top();q.pop();r.pb(x);",
            "\t\tfore(i,0,g[x].size()){",
            "\t\t\td[g[x][i]]--;",
            "\t\t\tif(!d[g[x][i]])q.push(-g[x][i]);",
            "\t\t}",
            "\t}",
            "\treturn r;  // if not DAG it will have less than n elements",
            "}"
        ],
        "description": "Snippet for topo_sort.cpp"
    },
    "bic_comp.cpp": {
        "prefix": "bic_comp.cpp",
        "body": [
            "struct Biconnected{",
            "\t// articulation point iff B[i] !=0",
            "\t// nbc = number of biconnected components",
            "\tstruct edge {int u,v,comp;bool bridge;};",
            "\tvector<edge> e;",
            "\tvector<vector<int>>g;",
            "\tint n,nbc,T;",
            "\tvoid add_edge(int u, int v){",
            "\t\tg[u].pb(sz(e));",
            "\t\tg[v].pb(sz(e));",
            "\t\te.pb({u,v,-1,0});",
            "\t}",
            "\tvector<int>D,B,art;",
            "\tstack<int> st;",
            "\tvoid dfs(int u,int pe){",
            "\t\tB[u]=D[u]=T++;",
            "\t\tfor(int ne:g[u])if(ne!=pe){",
            "\t\t\tint v=e[ne].u^e[ne].v^u;",
            "\t\t\tif(D[v]<0){",
            "\t\t\t\tst.push(ne);",
            "\t\t\t\tdfs(v,ne);",
            "\t\t\t\tif(B[v]>D[u])e[ne].bridge = true;",
            "\t\t\t\tif(B[v]>=D[u]){",
            "\t\t\t\t\twhile(1){",
            "\t\t\t\t\t\tint last=st.top();st.pop();",
            "\t\t\t\t\t\te[last].comp=nbc;",
            "\t\t\t\t\t\tif(last==ne)break;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tnbc++; art[u]++;",
            "\t\t\t\t}",
            "\t\t\t\tB[u]=min(B[u],B[v]);",
            "\t\t\t}",
            "\t\t\telse if(D[v]<D[u])st.push(ne),B[u]=min(B[u],D[v]);",
            "\t\t}",
            "\t}",
            "",
            "\tBiconnected(int n):n(n),nbc(0),T(0){",
            "\t\tD = vector<int>(n,-1);",
            "\t\tart = B = vector<int>(n,0);",
            "\t\tg = vector<int>(n);",
            "\t}",
            "",
            "\tvoid run(){",
            "\t\tfore(i,0,n)if(D[i]<0)dfs(i,-1),art[i]--;",
            "\t}",
            "",
            "\tauto get_cmp(){",
            "\t\tvector<vector<int>>v(nbc);",
            "\t\tfor(auto i:e)v[i.comp].pb(i.u), v[i.comp].pb(i.v);",
            "\t\treturn v;",
            "\t}",
            "",
            "};",
            ""
        ],
        "description": "Snippet for bic_comp.cpp"
    },
    "dominator.cpp": {
        "prefix": "dominator.cpp",
        "body": [
            "//idom[i]=parent of i in dominator tree with root=rt, or -1 if not exists",
            "int n,rnk[MAXN],pre[MAXN],anc[MAXN],idom[MAXN],semi[MAXN],low[MAXN];",
            "vector<int> g[MAXN],rev[MAXN],dom[MAXN],ord;",
            "void dfspre(int pos){",
            "\trnk[pos]=sz(ord); ord.pb(pos);",
            "\tfor(auto x:g[pos]){",
            "\t\trev[x].pb(pos);",
            "\t\tif(rnk[x]==n) pre[x]=pos,dfspre(x);",
            "\t}",
            "}",
            "int eval(int v){",
            "\tif(anc[v]<n and anc[anc[v]]<n){",
            "\t\tint x=eval(anc[v]);",
            "\t\tif(rnk[semi[low[v]]]>rnk[semi[x]]) low[v]=x;",
            "\t\tanc[v]=anc[anc[v]];",
            "\t}",
            "\treturn low[v];",
            "}",
            "void dominators(int rt){",
            "\tfore(i,0,n){",
            "\t\tdom[i].clear(); rev[i].clear();",
            "\t\trnk[i]=pre[i]=anc[i]=idom[i]=n;",
            "\t\tsemi[i]=low[i]=i;",
            "\t}",
            "\tord.clear(); ",
            "    dfspre(rt);",
            "\tfor(int i=sz(ord)-1;i;i--){",
            "\t\tint w=ord[i];",
            "\t\tfor(int v:rev[w]){",
            "\t\t\tint u=eval(v);",
            "\t\t\tif(rnk[semi[w]]>rnk[semi[u]])semi[w]=semi[u];",
            "\t\t}",
            "\t\tdom[semi[w]].pb(w); anc[w]=pre[w];",
            "\t\tfor(int v:dom[pre[w]]){",
            "\t\t\tint u=eval(v);",
            "\t\t\tidom[v]=(rnk[pre[w]]>rnk[semi[u]]?u:pre[w]);",
            "\t\t}",
            "\t\tdom[pre[w]].clear();",
            "\t}",
            "\tfor(int w:ord) if(w!=rt&&idom[w]!=semi[w]) idom[w]=idom[idom[w]];",
            "\tfore(i,0,n) if(idom[i]==n)idom[i]=-1;",
            "}"
        ],
        "description": "Snippet for dominator.cpp"
    },
    "hld.cpp": {
        "prefix": "hld.cpp",
        "body": [
            "vector<int> g[MAXN];",
            "int wg[MAXN],dad[MAXN],dep[MAXN]; // weight,father,depth",
            "void dfs1(int x){",
            "\twg[x]=1;",
            "\tfor(int y:g[x])if(y!=dad[x]){",
            "\t\tdad[y]=x;dep[y]=dep[x]+1;",
            "        dfs1(y);",
            "\t\twg[x]+=wg[y];",
            "\t}",
            "}",
            "int curpos,pos[MAXN],head[MAXN];",
            "void hld(int x, int c){",
            "\tif(c<0)c=x;",
            "\tpos[x]=curpos++;head[x]=c;",
            "\tint mx=-1;",
            "\tfor(int y:g[x])if(y!=dad[x]&&(mx<0||wg[mx]<wg[y]))mx=y;",
            "\tif(mx>=0)hld(mx,c);",
            "\tfor(int y:g[x])if(y!=mx&&y!=dad[x])hld(y,-1);",
            "}",
            "void hld_init(){dad[0]=-1;dep[0]=0;dfs1(0);curpos=0;hld(0,-1);}",
            "int query(int x, int y, STree& rmq){",
            "\tint r=NEUT;",
            "\twhile(head[x]!=head[y]){",
            "\t\tif(dep[head[x]]>dep[head[y]])swap(x,y);",
            "\t\tr=oper(r,rmq.query(pos[head[y]],pos[y]+1));",
            "\t\ty=dad[head[y]];",
            "\t}",
            "\tif(dep[x]>dep[y])swap(x,y); // now x is lca",
            "\tr=oper(r,rmq.query(pos[x],pos[y]+1));",
            "\treturn r;",
            "}",
            "// for updating: rmq.upd(pos[x],v);",
            "// queries on edges: - assign values of edges to \"child\" node",
            "//                   - change pos[x] to pos[x]+1 in query (line 28)"
        ],
        "description": "Snippet for hld.cpp"
    },
    "centroid.cpp": {
        "prefix": "centroid.cpp",
        "body": [
            "vector<int> g[MAXN];int n;",
            "bool tk[MAXN];",
            "int fat[MAXN]; // father in centroid decomposition",
            "int szt[MAXN]; // size of subtree",
            "int calcsz(int x, int f){",
            "\tszt[x]=1;",
            "\tfor(auto y:g[x])if(y!=f&&!tk[y])szt[x]+=calcsz(y,x);",
            "\treturn szt[x];",
            "}",
            "void cdfs(int x=0, int f=-1, int sz=-1){ // O(nlogn)",
            "\tif(sz<0)sz=calcsz(x,-1);",
            "\tfor(auto y:g[x])if(!tk[y]&&szt[y]*2>=sz){",
            "\t\tszt[x]=0;cdfs(y,f,sz);return;",
            "\t}",
            "\ttk[x]=true;fat[x]=f;",
            "\tfor(auto y:g[x])if(!tk[y])cdfs(y,x);",
            "}",
            "void centroid(){memset(tk,false,sizeof(tk));cdfs();}",
            ""
        ],
        "description": "Snippet for centroid.cpp"
    },
    "dynamic_conn.cpp": {
        "prefix": "dynamic_conn.cpp",
        "body": [
            "struct UnionFind {",
            "\tint n,comp;",
            "\tvector<int> uf,si,c;",
            "\tUnionFind(int n=0):n(n),comp(n),uf(n),si(n,1){",
            "\t\tfore(i,0,n)uf[i]=i;}",
            "\tint find(int x){return x==uf[x]?x:find(uf[x]);}",
            "\tbool join(int x, int y){",
            "\t\tif((x=find(x))==(y=find(y)))return false;",
            "\t\tif(si[x]<si[y])swap(x,y);",
            "\t\tsi[x]+=si[y];uf[y]=x;comp--;c.pb(y);",
            "\t\treturn true;",
            "\t}",
            "\tint snap(){return c.size();}",
            "\tvoid rollback(int snap){",
            "\t\twhile(c.size()>snap){",
            "\t\t\tint x=c.back();c.pop_back();",
            "\t\t\tsi[uf[x]]-=si[x];uf[x]=x;comp++;",
            "\t\t}",
            "\t}",
            "};",
            "enum {ADD,DEL,QUERY};",
            "struct Query {int type,x,y;};",
            "struct DynCon {",
            "\tvector<Query> q;",
            "\tUnionFind dsu;",
            "\tvector<int> mt;",
            "\tmap<pair<int,int>,int> last;",
            "\tDynCon(int n):dsu(n){}",
            "\tvoid add(int x, int y){",
            "\t\tif(x>y)swap(x,y);",
            "\t\tq.pb((Query){ADD,x,y});mt.pb(-1);",
            "        last[{x,y}]=q.size()-1;",
            "\t}",
            "\tvoid remove(int x, int y){",
            "\t\tif(x>y)swap(x,y);",
            "\t\tq.pb((Query){DEL,x,y});",
            "\t\tint pr=last[{x,y}];mt[pr]=q.size()-1;mt.pb(pr);",
            "\t}",
            "\tvoid query(){q.pb((Query){QUERY,-1,-1});",
            "    mt.pb(-1);}",
            "\tvoid process(){ // answers all queries in order",
            "\t\tif(!q.size())return;",
            "\t\tfore(i,0,q.size())if(q[i].type==ADD&&mt[i]<0)mt[i]=q.size();",
            "\t\tgo(0,q.size());",
            "\t}",
            "\tvoid go(int s, int e){",
            "\t\tif(s+1==e){",
            "\t\t\tif(q[s].type==QUERY) // answer query using DSU",
            "            cout<<dsu.comp<<ENDL;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint k=dsu.snap(),m=(s+e)/2;",
            "\t\tfor(int i=e-1;i>=m;--i)if(mt[i]>=0&&mt[i]<s)dsu.join(q[i].x,q[i].y);",
            "\t\tgo(s,m);",
            "        dsu.rollback(k);",
            "\t\tfor(int i=m-1;i>=s;--i)if(mt[i]>=e)dsu.join(q[i].x,q[i].y);",
            "\t\tgo(m,e);",
            "        dsu.rollback(k);",
            "\t}",
            "};"
        ],
        "description": "Snippet for dynamic_conn.cpp"
    },
    "edmon_blossom.cpp": {
        "prefix": "edmon_blossom.cpp",
        "body": [
            "vector<int> g[MAXN];",
            "int n,m,mt[MAXN],qh,qt,q[MAXN],ft[MAXN],bs[MAXN];",
            "bool inq[MAXN],inb[MAXN],inp[MAXN];",
            "int lca(int root, int x, int y){",
            "\tmemset(inp,0,sizeof(inp));",
            "\twhile(1){",
            "\t\tinp[x=bs[x]]=true;",
            "\t\tif(x==root)break;",
            "\t\tx=ft[mt[x]];",
            "\t}",
            "\twhile(1){",
            "\t\tif(inp[y=bs[y]])return y;",
            "\t\telse y=ft[mt[y]];",
            "\t}",
            "}",
            "void mark(int z, int x){",
            "\twhile(bs[x]!=z){",
            "\t\tint y=mt[x];",
            "\t\tinb[bs[x]]=inb[bs[y]]=true;",
            "\t\tx=ft[y];",
            "\t\tif(bs[x]!=z)ft[x]=y;",
            "\t}",
            "}",
            "void contr(int s, int x, int y){",
            "\tint z=lca(s,x,y);",
            "\tmemset(inb,0,sizeof(inb));",
            "\tmark(z,x);mark(z,y);",
            "\tif(bs[x]!=z)ft[x]=y;",
            "\tif(bs[y]!=z)ft[y]=x;",
            "\tfore(x,0,n)if(inb[bs[x]]){",
            "\t\tbs[x]=z;",
            "\t\tif(!inq[x])inq[q[++qt]=x]=true;",
            "\t}",
            "}",
            "int findp(int s){",
            "\tmemset(inq,0,sizeof(inq));",
            "\tmemset(ft,-1,sizeof(ft));",
            "\tfore(i,0,n)bs[i]=i;",
            "\tinq[q[qh=qt=0]=s]=true;",
            "\twhile(qh<=qt){",
            "\t\tint x=q[qh++];",
            "\t\tfor(int y:g[x])if(bs[x]!=bs[y]&&mt[x]!=y){",
            "\t\t\tif(y==s||mt[y]>=0&&ft[mt[y]]>=0)contr(s,x,y);",
            "\t\t\telse if(ft[y]<0){",
            "\t\t\t\tft[y]=x;",
            "\t\t\t\tif(mt[y]<0)return y;",
            "\t\t\t\telse if(!inq[mt[y]])inq[q[++qt]=mt[y]]=true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
            "int aug(int s, int t){",
            "\tint x=t,y,z;",
            "\twhile(x>=0){",
            "\t\ty=ft[x];",
            "\t\tz=mt[y];",
            "\t\tmt[y]=x;mt[x]=y;",
            "\t\tx=z;",
            "\t}",
            "\treturn t>=0;",
            "}",
            "int edmonds(){ // O(n^2 m)",
            "\tint r=0;",
            "\tmemset(mt,-1,sizeof(mt));",
            "\tfore(x,0,n)if(mt[x]<0)r+=aug(x,findp(x));",
            "\treturn r;",
            "}vector<int> g[MAXN];",
            "",
            "int n,m,mt[MAXN],qh,qt,q[MAXN],ft[MAXN],bs[MAXN];",
            "bool inq[MAXN],inb[MAXN],inp[MAXN];",
            "",
            "int lca(int root, int x, int y){",
            "\tmemset(inp,0,sizeof(inp));",
            "\twhile(1){",
            "\t\tinp[x=bs[x]]=true;",
            "\t\tif(x==root)break;",
            "\t\tx=ft[mt[x]];",
            "\t}",
            "\twhile(1){",
            "\t\tif(inp[y=bs[y]])return y;",
            "\t\telse y=ft[mt[y]];",
            "\t}",
            "}",
            "void mark(int z, int x){",
            "\twhile(bs[x]!=z){",
            "\t\tint y=mt[x];",
            "\t\tinb[bs[x]]=inb[bs[y]]=true;",
            "\t\tx=ft[y];",
            "\t\tif(bs[x]!=z)ft[x]=y;",
            "\t}",
            "}",
            "void contr(int s, int x, int y){",
            "\tint z=lca(s,x,y);",
            "\tmemset(inb,0,sizeof(inb));",
            "\tmark(z,x);mark(z,y);",
            "\tif(bs[x]!=z)ft[x]=y;",
            "\tif(bs[y]!=z)ft[y]=x;",
            "\tfore(x,0,n)if(inb[bs[x]]){",
            "\t\tbs[x]=z;",
            "\t\tif(!inq[x])inq[q[++qt]=x]=true;",
            "\t}",
            "}",
            "int findp(int s){",
            "\tmemset(inq,0,sizeof(inq));",
            "\tmemset(ft,-1,sizeof(ft));",
            "\tfore(i,0,n)bs[i]=i;",
            "\tinq[q[qh=qt=0]=s]=true;",
            "\twhile(qh<=qt){",
            "\t\tint x=q[qh++];",
            "\t\tfor(int y:g[x])if(bs[x]!=bs[y]&&mt[x]!=y){",
            "\t\t\tif(y==s||mt[y]>=0&&ft[mt[y]]>=0)contr(s,x,y);",
            "\t\t\telse if(ft[y]<0){",
            "\t\t\t\tft[y]=x;",
            "\t\t\t\tif(mt[y]<0)return y;",
            "\t\t\t\telse if(!inq[mt[y]])inq[q[++qt]=mt[y]]=true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn -1;",
            "}",
            "int aug(int s, int t){",
            "\tint x=t,y,z;",
            "\twhile(x>=0){",
            "\t\ty=ft[x];",
            "\t\tz=mt[y];",
            "\t\tmt[y]=x;mt[x]=y;",
            "\t\tx=z;",
            "\t}",
            "\treturn t>=0;",
            "}",
            "int edmonds(){ // O(n^2 m)",
            "\tint r=0;",
            "\tmemset(mt,-1,sizeof(mt));",
            "\tfore(x,0,n)if(mt[x]<0)r+=aug(x,findp(x));",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for edmon_blossom.cpp"
    },
    "line.cpp": {
        "prefix": "line.cpp",
        "body": [
            "//Needs EPS, INF and DINF",
            "",
            "struct ln {",
            "\tpt p,pq;",
            "\tln(pt p, pt q):p(p),pq(q-p){}",
            "\tln(){}",
            "\tbool has(pt r){return dist(r)<=EPS;}",
            "\tbool seghas(pt r){return has(r)&&(r-p)*(r-(p+pq))<=EPS;}",
            "//\tbool operator /(ln l){return (pq.unit()^l.pq.unit()).norm()<=EPS;} // 3D",
            "\tbool operator/(ln l){return abs(pq.unit()%l.pq.unit())<=EPS;} // 2D",
            "\tbool operator==(ln l){return *this/l&&has(l.p);}",
            "\tpt operator^(ln l){ // intersection",
            "\t\tif(*this/l)return pt(DINF,DINF);",
            "\t\tpt r=l.p+l.pq*((p-l.p)%pq/(l.pq%pq));",
            "//\t\tif(!has(r)){return pt(NAN,NAN,NAN);} // check only for 3D",
            "\t\treturn r;",
            "\t}",
            "\tdouble angle(ln l){return pq.angle(l.pq);}",
            "\tint side(pt r){return has(r)?0:sgn2(pq%(r-p));} // 2D",
            "\tpt proj(pt r){return p+pq*((r-p)*pq/pq.norm2());}",
            "\tpt ref(pt r){return proj(r)*2-r;}",
            "\tdouble dist(pt r){return (r-proj(r)).norm();}",
            "//\tdouble dist(ln l){ // only 3D",
            "//\t\tif(*this/l)return dist(l.p);",
            "//\t\treturn abs((l.p-p)*(pq^l.pq))/(pq^l.pq).norm();",
            "//\t}",
            "\tln rot(double a){return ln(p,p+pq.rot(a));} // 2D",
            "\tln rot(pt a){return ln(p,p+pq.rot(a));}",
            "};",
            "ln bisector(ln l, ln m){ // angle bisector",
            "\tpt p=l^m;",
            "\treturn ln(p,p+l.pq.unit()+m.pq.unit());",
            "}",
            "ln bisector(pt p, pt q){ // segment bisector (2D)",
            "\treturn ln((p+q)*.5,p).rot(ccw90);",
            "}"
        ],
        "description": "Snippet for line.cpp"
    },
    "intercircles.cpp": {
        "prefix": "intercircles.cpp",
        "body": [
            "//Need radial order",
            "vector<double> intercircles(vector<circle> c){",
            "\tvector<double> r(c.size() + 1); // r[k]: area covered by at least k circles",
            "\tfor(int i = 0; i < c.size(); ++i){           // O(n^2 log n) (high constant)",
            "\t\tint k=1;Cmp s(c[i].o);",
            "\t\tvector<pair<pt,int> > p={",
            "\t\t\t{c[i].o+pt(1,0)*c[i].r,0},",
            "\t\t\t{c[i].o-pt(1,0)*c[i].r,0}};",
            "\t\tfor(int j = 0; j < c.size(); ++j)if(j!=i){",
            "\t\t\tbool b0=c[i].in(c[j]),b1=c[j].in(c[i]);",
            "\t\t\tif(b0&&(!b1||i<j))k++;",
            "\t\t\telse if(!b0&&!b1){",
            "\t\t\t\tauto v=c[i]^c[j];",
            "\t\t\t\tif(v.size()==2){",
            "\t\t\t\t\tp.push_back({v[0],1});p.push_back({v[1],-1});",
            "\t\t\t\t\tif(s(v[1],v[0]))k++;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tsort(p.begin(),p.end(),",
            "\t\t\t[&](pair<pt,int> a, pair<pt,int> b){return s(a.first,b.first);});",
            "\t\tfor(int j = 0; j < (int)p.size(); ++j){",
            "\t\t\tpt p0=p[j?j-1:(int)p.size()-1].first,p1=p[j].first;",
            "\t\t\tdouble a=(p0-c[i].o).angle(p1-c[i].o);",
            "\t\t\tr[k]+=(p0.x-p1.x)*(p0.y+p1.y)/2+c[i].r*c[i].r*(a-sin(a))/2;",
            "\t\t\tk+=p[j].second;",
            "\t\t}",
            "\t}",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for intercircles.cpp"
    },
    "halfplanes.cpp": {
        "prefix": "halfplanes.cpp",
        "body": [
            "struct halfplane:public ln{",
            "\tdouble angle;",
            "\thalfplane(){}",
            "\thalfplane(pt a,pt b){p=a; pq=b-a; angle=atan2(pq.y,pq.x);}",
            "\tbool operator<(halfplane b)const{return angle<b.angle;}",
            "\tbool out(pt q){return pq%(q-p)<-EPS;}",
            "};",
            "vector<pt> intersect(vector<halfplane> b){",
            "\tvector<pt>bx={{DINF,DINF},{-DINF,DINF},{-DINF,-DINF},{DINF,-DINF}};",
            "\tfor(int i = 0; i < 4; ++i) b.push_back(halfplane(bx[i],bx[(i+1)%4]));",
            "\tsort(b.begin(), b.end());",
            "\tint n=(int)b.size(),q=1,h=0;",
            "\tvector<halfplane> c((int)b.size()+10);",
            "\tfor(int i = 0; i < n; ++i){",
            "\t\twhile(q<h&&b[i].out(c[h]^c[h-1])) h--;",
            "\t\twhile(q<h&&b[i].out(c[q]^c[q+1])) q++;",
            "\t\tc[++h]=b[i];",
            "\t\tif(q<h&&abs(c[h].pq%c[h-1].pq)<EPS){",
            "\t\t\tif(c[h].pq*c[h-1].pq<=0) return {};",
            "\t\t\th--;",
            "\t\t\tif(b[i].out(c[h].p)) c[h]=b[i];",
            "\t\t}",
            "\t}",
            "\twhile(q<h-1&&c[q].out(c[h]^c[h-1]))h--;",
            "\twhile(q<h-1&&c[h].out(c[q]^c[q+1]))q++;",
            "\tif(h-q<=1)return {};",
            "\tc[h+1]=c[q];",
            "\tvector<pt> s;",
            "\tfor(int i = q; i < h+1; ++i) s.push_back(c[i]^c[i+1]);",
            "\treturn s;",
            "}"
        ],
        "description": "Snippet for halfplanes.cpp"
    },
    "radial_order.cpp": {
        "prefix": "radial_order.cpp",
        "body": [
            "struct Cmp { // IMPORTANT: add const in pt operator -",
            "\tpt r;",
            "\tCmp(pt r):r(r){}",
            "\tint cuad(const pt &a)const {",
            "\t\tif(a.x>0&&a.y>=0)return 0;",
            "\t\tif(a.x<=0&&a.y>0)return 1;",
            "\t\tif(a.x<0&&a.y<=0)return 2;",
            "\t\tif(a.x>=0&&a.y<0)return 3;",
            "\t\tassert(a.x==0&&a.y==0);",
            "\t\treturn -1;",
            "\t}",
            "\tbool cmp(const pt& p1, const pt& p2)const {",
            "\t\tint c1=cuad(p1),c2=cuad(p2);",
            "\t\tif(c1==c2)return p1.y*p2.x<p1.x*p2.y;",
            "\t\treturn c1<c2;",
            "\t}",
            "\tbool operator()(const pt& p1, const pt& p2)const {",
            "\t\treturn cmp(pt(p1)-pt(r),pt(p2)-pt(r));",
            "\t}",
            "};"
        ],
        "description": "Snippet for radial_order.cpp"
    },
    "planar_graph_dual.cpp": {
        "prefix": "planar_graph_dual.cpp",
        "body": [
            "const int MAXN = 1;",
            "vector<int> g[MAXN];int n; // input graph (must be connected)",
            "vector<int> gd[MAXN];int nd; // output graph",
            "vector<int> nodes[MAXN]; // nodes delimiting region (in CW order)",
            "map<pair<int,int>,int> ps,es;",
            "void get_dual(vector<pt> p){ // p: points corresponding to nodes",
            "\tps.clear();es.clear();",
            "\tfor(int x = 0; x < n; ++x){",
            "\t\tCmp pc(p[x]); // (radial order of points)",
            "\t\tauto comp=[&](int a, int b){return pc(p[a],p[b]);};",
            "\t\tsort(g[x].begin(),g[x].end(),comp);",
            "\t\tfor(int i = 0; i < (int)g[x].size(); ++i)ps[{x,g[x][i]}]=i;",
            "\t}",
            "\tnd=0;",
            "\tfor(int xx = 0; xx < n; ++xx)for(auto yy:g[xx])if(!es.count({xx,yy})){",
            "\t\tint x=xx,y=yy;gd[nd].clear();nodes[nd].clear();",
            "\t\twhile(!es.count({x,y})){",
            "\t\t\tes[{x,y}]=nd;nodes[nd].push_back(y);",
            "\t\t\tint z=g[y][(ps[{y,x}]+1)%g[y].size()];x=y;y=z;",
            "\t\t}",
            "\t\tnd++;",
            "\t}",
            "\tfor(auto p:es){",
            "\t\tpair<int,int> q={p.first.second,p.first.first};",
            "\t\tassert(es.count(q));",
            "\t\tif(es[q]!=p.second)gd[p.second].push_back(es[q]);",
            "\t}",
            "\tfor(int i = 0; i < nd; ++i){",
            "\t\tsort(gd[i].begin(),gd[i].end());",
            "\t\tgd[i].erase(unique(gd[i].begin(),gd[i].end()),gd[i].end());",
            "\t}",
            "}"
        ],
        "description": "Snippet for planar_graph_dual.cpp"
    },
    "point.cpp": {
        "prefix": "point.cpp",
        "body": [
            "//Needs a EPS",
            "",
            "struct pt {  // for 3D add z coordinate",
            "\tdouble x,y;",
            "\tpt(double x, double y):x(x),y(y){}",
            "\tpt(){}",
            "\tdouble norm2(){return *this**this;}",
            "\tdouble norm(){return sqrt(norm2());}",
            "\tbool operator==(pt p){return abs(x-p.x)<=EPS&&abs(y-p.y)<=EPS;}",
            "\tpt operator+(pt p){return pt(x+p.x,y+p.y);}",
            "\tpt operator-(pt p){return pt(x-p.x,y-p.y);}",
            "\tpt operator*(double t){return pt(x*t,y*t);}",
            "\tpt operator/(double t){return pt(x/t,y/t);}",
            "\tdouble operator*(pt p){return x*p.x+y*p.y;}",
            "//\tpt operator^(pt p){ // only for 3D",
            "//\t\treturn pt(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);}",
            "\tdouble angle(pt p){ // redefine acos for values out of range",
            "\t\treturn acos(*this*p/(norm()*p.norm()));}",
            "\tpt unit(){return *this/norm();}",
            "\tdouble operator%(pt p){return x*p.y-y*p.x;}",
            "\t// 2D from now on",
            "\tbool operator<(pt p)const{ // for convex hull",
            "\t\treturn x<p.x-EPS||(abs(x-p.x)<=EPS&&y<p.y-EPS);}",
            "\tbool left(pt p, pt q){ // is it to the left of directed line pq?",
            "\t\treturn (q-p)%(*this-p)>EPS;}",
            "\tpt rot(pt r){return pt(*this%r,*this*r);}",
            "\tpt rot(double a){return rot(pt(sin(a),cos(a)));}",
            "};",
            "pt ccw90(1,0);",
            "pt cw90(-1,0);"
        ],
        "description": "Snippet for point.cpp"
    },
    "polygon.cpp": {
        "prefix": "polygon.cpp",
        "body": [
            "//Need CHULL",
            "int sgn(double x){return x<-EPS?-1:x>EPS;}",
            "struct pol {",
            "\tint n;vector<pt> p;",
            "\tpol(){}",
            "\tpol(vector<pt> _p){p=_p;n=p.size();}",
            "\tdouble area(){",
            "\t\tdouble r=0.;",
            "\t\tfor(int i = 0; i < n; ++i)r+=p[i]%p[(i+1)%n];",
            "\t\treturn abs(r)/2; // negative if CW, positive if CCW",
            "\t}",
            "\tpt centroid(){ // (barycenter)",
            "\t\tpt r(0,0);double t=0;",
            "\t\tfor(int i = 0; i < n; ){",
            "\t\t\tr=r+(p[i]+p[(i+1)%n])*(p[i]%p[(i+1)%n]);",
            "\t\t\tt+=p[i]%p[(i+1)%n];",
            "\t\t}",
            "\t\treturn r/t/3;",
            "\t}",
            "\tbool has(pt q){ // O(n)",
            "\t\tfor(int i = 0; i < n; ++i)if(ln(p[i],p[(i+1)%n]).seghas(q))return true;",
            "\t\tint cnt=0;",
            "\t\tfor(int i = 0; i < n; ++i){",
            "\t\t\tint j=(i+1)%n;",
            "\t\t\tint k=sgn((q-p[j])%(p[i]-p[j]));",
            "\t\t\tint u=sgn(p[i].y-q.y),v=sgn(p[j].y-q.y);",
            "\t\t\tif(k>0&&u<0&&v>=0)cnt++;",
            "\t\t\tif(k<0&&v<0&&u>=0)cnt--;",
            "\t\t}",
            "\t\treturn cnt!=0;",
            "\t}",
            "\tvoid normalize(){ // (call before haslog, remove collinear first)",
            "\t\tif(p[2].left(p[0],p[1]))reverse(p.begin(),p.end());",
            "\t\tint pi=min_element(p.begin(),p.end())-p.begin();",
            "\t\tvector<pt> s(n);",
            "\t\tfor(int i = 0; i < n; ++i) s[i]=p[(pi+i)%n];",
            "\t\tp.swap(s);",
            "\t}",
            "\tbool haslog(pt q){ // O(log(n)) only CONVEX. Call normalize first",
            "\t\tif(q.left(p[0],p[1])||q.left(p.back(),p[0]))return false;",
            "\t\tint a=1,b=p.size()-1;  // returns true if point on boundary",
            "\t\twhile(b-a>1){          // (change sign of EPS in left",
            "\t\t\tint c=(a+b)/2;       //  to return false in such case)",
            "\t\t\tif(!q.left(p[0],p[c]))a=c;",
            "\t\t\telse b=c;",
            "\t\t}",
            "\t\treturn !q.left(p[a],p[a+1]);",
            "\t}",
            "\tpt farthest(pt v){ // O(log(n)) only CONVEX",
            "\t\tif(n<10){",
            "\t\t\tint k=0;",
            "\t\t\tfor(int i = 1; i < n; ++i)if(v*(p[i]-p[k])>EPS)k=i;",
            "\t\t\treturn p[k];",
            "\t\t}",
            "\t\tif(n==(int)p.size()) p.push_back(p[0]);",
            "\t\tpt a=p[1]-p[0];",
            "\t\tint s=0,e=n,ua=v*a>EPS;",
            "\t\tif(!ua&&v*(p[n-1]-p[0])<=EPS)return p[0];",
            "\t\twhile(1){",
            "\t\t\tint m=(s+e)/2;pt c=p[m+1]-p[m];",
            "\t\t\tint uc=v*c>EPS;",
            "\t\t\tif(!uc&&v*(p[m-1]-p[m])<=EPS)return p[m];",
            "\t\t\tif(ua&&(!uc||v*(p[s]-p[m])>EPS))e=m;",
            "\t\t\telse if(ua||uc||v*(p[s]-p[m])>=-EPS)s=m,a=c,ua=uc;",
            "\t\t\telse e=m;",
            "\t\t\tassert(e>s+1);",
            "\t\t}",
            "\t}",
            "\tpol cut(ln l){   // cut CONVEX polygon by line l",
            "\t\tvector<pt> q;  // returns part at left of l.pq",
            "\t\tfor(int i = 0; i < n; ++i){",
            "\t\t\tint d0=sgn(l.pq%(p[i]-l.p)),d1=sgn(l.pq%(p[(i+1)%n]-l.p));",
            "\t\t\tif(d0>=0)q.push_back(p[i]);",
            "\t\t\tln m(p[i],p[(i+1)%n]);",
            "\t\t\tif(d0*d1<0&&!(l/m))q.push_back(l^m);",
            "\t\t}",
            "\t\treturn pol(q);",
            "\t}",
            "\tdouble intercircle(circle c){ // area of intersection with circle",
            "\t\tdouble r=0.;",
            "\t\tfor(int i = 0; i < n; ++i){",
            "\t\t\tint j=(i+1)%n;double w=c.intertriangle(p[i],p[j]);",
            "\t\t\tif((p[j]-c.o)%(p[i]-c.o)>0)r+=w;",
            "\t\t\telse r-=w;",
            "\t\t}",
            "\t\treturn abs(r);",
            "\t}",
            "\tdouble callipers(){ // square distance of most distant points",
            "\t\tdouble r=0;     // prereq: convex, ccw, NO COLLINEAR POINTS",
            "\t\tfor(int i=0,j=n<2?0:1;i<j;++i){",
            "\t\t\tfor(;;j=(j+1)%n){",
            "\t\t\t\tr=max(r,(p[i]-p[j]).norm2());",
            "\t\t\t\tif((p[(i+1)%n]-p[i])%(p[(j+1)%n]-p[j])<=EPS)break;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "};",
            "// Dynamic convex hull trick",
            "vector<pol> w;",
            "void add(pt q){ // add(q), O(log^2(n))",
            "\tvector<pt> p={q};",
            "\twhile(!w.empty()&&(int)(w.back().p).size() <2*(int)p.size()){",
            "\t\tfor(pt v:w.back().p)p.push_back(v);",
            "\t\tw.pop_back();",
            "\t}",
            "\tw.push_back(pol(chull(p)));",
            "}",
            "long long query(pt v){ // max(q*v:q in w), O(log^2(n))",
            "\tlong long r=-INF;",
            "\tfor(auto& p:w)r=max(r,(long long)(p.farthest(v)*v));",
            "\treturn r;",
            "}"
        ],
        "description": "Snippet for polygon.cpp"
    },
    "circle.cpp": {
        "prefix": "circle.cpp",
        "body": [
            "struct circle {",
            "\tpt o;double r;",
            "\tcircle(pt o, double r):o(o),r(r){}",
            "\tcircle(pt x, pt y, pt z){o=bisector(x,y)^bisector(x,z);r=(o-x).norm();}",
            "\tbool has(pt p){return (o-p).norm()<=r+EPS;}",
            "\tvector<pt> operator^(circle c){ // ccw",
            "\t\tvector<pt> s;",
            "\t\tdouble d=(o-c.o).norm();",
            "\t\tif(d>r+c.r+EPS||d+min(r,c.r)+EPS<max(r,c.r))return s;",
            "\t\tdouble x=(d*d-c.r*c.r+r*r)/(2*d);",
            "\t\tdouble y=sqrt(r*r-x*x);",
            "\t\tpt v=(c.o-o)/d;",
            "\t\ts.push_back(o+v*x-v.rot(ccw90)*y);",
            "\t\tif(y>EPS)s.push_back(o+v*x+v.rot(ccw90)*y);",
            "\t\treturn s;",
            "\t}",
            "\tvector<pt> operator^(ln l){",
            "\t\tvector<pt> s;",
            "\t\tpt p=l.proj(o);",
            "\t\tdouble d=(p-o).norm();",
            "\t\tif(d-EPS>r)return s;",
            "\t\tif(abs(d-r)<=EPS){s.push_back(p);return s;}",
            "\t\td=sqrt(r*r-d*d);",
            "\t\ts.push_back(p+l.pq.unit()*d);",
            "\t\ts.push_back(p-l.pq.unit()*d);",
            "\t\treturn s;",
            "\t}",
            "\tvector<pt> tang(pt p){",
            "\t\tdouble d=sqrt((p-o).norm2()-r*r);",
            "\t\treturn *this^circle(p,d);",
            "\t}",
            "\tbool in(circle c){ // non strict",
            "\t\tdouble d=(o-c.o).norm();",
            "\t\treturn d+r<=c.r+EPS;",
            "\t}",
            "\tdouble intertriangle(pt a, pt b){ // area of intersection with oab",
            "\t\tif(abs((o-a)%(o-b))<=EPS)return 0.;",
            "\t\tvector<pt> q={a},w=*this^ln(a,b);",
            "\t\tif(w.size()==2)for(auto p:w)if((a-p)*(b-p)<-EPS)q.push_back(p);",
            "\t\tq.push_back(b);",
            "\t\tif(q.size()==4&&(q[0]-q[1])*(q[2]-q[1])>EPS)swap(q[1],q[2]);",
            "\t\tdouble s=0;",
            "\t\tfor(int i = 0; i < (int)q.size() - 1; ++i) {",
            "\t\t\tif(!has(q[i])||!has(q[i+1]))s+=r*r*(q[i]-o).angle(q[i+1]-o)/2;",
            "\t\t\telse s+=abs((q[i]-o)%(q[i+1]-o)/2);",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "};"
        ],
        "description": "Snippet for circle.cpp"
    },
    "plane.cpp": {
        "prefix": "plane.cpp",
        "body": [
            "struct plane {",
            "\tpt a,n; // n: normal unit vector",
            "\tplane(pt a, pt b, pt c):a(a),n(((b-a)^(c-a)).unit()){}",
            "\tplane(){}",
            "\tbool has(pt p){return abs((p-a)*n)<=EPS;}",
            "\tdouble angle(plane w){return acos(n*w.n);}",
            "\tdouble dist(pt p){return abs((p-a)*n);}",
            "\tpt proj(pt p){inter(ln(p,p+n),p);return p;}",
            "\tbool inter(ln l, pt& r){",
            "\t\tdouble x=n*(l.p+l.pq-a),y=n*(l.p-a);",
            "\t\tif(abs(x-y)<=EPS)return false;",
            "\t\tr=(l.p*x-(l.p+l.pq)*y)/(x-y);",
            "\t\treturn true;",
            "\t}",
            "\tbool inter(plane w, ln& r){",
            "\t\tpt nn=n^w.n;pt v=n^nn;double d=w.n*v;",
            "\t\tif(abs(d)<=EPS)return false;",
            "\t\tpt p=a+v*(w.n*(w.a-a)/d);",
            "\t\tr=ln(p,p+nn);",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "Snippet for plane.cpp"
    },
    "kdtree.cpp": {
        "prefix": "kdtree.cpp",
        "body": [
            "bool onx(pt a, pt b){return a.x<b.x;}",
            "bool ony(pt a, pt b){return a.y<b.y;}",
            "",
            "struct Node {",
            "\tpt pp;",
            "\tlong long x0=INF, x1=-INF, y0=INF, y1=-INF;",
            "\tNode *first=0, *second=0;",
            "\tlong long distance(pt p){",
            "\t\tlong long x=min(max(x0,(long long)p.x),x1);",
            "\t\tlong long y=min(max(y0,(long long)p.y),y1);",
            "\t\treturn (pt(x,y)-p).norm2();",
            "\t}",
            "\tNode(vector<pt>&& vp):pp(vp[0]){",
            "\t\tfor(pt p:vp){",
            "\t\t\tx0=min(x0,(long long)p.x); x1=max(x1,(long long)p.x);",
            "\t\t\ty0=min(y0,(long long)p.y); y1=max(y1,(long long)p.y);",
            "\t\t}",
            "\t\tif(vp.size() > 1){",
            "\t\t\tsort(vp.begin(), vp.end(),x1-x0>=y1-y0?onx:ony);",
            "\t\t\tint m=(int)(vp.size())/2;",
            "\t\t\tfirst=new Node({vp.begin(),vp.begin()+m});",
            "\t\t\tsecond=new Node({vp.begin()+m,vp.end()});",
            "\t\t}",
            "\t}",
            "};",
            "struct KDTree {",
            "\tNode* root;",
            "\tKDTree(const vector<pt>& vp):root(new Node({vp.begin(), vp.end()})) {}",
            "\tpair<long long,pt> search(pt p, Node *node){",
            "\t\tif(!node->first){",
            "\t\t\t//avoid query point as answer",
            "\t\t\t//if(p==node->pp) {INF,pt()};",
            "\t\t\treturn {(p-node->pp).norm2(),node->pp};",
            "\t\t}",
            "\t\tNode *f=node->first, *s=node->second;",
            "\t\tlong long bf=f->distance(p), bs=s->distance(p);",
            "\t\tif(bf>bs)swap(bf,bs),swap(f,s);",
            "\t\tauto best=search(p,f);",
            "\t\tif(bs<best.first) best=min(best,search(p,s));",
            "\t\treturn best;",
            "\t}",
            "\tpair<long long,pt> nearest(pt p){return search(p,root);}",
            "};"
        ],
        "description": "Snippet for kdtree.cpp"
    },
    "convex_hull.cpp": {
        "prefix": "convex_hull.cpp",
        "body": [
            "vector<pt> chull(vector<pt> p){",
            "\tif(p.size()<3)return p;",
            "\tvector<pt> r;",
            "\tsort(p.begin(),p.end()); // first x, then y",
            "\tfor(int i = 0; i < (int)p.size(); ++i){ // lower hull",
            "\t\twhile(r.size()>=2&&r.back().left(r[r.size()-2],p[i]))r.pop_back();",
            "\t\tr.push_back(p[i]);",
            "\t}",
            "\tr.pop_back();",
            "\tint k=r.size();",
            "\tfor(int i=p.size()-1;i>=0;--i){ // upper hull",
            "\t\twhile((int)r.size()>=k+2&&r.back().left(r[(int)r.size()-2],p[i]))r.pop_back();",
            "\t\tr.push_back(p[i]);",
            "\t}",
            "\tr.pop_back();",
            "\treturn r;",
            "}",
            ""
        ],
        "description": "Snippet for convex_hull.cpp"
    },
    "tem-comp.cpp": {
        "prefix": "tem-comp.cpp",
        "body": [
            "/*",
            " \u00a9 $%Y%$-$%M%$-$%D%$ $%h%$:$%m%$:$%s%$ $%U%$ All Rights Reserved",
            "*/",
            "",
            "//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")",
            "//#pragma GCC target(\"avx,avx2,fma\")",
            "#include <bits/stdc++.h>",
            "#define f first",
            "#define s second",
            "#define fore(i,a,b) for(int i = (a), ThxMK = (b); i < ThxMK; ++i)",
            "#define pb push_back",
            "#define all(s) begin(s), end(s)",
            "#define _ ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
            "#define sz(s) int(s.size())",
            "#define ENDL '\\n'",
            "using namespace std;",
            "// #include <ext/pb_ds/assoc_container.hpp>",
            "// #include <ext/pb_ds/trie_policy.hpp>",
            "// using namespace __gnu_pbds;",
            "// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",
            "typedef long double ld;",
            "typedef long long lli;",
            "typedef pair<lli,lli> ii;",
            "typedef vector<lli> vi;",
            "#define deb(x) cout << #x\": \" << (x) << endl;",
            "template <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;",
            "// unsigned int",
            "// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());",
            "// long long",
            "// mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());",
            "// int en rango [L,R]",
            "// auto rnd=bind(uniform_int_distribution<int>(L,R), mt19937(time(0)));",
            "// long long en rango [L,R]",
            "// auto rnd=bind(uniform_int_distribution<long long>(L,R), mt19937(time(0)));",
            "// double en rango [L, R)",
            "// auto rnd=bind(uniform_real_distribution<double>(L,R), mt19937(time(0)));",
            "lli MOD = 1e9 + 7;",
            "lli gcd(lli a, lli b){return (b?gcd(b,a%b):a);}",
            "lli lcm(lli a, lli b){ if(!a || !b) return 0; return a * b / gcd(a, b); }",
            "int popcount(lli x) { return __builtin_popcountll(x); }",
            "lli powm(lli a, lli b){",
            "    lli res =1;",
            "    while(b){ if(b&1) res = (res * a) % MOD; a = (a*a) % MOD; b/=2; }",
            "    return res;",
            "}",
            "lli invm(lli a) {",
            "  return powm(a, MOD - 2);",
            "}",
            "lli poww(lli a, lli b){",
            "    lli res =1;",
            "    while(b){ if(b&1) res = res * a; a = a*a; b/=2; }",
            "    return res;",
            "}",
            "vi sieve(int N){",
            "    vi m(N+1,0);",
            "    vi primes(1,2);",
            "    for(int i = 4; i < N; i += 2) m[i]=1;",
            "    for(int i = 3; i*i <= N; i +=2) if(!m[i]) for(int j = i*i; j < N; j += i) m[j]=1;",
            "    for(int i = 3; i < N; i += 2) if(!m[i]) primes.pb(i);",
            "    return primes;",
            "}",
            "int main(){ _",
            "  return 0;",
            "}",
            ""
        ],
        "description": "Snippet for tem-comp.cpp"
    },
    "tem.cpp": {
        "prefix": "tem.cpp",
        "body": [
            "/*",
            " \u00a9 $%Y%$-$%M%$-$%D%$ $%h%$:$%m%$:$%s%$ $%U%$ All Rights Reserved",
            "*/",
            "",
            "// #pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")",
            "// #pragma GCC target(\"avx,avx2,fma\")",
            "#include <bits/stdc++.h>",
            "#define f first",
            "#define s second",
            "#define fore(i,a,b) for(int i = (a), ThxMK = (b); i < ThxMK; ++i)",
            "#define pb push_back",
            "#define all(s) begin(s), end(s)",
            "#define _ ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
            "#define sz(s) int(s.size())",
            "#define ENDL '\\n'",
            "using namespace std;",
            "typedef long double ld;",
            "typedef long long lli;",
            "typedef pair<lli,lli> ii;",
            "typedef vector<lli> vi;",
            "#define deb(x) cout << #x\": \" << (x) << endl;",
            "",
            "int main(){ _",
            "  // freopen(\"file.in\",\"r\",stdin);",
            "  // freopen(\"file.out\",\"w\",stdout);",
            "  return 0;",
            "}",
            ""
        ],
        "description": "Snippet for tem.cpp"
    },
    "MCMF_cycles.cpp": {
        "prefix": "MCMF_cycles.cpp",
        "body": [
            "typedef int tf;",
            "typedef int tc;",
            "const tc INFCOST = numeric_limits<tc>::max()/2;",
            "const int scale=2;",
            "struct mcSFlow{",
            "  int n, s, t; tc eps;",
            "  vector<int> isq, cur, co; vector<tf> ex; vector<tc> h; vector<vector<int>> hs;",
            "  struct edge{int to, rev; tf f; tc c;};",
            "  vector<vector<edge>> g;",
            "  mcSFlow(int n,int s,int t):eps(0),n(n),s(s),t(t),g(n){}",
            "  void add_edge(int a, int b, tc cost, tf cap){",
            "    if(a==b){assert(cost>=0); return;}",
            "    cost*=n; eps = max(eps, abs(cost));",
            "    g[a].pb({b, sz(g[b]), cap, cost});",
            "    g[b].pb({a, sz(g[a])-1, 0, -cost});",
            "  }",
            "  void add_flow(edge& e, tf f) {",
            "    edge &back = g[e.to][e.rev];",
            "    if (!ex[e.to] && f) hs[h[e.to]].push_back(e.to);",
            "    e.f -= f; ex[e.to] += f;",
            "    back.f += f; ex[back.to] -= f;",
            "  }",
            "  tf max_flow() {",
            "    ex.assign(n, 0), h.assign(n, 0), co.assign(2*n, 0), cur.assign(n, 0), hs.resize(2*n);",
            "    h[s] = n, ex[t] = 1, co[0] = n - 1;",
            "    for(auto &e:g[s]) add_flow(e, e.f);",
            "    if(hs[0].size()) for (int hi=0;hi>=0;) {",
            "      int u = hs[hi].back(); hs[hi].pop_back();",
            "      while (ex[u] > 0) { // discharge u",
            "        if (cur[u] == g[u].size()) {",
            "          h[u] = 1e9;",
            "          fore(i,0,sz(g[u])){",
            "            auto &e = g[u][i];",
            "            if (e.f && h[u] > h[e.to]+1) h[u] = h[e.to]+1, cur[u] = i;",
            "          }",
            "          if(hi==n)break;",
            "          if (++co[h[u]] && !--co[hi] && hi < n) {",
            "            fore(i,0,n) if (hi < h[i] && h[i] < n){",
            "              --co[h[i]];",
            "              h[i] = n + 1;",
            "            }",
            "          }",
            "          hi = h[u];",
            "        } else if (g[u][cur[u]].f && h[u] == h[g[u][cur[u]].to]+1) {",
            "          add_flow(g[u][cur[u]], min(ex[u], g[u][cur[u]].f));",
            "        } else ++cur[u];",
            "\t\t\t    }",
            "      while (hi>=0 && hs[hi].empty()) --hi;",
            "    }",
            "    return -ex[s];",
            "  }",
            "  void push(edge &e, tf amt){",
            "    if(e.f < amt) amt=e.f;",
            "    e.f-=amt; ex[e.to]+=amt;",
            "    g[e.to][e.rev].f+=amt; ex[g[e.to][e.rev].to]-=amt;",
            "  }",
            "  void relabel(int vertex){",
            "    tc newHeight = -INFCOST;",
            "\t\tfore(i,0,sz(g[vertex])){",
            "      edge const&e = g[vertex][i];",
            "      if(e.f && newHeight < h[e.to]-e.c){",
            "        newHeight = h[e.to] - e.c;",
            "        cur[vertex] = i;",
            "      }",
            "    }",
            "    h[vertex] = newHeight - eps;",
            "  }",
            "  pair<tf, tc> minCostMaxFlow(){",
            "    tc retCost = 0;",
            "    fore(i,0,n) for(edge &e:g[i]) retCost += e.c*(e.f);",
            "    tf retFlow = max_flow(); ",
            "    h.assign(n, 0); ex.assign(n, 0); isq.assign(n, 0); cur.assign(n,0);",
            "    queue<int> q;",
            "    for(;eps;eps>>=scale){",
            "      fill(cur.begin(), cur.end(), 0);",
            "      fore(i,0,n) for(auto &e:g[i])",
            "        if(h[i] + e.c - h[e.to] < 0 && e.f) push(e, e.f);",
            "      fore(i,0,n) if(ex[i]>0)q.push(i),isq[i]=1;",
            "      while(!q.empty()){",
            "        int u=q.front();q.pop();",
            "        isq[u]=0;",
            "        while(ex[u]>0){",
            "          if(cur[u] == g[u].size()) relabel(u);",
            "          for(int &i=cur[u], max_i = g[u].size();i<max_i;++i){",
            "            edge &e=g[u][i];",
            "            if(h[u] + e.c - h[e.to] < 0){",
            "              push(e, ex[u]);",
            "              if(ex[e.to]>0 && isq[e.to]==0) q.push(e.to), isq[e.to]=1;",
            "              if(ex[u]==0) break;",
            "            }",
            "          }",
            "        }",
            "      }",
            "      if(eps>1 && eps>>scale==0) eps = 1<<scale;",
            "    }",
            "    fore(i,0,n) for(edge &e:g[i])retCost -= e.c*(e.f);",
            "    return make_pair(retFlow, retCost/2/n);",
            "  }",
            "  tf getFlow(edge const &e){",
            "    return g[e.to][e.rev].f;",
            "  }",
            "};"
        ],
        "description": "Snippet for MCMF_cycles.cpp"
    },
    "hungarian.cpp": {
        "prefix": "hungarian.cpp",
        "body": [
            "typedef long double td; ",
            "typedef vector<int> vi; ",
            "typedef vector<td> vd;",
            "const td INF=1e10;//for maximum set INF to 0, and negate costs",
            "bool zero(td x){return fabs(x)<1e-9;}//change to x==0, for ints/ll",
            "struct Hungarian{",
            "    int n; vector<vd> cs; vi L, R;",
            "    Hungarian(int N, int M):n(max(N,M)),cs(n,vd(n)),L(n),R(n){",
            "        fore(x,0,N)fore(y,0,M)cs[x][y]=INF;",
            "    }",
            "    void set(int x,int y,td c){cs[x][y]=c;}",
            "\ttd assign() {",
            "\t\tint mat = 0; vd ds(n), u(n), v(n); vi dad(n), sn(n);",
            "\t\tfore(i,0,n)u[i]=*min_element(all(cs[i]));",
            "\t\tfore(j,0,n){",
            "            v[j]=cs[0][j]-u[0];",
            "            fore(i,1,n)v[j]=min(v[j],cs[i][j]-u[i]);",
            "        }",
            "\t\tL=R=vector<int>(n, -1);",
            "\t\tfore(i,0,n)fore(j,0,n)",
            "\t\t\tif(R[j]==-1&&zero(cs[i][j]-u[i]-v[j])){",
            "                L[i]=j;R[j]=i;",
            "                mat++;",
            "                break;",
            "            }",
            "\t\tfor(;mat<n;mat++){",
            "\t\t    int s=0, j=0, i;",
            "\t\t    while(L[s] != -1)s++;",
            "\t\t    fill(all(dad),-1);",
            "            fill(all(sn),0);",
            "\t\t    fore(k,0,n)ds[k]=cs[s][k]-u[s]-v[k];",
            "\t\t    for(;;){",
            "\t\t        j = -1;",
            "\t\t        fore(k,0,n)if(!sn[k]&&(j==-1||ds[k]<ds[j]))j=k;",
            "\t\t        sn[j] = 1; i = R[j];",
            "\t\t        if(i == -1) break;",
            "\t\t        fore(k,0,n)if(!sn[k]){",
            "\t\t            auto new_ds=ds[j]+cs[i][k]-u[i]-v[k];",
            "\t\t            if(ds[k] > new_ds){ds[k]=new_ds;dad[k]=j;}",
            "\t\t        }",
            "\t\t    }",
            "\t\t    fore(k,0,n)if(k!=j&&sn[k]){",
            "                auto w=ds[k]-ds[j];",
            "                v[k]+=w,u[R[k]]-=w;",
            "            }",
            "\t\t    u[s] += ds[j];",
            "\t\t    while(dad[j]>=0){",
            "                int d = dad[j];",
            "                R[j]=R[d];",
            "                L[R[j]]=j;j=d;",
            "            }",
            "\t\t    R[j]=s;L[s]=j;",
            "\t\t}",
            "\t\ttd value=0;",
            "        fore(i,0,n)value+=cs[i][L[i]];",
            "\t\treturn value;",
            "\t}",
            "};"
        ],
        "description": "Snippet for hungarian.cpp"
    },
    "matching-bip.cpp": {
        "prefix": "matching-bip.cpp",
        "body": [
            "struct Bipartite_Matching {",
            "  vector<vector<int>> graph;",
            "  vector<int> dist, match, used;",
            "  vector<bool> vv;",
            "",
            "  Bipartite_Matching(int n, int m) {",
            "    graph.resize(n);",
            "    match.assign(m, -1);",
            "    used.assign(n, -1);",
            "  }",
            "",
            "  void add(int u, int v) { graph[u].push_back(v);}",
            "",
            "  void bfs() {",
            "    dist.assign(graph.size(), -1);",
            "    queue< int > que;",
            "    for(int i = 0; i < graph.size(); i++) {",
            "      if(used[i] == -1) {",
            "        que.emplace(i);",
            "        dist[i] = 0;",
            "      }",
            "    }",
            "",
            "    while(!que.empty()) {",
            "      int a = que.front();",
            "      que.pop();",
            "      for(auto &b : graph[a]) {",
            "        int c = match[b];",
            "        if(c >= 0 && dist[c] == -1) {",
            "          dist[c] = dist[a] + 1;",
            "          que.emplace(c);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  bool dfs(int a) {",
            "    vv[a] = true;",
            "    for(auto &b : graph[a]) {",
            "      int c = match[b];",
            "      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {",
            "        match[b] = a;",
            "        used[a] = b;",
            "        return (true);",
            "      }",
            "    }",
            "    return (false);",
            "  }",
            "",
            "  int bipartite_matching() {",
            "    int ret = 0;",
            "    while(true) {",
            "      bfs();",
            "      vv.assign(graph.size(), false);",
            "      int flow = 0;",
            "      for(int i = 0; i < graph.size(); i++) {",
            "        if(used[i] == -1 && dfs(i)) ++flow;",
            "      }",
            "      if(flow == 0) return (ret);",
            "      ret += flow;",
            "    }",
            "  }",
            "};",
            ""
        ],
        "description": "Snippet for matching-bip.cpp"
    },
    "MCMF.cpp": {
        "prefix": "MCMF.cpp",
        "body": [
            "template <typename tf, typename tc>struct MCF{",
            "int n;",
            "  tf INFFLOW;",
            "  tc INFCOST;",
            "  vector<tc> prio, pot;",
            "  vector<tf> curflow;",
            "  vector<int> prevedge,prevnode;",
            "\tpriority_queue<pair<tc, int>, vector<pair<tc, int>>, greater<pair<tc, int>>> q;",
            "\tstruct edge{int to, rev; tf f, cap; tc cost;};",
            "\tvector<vector<edge>> g;",
            "\tMCF(int n):n(n),prio(n),curflow(n),prevedge(n),prevnode(n),pot(n),g(n){",
            "    INFFLOW=numeric_limits<tf>::max() / 2;",
            "    INFCOST=numeric_limits<tc>::max() / 2;",
            "  }",
            "\tvoid add(int s, int t, tf cap, tc cost) {",
            "\t\tg[s].pb((edge){t,sz(g[t]),0,cap,cost});",
            "\t\tg[t].pb((edge){s,sz(g[s])-1,0,0,-cost});",
            "\t}",
            "\tpair<tf,tc> get_flow(int s, int t) {",
            "\t\ttf flow=0; tc flowcost=0;",
            "\t\twhile(1){",
            "\t\t\tq.push({0, s});",
            "\t\t\tfill(all(prio),INFCOST);",
            "\t\t\tprio[s]=0; curflow[s]=INFFLOW;",
            "\t\t\twhile(!q.empty()) {",
            "\t\t\t\tauto cur=q.top();",
            "\t\t\t\ttc d=cur.f;",
            "\t\t\t\tint u=cur.s;",
            "\t\t\t\tq.pop();",
            "\t\t\t\tif(d!=prio[u]) continue;",
            "\t\t\t\tfor(int i=0; i<sz(g[u]); ++i) {",
            "\t\t\t\t\tedge &e=g[u][i];",
            "\t\t\t\t\tint v=e.to;",
            "\t\t\t\t\tif(e.cap<=e.f) continue;",
            "\t\t\t\t\ttc nprio=prio[u]+e.cost+pot[u]-pot[v];",
            "\t\t\t\t\tif(prio[v]>nprio) {",
            "\t\t\t\t\t\tprio[v]=nprio;",
            "\t\t\t\t\t\tq.push({nprio, v});",
            "\t\t\t\t\t\tprevnode[v]=u; prevedge[v]=i;",
            "\t\t\t\t\t\tcurflow[v]=min(curflow[u], e.cap-e.f);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(prio[t]==INFCOST) break;",
            "\t\t\tfore(i,0,n) pot[i]+=prio[i];",
            "\t\t\ttf df=min(curflow[t], INFFLOW-flow);",
            "\t\t\tflow+=df;",
            "\t\t\tfor(int v=t; v!=s; v=prevnode[v]) {",
            "\t\t\t\tedge &e=g[prevnode[v]][prevedge[v]];",
            "\t\t\t\te.f+=df; g[v][e.rev].f-=df;",
            "\t\t\t\tflowcost+=df*e.cost;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn {flow,flowcost};",
            "\t}",
            "};",
            ""
        ],
        "description": "Snippet for MCMF.cpp"
    },
    "dinic.cpp": {
        "prefix": "dinic.cpp",
        "body": [
            "// Min cut: nodes with dist>=0 vs nodes with dist<0",
            "// Matching MVC: left nodes with dist<0 + right nodes with dist>0",
            "struct Dinic{",
            "\tint nodes,src,dst;",
            "\tvector<int> dist,q,work;",
            "\tstruct edge {int to,rev;lli f,cap;};",
            "\tvector<vector<edge>> g;",
            "\tDinic(int x):nodes(x),g(x),dist(x),q(x),work(x){}",
            "\tvoid add_edge(int s, int t, lli cap){",
            "\t\tg[s].pb((edge){t,sz(g[t]),0,cap});",
            "\t\tg[t].pb((edge){s,sz(g[s])-1,0,0});",
            "\t}",
            "\tbool dinic_bfs(){",
            "\t\tfill(all(dist),-1);dist[src]=0;",
            "\t\tint qt=0;q[qt++]=src;",
            "\t\tfor(int qh=0;qh<qt;qh++){",
            "\t\t\tint u=q[qh];",
            "\t\t\tfore(i,0,sz(g[u])){",
            "\t\t\t\tedge &e=g[u][i];int v=g[u][i].to;",
            "\t\t\t\tif(dist[v]<0&&e.f<e.cap)dist[v]=dist[u]+1,q[qt++]=v;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn dist[dst]>=0;",
            "\t}",
            "\tlli dinic_dfs(int u, lli f){",
            "\t\tif(u==dst)return f;",
            "\t\tfor(int &i=work[u];i<sz(g[u]);i++){",
            "\t\t\tedge &e=g[u][i];",
            "\t\t\tif(e.cap<=e.f)continue;",
            "\t\t\tint v=e.to;",
            "\t\t\tif(dist[v]==dist[u]+1){",
            "\t\t\t\tlli df=dinic_dfs(v,min(f,e.cap-e.f));",
            "\t\t\t\tif(df>0){e.f+=df;g[v][e.rev].f-=df;return df;}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\tlli max_flow(int _src, int _dst){",
            "\t\tsrc=_src;dst=_dst;",
            "\t\tlli result=0;",
            "\t\twhile(dinic_bfs()){",
            "\t\t\tfill(all(work),0);",
            "\t\t\twhile(lli delta=dinic_dfs(src,INF))result+=delta;",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "};"
        ],
        "description": "Snippet for dinic.cpp"
    },
    "dinic_crystal.cpp": {
        "prefix": "dinic_crystal.cpp",
        "body": [
            "template <typename flow_t> struct Dinic {",
            "    const flow_t INF;",
            "    struct edge {int to;flow_t cap;int rev;bool isrev;int idx;};",
            "    vector<vector<edge>> graph;",
            "    vector<int> min_cost, iter;",
            "    Dinic(int V) : INF(numeric_limits<flow_t>::max()), graph(V) {}",
            "    void add(int from, int to, flow_t cap, int idx = -1) {",
            "        graph[from].emplace_back((edge){to, cap, (int)graph[to].size(), false, idx});",
            "        graph[to].emplace_back((edge){from, 0, (int)graph[from].size() - 1, true, idx});",
            "    }",
            "    bool bfs(int s, int t) {",
            "        min_cost.assign(graph.size(), -1);",
            "        queue<int> que;",
            "        min_cost[s] = 0;",
            "        que.push(s);",
            "        while(!que.empty() && min_cost[t] == -1) {",
            "            int p = que.front();",
            "            que.pop();",
            "            for(auto &e : graph[p]) {",
            "                if(e.cap > 0 && min_cost[e.to] == -1) {",
            "                    min_cost[e.to] = min_cost[p] + 1;",
            "                    que.push(e.to);",
            "                }",
            "            }",
            "        }",
            "        return min_cost[t] != -1;",
            "    }",
            "    flow_t dfs(int idx, const int t, flow_t flow) {",
            "        if(idx == t) return flow;",
            "        for(int &i = iter[idx]; i < graph[idx].size(); i++) {",
            "            edge &e = graph[idx][i];",
            "            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {",
            "                flow_t d = dfs(e.to, t, min(flow, e.cap));",
            "                if(d > 0) {",
            "                    e.cap -= d;",
            "                    graph[e.to][e.rev].cap += d;",
            "                    return d;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "    flow_t max_flow(int s, int t) {",
            "        flow_t flow = 0;",
            "        while(bfs(s, t)) {",
            "            iter.assign(graph.size(), 0);",
            "            flow_t f = 0;",
            "            while((f = dfs(s, t, INF)) > 0) flow += f;",
            "        }",
            "        return flow;",
            "    }",
            "    void output() {",
            "        for(int i = 0; i < graph.size(); i++) {",
            "            for(auto &e : graph[i]) {",
            "                if(e.isrev) continue;",
            "                auto &rev_e = graph[e.to][e.rev];",
            "                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << ENDL;",
            "            }",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "Snippet for dinic_crystal.cpp"
    }
}