{
"sparse_table.cpp": {
	"prefix": "sparse_table.cpp" ,
	"body": ["#define oper min","int st[K][1<<K];int n;  // K such that 2^K>n","void st_init(int *a){","	fore(i,0,n)st[0][i]=a[i];","	fore(k,1,K)fore(i,0,n-(1<<k)+1)","		st[k][i]=oper(st[k-1][i],st[k-1][i+(1<<(k-1))]);","}","int st_query(int s, int e){","	int k=31-__builtin_clz(e-s);","	return oper(st[k][s],st[k][e-(1<<k)]);","}",]
},
"bigint.cpp": {
	"prefix": "bigint.cpp" ,
	"body": ["/*","  ######################################################################","  #######################   THE   BIG   INT   ##########################","*/","const int base = 1000000000;","const int base_digits = 9;","struct bigint {","    vector<int> a;","    int sign;","    /*<arpa>*/","    int size(){","	if(a.empty())return 0;","	int ans=(a.size()-1)*base_digits;","	int ca=a.back();","	while(ca)","	    ans++,ca/=10;","	return ans;","    }","    bigint operator ^(const bigint &v){","	bigint ans=1,a=*this,b=v;","	while(!b.isZero()){","	    if(b%2)","		ans*=a;","	    a*=a,b/=2;","	}","	return ans;","    }","    string to_string(){","	stringstream ss;","	ss << *this;","	string s;","	ss >> s;","	return s;","    }","    int sumof(){","	string s = to_string();","	int ans = 0;","	for(auto c : s)  ans += c - '0';","	return ans;","    }","    /*</arpa>*/","    bigint() :","	sign(1) {","    }","","    bigint(long long v) {","	*this = v;","    }","","    bigint(const string &s) {","	read(s);","    }","","    void operator=(const bigint &v) {","	sign = v.sign;","	a = v.a;","    }","","    void operator=(long long v) {","	sign = 1;","	a.clear();","	if (v < 0)","	    sign = -1, v = -v;","	for (; v > 0; v = v / base)","	    a.push_back(v % base);","    }","","    bigint operator+(const bigint &v) const {","	if (sign == v.sign) {","	    bigint res = v;","","	    for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {","		if (i == (int) res.a.size())","		    res.a.push_back(0);","		res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);","		carry = res.a[i] >= base;","		if (carry)","		    res.a[i] -= base;","	    }","	    return res;","	}","	return *this - (-v);","    }","","    bigint operator-(const bigint &v) const {","	if (sign == v.sign) {","	    if (abs() >= v.abs()) {","		bigint res = *this;","		for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {","		    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);","		    carry = res.a[i] < 0;","		    if (carry)","			res.a[i] += base;","		}","		res.trim();","		return res;","	    }","	    return -(v - *this);","	}","	return *this + (-v);","    }","","    void operator*=(int v) {","	if (v < 0)","	    sign = -sign, v = -v;","	for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {","	    if (i == (int) a.size())","		a.push_back(0);","	    long long cur = a[i] * (long long) v + carry;","	    carry = (int) (cur / base);","	    a[i] = (int) (cur % base);","	    //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));","	}","	trim();","    }","","    bigint operator*(int v) const {","	bigint res = *this;","	res *= v;","	return res;","    }","","    void operator*=(long long v) {","	if (v < 0)","	    sign = -sign, v = -v;","	for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {","	    if (i == (int) a.size())","		a.push_back(0);","	    long long cur = a[i] * (long long) v + carry;","	    carry = (int) (cur / base);","	    a[i] = (int) (cur % base);","	    //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));","	}","	trim();","    }","","    bigint operator*(long long v) const {","	bigint res = *this;","	res *= v;","	return res;","    }","","    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {","	int norm = base / (b1.a.back() + 1);","	bigint a = a1.abs() * norm;","	bigint b = b1.abs() * norm;","	bigint q, r;","	q.a.resize(a.a.size());","","	for (int i = a.a.size() - 1; i >= 0; i--) {","	    r *= base;","	    r += a.a[i];","	    int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];","	    int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];","	    int d = ((long long) base * s1 + s2) / b.a.back();","	    r -= b * d;","	    while (r < 0)","		r += b, --d;","	    q.a[i] = d;","	}","","	q.sign = a1.sign * b1.sign;","	r.sign = a1.sign;","	q.trim();","	r.trim();","	return make_pair(q, r / norm);","    }","","    bigint operator/(const bigint &v) const {","	return divmod(*this, v).first;","    }","","    bigint operator%(const bigint &v) const {","	return divmod(*this, v).second;","    }","","    void operator/=(int v) {","	if (v < 0)","	    sign = -sign, v = -v;","	for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {","	    long long cur = a[i] + rem * (long long) base;","	    a[i] = (int) (cur / v);","	    rem = (int) (cur % v);","	}","	trim();","    }","","    bigint operator/(int v) const {","	bigint res = *this;","	res /= v;","	return res;","    }","","    int operator%(int v) const {","	if (v < 0)","	    v = -v;","	int m = 0;","	for (int i = a.size() - 1; i >= 0; --i)","	    m = (a[i] + m * (long long) base) % v;","	return m * sign;","    }","","    void operator+=(const bigint &v) {","	*this = *this + v;","    }","    void operator-=(const bigint &v) {","	*this = *this - v;","    }","    void operator*=(const bigint &v) {","	*this = *this * v;","    }","    void operator/=(const bigint &v) {","	*this = *this / v;","    }","","    bool operator<(const bigint &v) const {","	if (sign != v.sign)","	    return sign < v.sign;","	if (a.size() != v.a.size())","	    return a.size() * sign < v.a.size() * v.sign;","	for (int i = a.size() - 1; i >= 0; i--)","	    if (a[i] != v.a[i])","		return a[i] * sign < v.a[i] * sign;","	return false;","    }","","    bool operator>(const bigint &v) const {","	return v < *this;","    }","    bool operator<=(const bigint &v) const {","	return !(v < *this);","    }","    bool operator>=(const bigint &v) const {","	return !(*this < v);","    }","    bool operator==(const bigint &v) const {","	return !(*this < v) && !(v < *this);","    }","    bool operator!=(const bigint &v) const {","	return *this < v || v < *this;","    }","","    void trim() {","	while (!a.empty() && !a.back())","	    a.pop_back();","	if (a.empty())","	    sign = 1;","    }","","    bool isZero() const {","	return a.empty() || (a.size() == 1 && !a[0]);","    }","","    bigint operator-() const {","	bigint res = *this;","	res.sign = -sign;","	return res;","    }","","    bigint abs() const {","	bigint res = *this;","	res.sign *= res.sign;","	return res;","    }","","    long long longValue() const {","	long long res = 0;","	for (int i = a.size() - 1; i >= 0; i--)","	    res = res * base + a[i];","	return res * sign;","    }","","    friend bigint gcd(const bigint &a, const bigint &b) {","	return b.isZero() ? a : gcd(b, a % b);","    }","    friend bigint lcm(const bigint &a, const bigint &b) {","	return a / gcd(a, b) * b;","    }","","    void read(const string &s) {","	sign = 1;","	a.clear();","	int pos = 0;","	while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {","	    if (s[pos] == '-')","		sign = -sign;","	    ++pos;","	}","	for (int i = s.size() - 1; i >= pos; i -= base_digits) {","	    int x = 0;","	    for (int j = max(pos, i - base_digits + 1); j <= i; j++)","		x = x * 10 + s[j] - '0';","	    a.push_back(x);","	}","	trim();","    }","","    friend istream& operator>>(istream &stream, bigint &v) {","	string s;","	stream >> s;","	v.read(s);","	return stream;","    }","","    friend ostream& operator<<(ostream &stream, const bigint &v) {","	if (v.sign == -1)","	    stream << '-';","	stream << (v.a.empty() ? 0 : v.a.back());","	for (int i = (int) v.a.size() - 2; i >= 0; --i)","	    stream << setw(base_digits) << setfill('0') << v.a[i];","	return stream;","    }","","    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {","	vector<long long> p(max(old_digits, new_digits) + 1);","	p[0] = 1;","	for (int i = 1; i < (int) p.size(); i++)","	    p[i] = p[i - 1] * 10;","	vector<int> res;","	long long cur = 0;","	int cur_digits = 0;","	for (int i = 0; i < (int) a.size(); i++) {","	    cur += a[i] * p[cur_digits];","	    cur_digits += old_digits;","	    while (cur_digits >= new_digits) {","		res.push_back(int(cur % p[new_digits]));","		cur /= p[new_digits];","		cur_digits -= new_digits;","	    }","	}","	res.push_back((int) cur);","	while (!res.empty() && !res.back())","	    res.pop_back();","	return res;","    }","","    typedef vector<long long> vll;","","    static vll karatsubaMultiply(const vll &a, const vll &b) {","	int n = a.size();","	vll res(n + n);","	if (n <= 32) {","	    for (int i = 0; i < n; i++)","		for (int j = 0; j < n; j++)","		    res[i + j] += a[i] * b[j];","	    return res;","	}","","	int k = n >> 1;","	vll a1(a.begin(), a.begin() + k);","	vll a2(a.begin() + k, a.end());","	vll b1(b.begin(), b.begin() + k);","	vll b2(b.begin() + k, b.end());","","	vll a1b1 = karatsubaMultiply(a1, b1);","	vll a2b2 = karatsubaMultiply(a2, b2);","","	for (int i = 0; i < k; i++)","	    a2[i] += a1[i];","	for (int i = 0; i < k; i++)","	    b2[i] += b1[i];","","	vll r = karatsubaMultiply(a2, b2);","	for (int i = 0; i < (int) a1b1.size(); i++)","	    r[i] -= a1b1[i];","	for (int i = 0; i < (int) a2b2.size(); i++)","	    r[i] -= a2b2[i];","","	for (int i = 0; i < (int) r.size(); i++)","	    res[i + k] += r[i];","	for (int i = 0; i < (int) a1b1.size(); i++)","	    res[i] += a1b1[i];","	for (int i = 0; i < (int) a2b2.size(); i++)","	    res[i + n] += a2b2[i];","	return res;","    }","","    bigint operator*(const bigint &v) const {","	vector<int> a6 = convert_base(this->a, base_digits, 6);","	vector<int> b6 = convert_base(v.a, base_digits, 6);","	vll a(a6.begin(), a6.end());","	vll b(b6.begin(), b6.end());","	while (a.size() < b.size())","	    a.push_back(0);","	while (b.size() < a.size())","	    b.push_back(0);","	while (a.size() & (a.size() - 1))","	    a.push_back(0), b.push_back(0);","	vll c = karatsubaMultiply(a, b);","	bigint res;","	res.sign = sign * v.sign;","	for (int i = 0, carry = 0; i < (int) c.size(); i++) {","	    long long cur = c[i] + carry;","	    res.a.push_back((int) (cur % 1000000));","	    carry = (int) (cur / 1000000);","	}","	res.a = convert_base(res.a, 6, base_digits);","	res.trim();","	return res;","    }","};","/*","  #######################   THE   BIG   INT   ##########################","  ######################################################################","*/",]
},
"treap_implicit.cpp": {
	"prefix": "treap_implicit.cpp" ,
	"body": ["// example that supports range reverse and addition updates, and range sum query","// (commented parts are specific to this  problem)","typedef struct item *pitem;","struct item {","	int pr,cnt,val;","//	int sum; // (paramters for range query)","//	bool rev;int add; // (parameters for lazy prop)","	pitem l,r;","	item(int val): pr(rand()),cnt(1),val(val),l(0),r(0)/*,sum(val),rev(0),add(0)*/ {}","};","void push(pitem it){","	if(it){","		/*if(it->rev){","			swap(it->l,it->r);","			if(it->l)it->l->rev^=true;","			if(it->r)it->r->rev^=true;","			it->rev=false;","		}","		it->val+=it->add;it->sum+=it->cnt*it->add;","		if(it->l)it->l->add+=it->add;","		if(it->r)it->r->add+=it->add;","		it->add=0;*/","	}","}","int cnt(pitem t){return t?t->cnt:0;}","// int sum(pitem t){return t?push(t),t->sum:0;}","void upd_cnt(pitem t){","	if(t){","		t->cnt=cnt(t->l)+cnt(t->r)+1;","		// t->sum=t->val+sum(t->l)+sum(t->r);","	}","}","void merge(pitem& t, pitem l, pitem r){","	push(l);push(r);","	if(!l||!r)t=l?l:r;","	else if(l->pr>r->pr)merge(l->r,l->r,r),t=l;","	else merge(r->l,l,r->l),t=r;","	upd_cnt(t);","}","void split(pitem t, pitem& l, pitem& r, int sz){ // sz:desired size of l","	if(!t){l=r=0;return;}","	push(t);","	if(sz<=cnt(t->l))split(t->l,l,t->l,sz),r=t;","	else split(t->r,t->r,r,sz-1-cnt(t->l)),l=t;","	upd_cnt(t);","}","void output(pitem t){ // useful for debugging","	if(!t)return;","	push(t);","	output(t->l);printf(\" %d\",t->val);output(t->r);","}","// use merge and split for range updates and queries",]
},
"fenwick_tree_2D.cpp": {
	"prefix": "fenwick_tree_2D.cpp" ,
	"body": ["int ft[MAXN+1][MAXN+1];","void upd(int i0, int j0, int v){","	for(int i=i0+1;i<=MAXN;i+=i&-i)","	for(int j=j0+1;j<=MAXN;j+=j&-j)","		ft[i][j]+=v;","}","int get(int i0, int j0){","	int r=0;","	for(int i=i0;i;i-=i&-i)","	for(int j=j0;j;j-=j&-j)","		r+=ft[i][j];","	return r;","}","int get_sum(int i0, int j0, int i1, int j1){","	return get(i1,j1)-get(i1,j0)-get(i0,j1)+get(i0,j0);","}",]
},
"lazy_segtree.cpp": {
	"prefix": "lazy_segtree.cpp" ,
	"body": ["struct LazySegtree{","  #define mid (l + r) / 2","  #define left(u) (u + 1)","  #define right(u) (u + ((mid - l + 1) << 1))","  struct Node{","    lli s, lazy;","    Node(lli s = 0, lli lazy = 0): s(s), lazy(lazy) {}","    Node operator + (const Node &n){","      return Node(s + n.s);","    }","  };","  vector<Node> st;","  LazySegtree(int n): st(2 * n) {}","  void push(int u, int l, int r){","    if(st[u].lazy){","      if(l < r){","        st[left(u)].lazy += st[u].lazy;","        st[right(u)].lazy += st[u].lazy;","      }","      st[u].s += st[u].lazy * (r - l + 1);","      st[u].lazy = 0;","    }","  }","  void update(int u, int l, int r, int ll, int rr, lli val){ // O(logN)","    push(u, l, r);","    if(l > r or r < ll or l > rr) return;","    if(ll <= l and r <= rr){","      st[u].lazy += val;","      push(u, l, r);","      return;","    }","    update(left(u), l, mid, ll, rr, val);","    update(right(u), mid + 1, r, ll, rr, val);","    st[u] = st[left(u)] + st[right(u)];","  }","  Node query(int u, int l, int r, int ll, int rr){ // O(logN)","    push(u, l, r);","    if(l > r or r < ll or l > rr) return Node();","    if(ll <= l and r <= rr) return st[u];","    return query(left(u), l, mid, ll, rr) + query(right(u), mid + 1, r, ll, rr);","  }","};",]
},
"sparse_lazy_segtree.cpp": {
	"prefix": "sparse_lazy_segtree.cpp" ,
	"body": ["#define mid l + (r - l) / 2","struct Node{","  lli s, z;","  Node(lli s = 0, lli z = 0): s(s), z(z) {};","  Node operator + (const Node& n) {","    return Node(s + n.s);","  }","};","struct ST {","	Node data;","	lli l, r;","  // ST(Node data = Node()): data(data), l(0), r(0) {}","};","ST st[MAXN];","lli curst = 1; // 0 = NULL","lli newST(){","  st[curst].data = Node();","  st[curst].l = 0;","  st[curst].r = 0;","  return curst++;","}","Node data(lli u){return u ? st[u].data : Node();}","void pull(lli u){st[u].data = data(st[u].l) + data(st[u].r);}","void push(lli u, lli l, lli r){","  if(!st[u].l) st[u].l = newST();","  if(!st[u].r) st[u].r = newST();","  if(st[u].data.z){","    if(l < r){","      st[st[u].l].data.z += st[u].data.z;","      st[st[u].r].data.z += st[u].data.z;","    }","    st[u].data.s += (r - l + 1ll) * st[u].data.z;","    st[u].data.z = 0;","  }","}","void update(lli u, lli l, lli r, lli ll, lli rr, lli val){","  push(u, l, r);","  if(l > r or r < ll or l > rr or ll > rr) return;","  if(ll <= l and r <= rr){","    st[u].data.z += val;","    push(u, l, r);","    return;","  }","  update(st[u].l, l, mid, ll, rr, val);","  update(st[u].r, mid + 1, r, ll, rr, val);","  pull(u);","}","Node query(lli u, lli l, lli r, lli ll, lli rr){","  push(u, l, r);","  if(!u or l > r or r < ll or l > rr) return Node();","  if(ll <= l and r <= rr) return st[u].data;","  return query(st[u].l, l, mid, ll, rr) + query(st[u].r, mid + 1, r, ll, rr);","}",]
},
"disjoint_set.cpp": {
	"prefix": "disjoint_set.cpp" ,
	"body": ["struct DSU{","  vector<int> pr, rank;","  stack<pair<int,int>> what;","  DSU(int n): pr(n), rank(n, 1){ // O(N)","    iota(all(pr), 0);","  }","  int find(int u){ // O(1)","    return pr[u] == u ? u: pr[u] = find(pr[u]);","  }","  void unite(int u, int v){ // O(1)","    u = find(u), v = find(v);","    if(u != v){","      if(rank[u] < rank[v]) swap(u, v);","      rank[u] += rank[v];","      pr[v] = u;","      what.push({u, v});","    }else what.push({-1, -1});","  }","  pair<int,int> rollback(){ // O(1)","    pair<int,int> last = what.top();","    what.pop();","    int u = last.f, v = last.s;","    if(u != -1){","      rank[u] -= rank[v];","      pr[v] = v;","    }","    return last;","  }","};",]
},
"gain_cost_set.cpp": {
	"prefix": "gain_cost_set.cpp" ,
	"body": ["// stores pairs (benefit,cost) (erases non-optimal pairs)","struct GCS {","	set<pair<int,int> > s;","	void add(int g, int c){","		pair<int,int> x={g,c};","		auto p=s.lower_bound(x);","		if(p!=s.end()&&p->s<=x.s)return;","		if(p!=s.begin()){ // erase pairs with less benefit","			--p;            // and more cost","			while(p->s>=x.s){","				if(p==s.begin()){s.erase(p);break;}","				s.erase(p--);","			}","		}","		s.insert(x);","	}","	int get(int gain){ // min cost for some benefit","		auto p=s.lower_bound((pair<int,int>){gain,-INF});","		int r=p==s.end()?INF:p->s;","		return r;","	}","};",]
},
"link_cut_tree_crystal.cpp": {
	"prefix": "link_cut_tree_crystal.cpp" ,
	"body": ["struct SplayTree {","  struct Node {","    int ch[2] = {0, 0}, p = 0;","    long long self = 0, path = 0;        // Path aggregates","    long long sub = 0, vir = 0;          // Subtree aggregates","    bool flip = 0;                       // Lazy tags","  };","  vector<Node> T;","","  SplayTree(int n) : T(n + 1) {}","","  void push(int x) {","    if (!x || !T[x].flip) return;","    int l = T[x].ch[0], r = T[x].ch[1];","","    T[l].flip ^= 1, T[r].flip ^= 1;","    swap(T[x].ch[0], T[x].ch[1]);","    T[x].flip = 0;","  }","","  void pull(int x) {","    int l = T[x].ch[0], r = T[x].ch[1]; push(l); push(r);","","    T[x].path = T[l].path + T[x].self + T[r].path;","    T[x].sub = T[x].vir + T[l].sub + T[r].sub + T[x].self;","  }","","  void set(int x, int d, int y) {","    T[x].ch[d] = y; T[y].p = x; pull(x);","  }","","  void splay(int x) {","    auto dir = [&](int x) {","      int p = T[x].p; if (!p) return -1;","      return T[p].ch[0] == x ? 0 : T[p].ch[1] == x ? 1 : -1;","    };","    auto rotate = [&](int x) {","      int y = T[x].p, z = T[y].p, dx = dir(x), dy = dir(y);","      set(y, dx, T[x].ch[!dx]);","      set(x, !dx, y);","      if (~dy) set(z, dy, x);","      T[x].p = z;","    };","    for (push(x); ~dir(x); ) {","      int y = T[x].p, z = T[y].p;","      push(z); push(y); push(x);","      int dx = dir(x), dy = dir(y);","      if (~dy) rotate(dx != dy ? x : y);","      rotate(x);","    }","  }","};","","struct LinkCut : SplayTree {","  LinkCut(int n) : SplayTree(n) {}","","  int access(int x) {","    int u = x, v = 0;","    for (; u; v = u, u = T[u].p) {","      splay(u);","      int& ov = T[u].ch[1];","      T[u].vir += T[ov].sub;","      T[u].vir -= T[v].sub;","      ov = v; pull(u);","    }","    return splay(x), v;","  }","","  void reroot(int x) {","    access(x); T[x].flip ^= 1; push(x);","  }","","  void Link(int u, int v) {","    reroot(u); access(v);","    T[v].vir += T[u].sub;","    T[u].p = v; pull(v);","  }","","  void Cut(int u, int v) {","    reroot(u); access(v);","    T[v].ch[0] = T[u].p = 0; pull(v);","  }","","  // Rooted tree LCA. Returns 0 if u and v arent connected.","  int LCA(int u, int v) {","    if (u == v) return u;","    access(u); int ret = access(v);","    return T[u].p ? ret : 0;","  }","","  // Query subtree of u where v is outside the subtree.","  long long Subtree(int u, int v) {","    reroot(v); access(u); return T[u].vir + T[u].self;","  }","","  // Query path [u..v]","  long long Path(int u, int v) {","    reroot(u); access(v); return T[v].path;","  }","","  // Update vertex u with value v","  void Update(int u, long long v) {","    access(u); T[u].self = v; pull(u);","  }","};",]
},
"convexhull_trick_dynamic.cpp": {
	"prefix": "convexhull_trick_dynamic.cpp" ,
	"body": ["typedef lli tc;","const tc is_query=-(1LL<<62); // special value for query","struct Line {","	tc m,b;","	mutable multiset<Line>::iterator it,end;","	const Line* succ(multiset<Line>::iterator it) const {","		return (++it==end? NULL : &*it);}","	bool operator<(const Line& rhs) const {","		if(rhs.b!=is_query)return m<rhs.m;","		const Line *s=succ(it);","		if(!s)return 0;","		return b-s->b<(s->m-m)*rhs.m;","	}","};","struct HullDynamic : public multiset<Line> { // for maximum","	bool bad(iterator y){","		iterator z=next(y);","		if(y==begin()){","			if(z==end())return false;","			return y->m==z->m&&y->b<=z->b;","		}","		iterator x=prev(y);","		if(z==end())return y->m==x->m&&y->b<=x->b;","		return (x->b-y->b)*(z->m-y->m)>=(y->b-z->b)*(y->m-x->m);","	}","	iterator next(iterator y){return ++y;}","	iterator prev(iterator y){return --y;}","	void add(tc m, tc b){","		iterator y=insert((Line){m,b});","		y->it=y;y->end=end();","		if(bad(y)){erase(y);return;}","		while(next(y)!=end()&&bad(next(y)))erase(next(y));","		while(y!=begin()&&bad(prev(y)))erase(prev(y));","	}","	tc eval(tc x){","		Line l=*lower_bound((Line){x,is_query});","		return l.m*x+l.b;","	}","};",]
},
"minmax_queue.cpp": {
	"prefix": "minmax_queue.cpp" ,
	"body": ["struct qiu{","	stack<ii> s1,s2;","	int query(){","		int minimum;","		if (s1.empty() || s2.empty()) minimum = s1.empty() ? s2.top().second : s1.top().second;","		else minimum = min(s1.top().second, s2.top().second);","		return minimum;","	}","","	void pop(){","		if (s2.empty())while (!s1.empty()) {","        int element = s1.top().first;","        s1.pop();","        int minimum = s2.empty() ? element : min(element, s2.top().second);","        s2.push({element, minimum});","    	}","		int remove_element = s2.top().first;","		s2.pop();","	}","","	void add(int new_element){","		int minimum = s1.empty() ? new_element : min(new_element, s1.top().second);","		s1.push({new_element, minimum});","	}","};","",]
},
"disjoint_intervals.cpp": {
	"prefix": "disjoint_intervals.cpp" ,
	"body": ["// stores disjoint intervals as [first, second)","struct disjoint_intervals {","	set<pair<int,int> > s;","	void insert(pair<int,int> v){","		if(v.f>=v.s) return;","		auto at=s.lower_bound(v);auto it=at;","		if(at!=s.begin()&&(--at)->s>=v.f)v.f=at->f,--it;","		for(;it!=s.end()&&it->f<=v.s;s.erase(it++))","			v.s=max(v.s,it->s);","		s.insert(v);","	}","};",]
},
"segtree2d.cpp": {
	"prefix": "segtree2d.cpp" ,
	"body": ["const lli INF = 1E18;","struct Segtree{","  #define midx (lx + rx) / 2","  #define midy (ly + ry) / 2","  #define leftx(u) (u + 1)","  #define lefty(u) (u + 1)","  #define rightx(u) (u + ((midx - lx + 1) << 1))","  #define righty(u) (u + ((midy - ly + 1) << 1))","  struct Node{","    lli s, mx;","    Node(lli s = 0, lli mx = -INF): s(s), mx(mx) {}","    Node operator + (const Node& n){","      return Node(s + n.s, max(mx, n.mx));","    }","  };","  vector<vector<Node>> st;","  int n;","  Segtree(int n): n(n), st(2 * n, vector<Node>(2*n)) {}","  void updatey(int ux, int lx, int rx, int uy, int ly, int ry, int x, int y, lli val){","    if(ly == ry){","      if(lx == rx){","        st[ux][uy].s = val;","        st[ux][uy].mx = val;","        return;","      }","      st[ux][uy] = st[leftx(ux)][uy] + st[rightx(ux)][uy];","      return;","    }","    if(y <= midy) updatey(ux, lx, rx, lefty(uy), ly, midy, x, y, val);","    else updatey(ux, lx, rx, righty(uy), midy + 1, ry, x, y, val);","    st[ux][uy] = st[ux][lefty(uy)] + st[ux][righty(uy)];","  }","  void updatex(int ux, int lx, int rx, int x, int y, lli val){","    if(lx == rx){","      updatey(ux, lx, rx, 0, 0, n - 1, x, y, val);","      return;","    }","    if(x <= midx) updatex(leftx(ux), lx, midx, x, y, val);","    else updatex(rightx(ux), midx + 1, rx, x, y, val);","    updatey(ux, lx, rx, 0, 0, n - 1, x, y, val);","  }","  Node queryy(int ux, int uy, int ly, int ry, int lly, int rry){","    if(ly > ry or ry < lly or ly > rry) return Node();","    if(lly <= ly and ry <= rry) return st[ux][uy];","    return queryy(ux, lefty(uy), ly, midy, lly , rry) +","            queryy(ux, righty(uy), midy + 1, ry, lly, rry);","  }","  Node queryx(int ux, int lx, int rx, int llx, int rrx, int lly, int rry){","    if(lx > rx or rx < llx or lx > rrx) return Node();","    if(llx <= lx and rx <= rrx) return queryy(ux, 0, 0, n - 1, lly, rry);","    return queryx(leftx(ux), lx, midx, llx, rrx, lly, rry) +","            queryx(rightx(ux), midx + 1, rx, llx, rrx, lly, rry);","  }","  void printy(int ux, int uy, int ly, int ry){","    if(ly == ry){","      if(st[ux][uy].mx == -INF) cout << \"∆\" << ' ';","      else cout << st[ux][uy].mx << ' ';","      return;","    }","    printy(ux, lefty(uy), ly, midy);","    printy(ux, righty(uy), midy + 1, ry);","  }","  void printx(int ux, int lx, int rx){","    if(lx == rx){","      printy(ux, 0, 0, n - 1);","      cout << ENDL;","      return;","    }","    printx(leftx(ux), lx, midx);","    printx(rightx(ux), midx + 1, rx);","  }","};",]
},
"fenwick_tree.cpp": {
	"prefix": "fenwick_tree.cpp" ,
	"body": ["int ft[MAXN+1]; // for more dimensions, make ft multi-dimensional","void upd(int i0, int v){ // add v to i0th element (0-based)","	// add extra fors for more dimensions","	for(int i=i0+1;i<=MAXN;i+=i&-i)ft[i]+=v;","}","int get(int i0){ // get sum of range [0,i0)","	int r=0;","	// add extra fors for more dimensions","	for(int i=i0;i;i-=i&-i)r+=ft[i];","	return r;","}","int get_sum(int i0, int i1){ // get sum of range [i0,i1) (0-based)","	return get(i1)-get(i0);","}",]
},
"convexhull_trick.cpp": {
	"prefix": "convexhull_trick.cpp" ,
	"body": ["typedef lli tc;","struct Line{tc m,h;};","struct CHT { // for minimum (for maximum just change the sign of lines)","	vector<Line> c;","	int pos=0;","	tc in(Line a, Line b){","		tc x=b.h-a.h,y=a.m-b.m;","		return x/y+(x%y?!((x>0)^(y>0)):0); // ==ceil(x/y)","	}","	void add(tc m, tc h){ // m's should be non increasing","		Line l=(Line){m,h};","		if(c.size()&&m==c.back().m){","			l.h=min(h,c.back().h);c.pop_back();if(pos)pos--;","		}","		while(c.size()>1&&in(c.back(),l)<=in(c[c.size()-2],c.back())){","			c.pop_back();if(pos)pos--;","		}","		c.pb(l);","	}","	inline bool fbin(tc x, int m){return in(c[m],c[m+1])>x;}","	tc eval(tc x){","		// O(log n) query:","		int s=0,e=c.size();","		while(e-s>1){int m=(s+e)/2;","			if(fbin(x,m-1))e=m;","			else s=m;","		}","		return c[s].m*x+c[s].h;","		// O(1) query (for ordered x's):","		while(pos>0&&fbin(x,pos-1))pos--;","		while(pos<c.size()-1&&!fbin(x,pos))pos++;","		return c[pos].m*x+c[pos].h;","	}","};",]
},
"wavelet_tree.cpp": {
	"prefix": "wavelet_tree.cpp" ,
	"body": ["struct WT {","	vector<int> wt[1<<20];int n;","	void init(int k, int s, int e){","		if(s+1==e)return;","		wt[k].clear();wt[k].pb(0);","		int m=(s+e)/2;","		init(2*k,s,m);init(2*k+1,m,e);","	}","	void add(int k, int s, int e, int v){","		if(s+1==e)return;","		int m=(s+e)/2;","		if(v<m)wt[k].pb(wt[k].back()),add(2*k,s,m,v);","		else wt[k].pb(wt[k].back()+1),add(2*k+1,m,e,v);","	}","	int query0(int k, int s, int e, int a, int b, int i){","		if(s+1==e)return s;","		int m=(s+e)/2;","		int q=(b-a)-(wt[k][b]-wt[k][a]);","		if(i<q)return query0(2*k,s,m,a-wt[k][a],b-wt[k][b],i);","		else return query0(2*k+1,m,e,wt[k][a],wt[k][b],i-q);","	}","	void upd(int k, int s, int e, int i){","		if(s+1==e)return;","		int m=(s+e)/2;","		int v0=wt[k][i+1]-wt[k][i],v1=wt[k][i+2]-wt[k][i+1];","		if(!v0&&!v1)upd(2*k,s,m,i-wt[k][i]);","		else if(v0&&v1)upd(2*k+1,m,e,wt[k][i]);","		else if(v0)wt[k][i+1]--;","		else wt[k][i+1]++;","	}","	void init(int _n){n=_n;init(1,0,n);} // (values in range [0,n))","	void add(int v){add(1,0,n,v);}","	int query0(int a, int b, int i){ // ith element in range [a,b)","		return query0(1,0,n,a,b,i);    // (if it was sorted)","	}","	void upd(int i){ // swap positions i,i+1","		upd(1,0,n,i);","	}","};",]
},
"linkcut2.cpp": {
	"prefix": "linkcut2.cpp" ,
	"body": ["const int N_DEL = 0, N_VAL = 0; //delta, value","inline int mOp(int x, int y){return x+y;}//modify","inline int qOp(int lval, int rval){return lval + rval;}//query","inline int dOnSeg(int d, int len){return d==N_DEL ? N_DEL : d*len;}","//mostly generic","inline int joinD(int d1, int d2){","  if(d1==N_DEL)return d2;if(d2==N_DEL)return d1;return mOp(d1, d2);}","inline int joinVD(int v, int d){return d==N_DEL ? v : mOp(v, d);}","struct Node_t{","  int cnt, nVal, tVal, d;","  bool rev;","  Node_t *c[2], *p;","  Node_t(int v) : cnt(1), nVal(v), tVal(v), d(N_DEL), rev(0), p(0){","    c[0]=c[1]=0;","  }","  bool isRoot(){return !p || (p->c[0] != this && p->c[1] != this);}","  void push(){","    if(rev){","      rev=0; swap(c[0], c[1]);","      fore(x,0,2)if(c[x])c[x]->rev^=1;","    }","    nVal=joinVD(nVal, d); tVal=joinVD(tVal, dOnSeg(d, cnt));","    fore(x,0,2)if(c[x])c[x]->d=joinD(c[x]->d, d);","    d=N_DEL;","  }","  void upd();","};","typedef Node_t* Node;","int getSize(Node r){return r ? r->cnt : 0;}","int getPV(Node r){","  return r ? joinVD(r->tVal, dOnSeg(r->d,r->cnt)) : N_VAL;}","void Node_t::upd(){","  tVal = qOp(qOp(getPV(c[0]), joinVD(nVal, d)), getPV(c[1]));","  cnt = 1 + getSize(c[0]) + getSize(c[1]);","}","void conn(Node c, Node p, int il){if(c)c->p=p;if(il>=0)p->c[!il]=c;}","void rotate(Node x){","  Node p = x->p, g = p->p;","  bool gCh=p->isRoot(), isl = x==p->c[0];","  conn(x->c[isl],p,isl); conn(p,x,!isl);","  conn(x,g,gCh?-1:(p==g->c[0])); p->upd();","}","void spa(Node x){//splay","  while(!x->isRoot()){","    Node p = x->p, g = p->p;","    if(!p->isRoot())g->push();","    p->push(); x->push();","    if(!p->isRoot())rotate((x==p->c[0])==(p==g->c[0])? p : x);","    rotate(x);","  }","  x->push(); x->upd();","}","Node exv(Node x){//expose","  Node last=0;","  for(Node y=x; y; y=y->p)spa(y),y->c[0]=last,y->upd(),last=y;","  spa(x);","  return last;","}","void mkR(Node x){exv(x);x->rev^=1;}//makeRoot","Node getR(Node x){exv(x);while(x->c[1])x=x->c[1];spa(x);return x;}","Node lca(Node x, Node y){exv(x); return exv(y);}","bool connected(Node x, Node y){exv(x);exv(y); return x==y?1:x->p!=0;}","void link(Node x, Node y){mkR(x); x->p=y;}","void cut(Node x, Node y){mkR(x); exv(y); y->c[1]->p=0; y->c[1]=0;}","Node father(Node x){","	exv(x);","	Node r=x->c[1];","	if(!r)return 0;","	while(r->c[0])r=r->c[0];","	return r;","}","void cut(Node x){ // cuts x from father keeping tree root","	exv(father(x));x->p=0;}","int query(Node x, Node y){mkR(x); exv(y); return getPV(y);}","void modify(Node x, Node y, int d){mkR(x);exv(y);y->d=joinD(y->d,d);}","Node lift_rec(Node x, int t){","	if(!x)return 0;","	if(t==getSize(x->c[0])){spa(x);return x;}","	if(t<getSize(x->c[0]))return lift_rec(x->c[0],t);","	return lift_rec(x->c[1],t-getSize(x->c[0])-1);","}","Node lift(Node x, int t){ // t-th ancestor of x (lift(x,1) is x's father)","	exv(x);return lift_rec(x,t);}","int depth(Node x){ // distance from x to its tree root","	exv(x);return getSize(x)-1;}",]
},
"stl_rope.cpp": {
	"prefix": "stl_rope.cpp" ,
	"body": ["#include <ext/rope>","using namespace __gnu_cxx;","rope<int> s;","// Sequence with O(log(n)) random access, insert, erase at any position","// s.push_back(x);","// s.insert(i,r) // insert rope r at position i","// s.erase(i,k) // erase subsequence [i,i+k)","// s.substr(i,k) // return new rope corresponding to subsequence [i,i+k)","// s[i] // access ith element (cannot modify)","// s.mutable_reference_at(i) // acces ith element (allows modification)","// s.begin() and s.end() are const iterators (use mutable_begin(), mutable_end() to allow modification)",]
},
"treap.cpp": {
	"prefix": "treap.cpp" ,
	"body": ["typedef struct item *pitem;","struct item {","	int pr,key,cnt;","	pitem l,r;","	item(int key):key(key),pr(rand()),cnt(1),l(0),r(0) {}","};","int cnt(pitem t){return t?t->cnt:0;}","void upd_cnt(pitem t){if(t)t->cnt=cnt(t->l)+cnt(t->r)+1;}","void split(pitem t, int key, pitem& l, pitem& r){ // l: < key, r: >= key","	if(!t)l=r=0;","	else if(key<t->key)split(t->l,key,l,t->l),r=t;","	else split(t->r,key,t->r,r),l=t;","	upd_cnt(t);","}","void insert(pitem& t, pitem it){","	if(!t)t=it;","	else if(it->pr>t->pr)split(t,it->key,it->l,it->r),t=it;","	else insert(it->key<t->key?t->l:t->r,it);","	upd_cnt(t);","}","void merge(pitem& t, pitem l, pitem r){","	if(!l||!r)t=l?l:r;","	else if(l->pr>r->pr)merge(l->r,l->r,r),t=l;","	else merge(r->l,l,r->l),t=r;","	upd_cnt(t);","}","void erase(pitem& t, int key){","	if(t->key==key)merge(t,t->l,t->r);","	else erase(key<t->key?t->l:t->r,key);","	upd_cnt(t);","}","void unite(pitem &t, pitem l, pitem r){","	if(!l||!r){t=l?l:r;return;}","	if(l->pr<r->pr)swap(l,r);","	pitem p1,p2;split(r,l->key,p1,p2);","	unite(l->l,l->l,p1);unite(l->r,l->r,p2);","	t=l;upd_cnt(t);","}","pitem kth(pitem t, int k){","	if(!t)return 0;","	if(k==cnt(t->l))return t;","	return k<cnt(t->l)?kth(t->l,k):kth(t->r,k-cnt(t->l)-1);","}","pair<int,int> lb(pitem t, int key){ // position and value of lower_bound","	if(!t)return {0,1<<30}; // (special value)","	if(key>t->key){","		auto w=lb(t->r,key);w.f+=cnt(t->l)+1;return w;","	}","	auto w=lb(t->l,key);","	if(w.f==cnt(t->l))w.s=t->key;","	return w;","}",]
},
"link_cut_tree.cpp": {
	"prefix": "link_cut_tree.cpp" ,
	"body": ["typedef struct item *pitem;","struct item {","	int pr;bool rev;","	pitem l,r,f,d;","	item():pr(rand()),l(0),r(0),f(0),d(0),rev(0){}","};","void push(pitem t){","	if(t&&t->rev){","		swap(t->l,t->r);","		if(t->l)t->l->rev^=1;","		if(t->r)t->r->rev^=1;","		t->rev=0;","	}","}","void merge(pitem& t, pitem l, pitem r){","	push(l);push(r);","	if(!l||!r)t=l?l:r;","	else if(l->pr>r->pr)merge(l->r,l->r,r),l->r->f=t=l;","	else merge(r->l,l,r->l),r->l->f=t=r;","}","void push_all(pitem t){","	if(t->f)push_all(t->f);","	push(t);","}","void split(pitem t, pitem& l, pitem& r){","	push_all(t);","	l=t->l;r=t->r;t->l=t->r=0;","	while(t->f){","		pitem f=t->f;t->f=0;","		if(t==f->l){","			if(r)r->f=f;","			f->l=r;r=f;","		}","		else {","			if(l)l->f=f;","			f->r=l;l=f;","		}","		t=f;","	}","	if(l)l->f=0;","	if(r)r->f=0;","}","pitem path(pitem p){return p->f?path(p->f):p;}","pitem tail(pitem p){push(p);return p->r?tail(p->r):p;}","pitem expose(pitem p){","	pitem q,r,t;","	split(p,q,r);","	if(q)tail(q)->d=p;","	merge(p,p,r);","	while(t=tail(p),t->d){","		pitem d=t->d;t->d=0;","		split(d,q,r);","		if(q)tail(q)->d=d;","		merge(p,p,d);merge(p,p,r);","	}","	return p;","}","pitem root(pitem v){return tail(expose(v));}","void evert(pitem v){expose(v)->rev^=1;v->d=0;}","void link(pitem v, pitem w){ // make v son of w","	evert(v);","	pitem p=path(v);","	merge(p,p,expose(w));","}","void cut(pitem v){ // cut v from its father","	pitem p,q;","	expose(v);split(v,p,q);v->d=0;","}","void cut(pitem v, pitem w){evert(w);cut(v);}",]
},
"stl_extended_set.cpp": {
	"prefix": "stl_extended_set.cpp" ,
	"body": ["#include<ext/pb_ds/assoc_container.hpp>","#include<ext/pb_ds/tree_policy.hpp>","using namespace __gnu_pbds;","typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;","// find_by_order(i) -> iterator to ith element","// order_of_key(k) -> position (int) of lower_bound of k",]
},
"sparse_segtree.cpp": {
	"prefix": "sparse_segtree.cpp" ,
	"body": ["#define mid l + (r - l) / 2","struct Node{","  lli s, mx;","  Node(lli s = 0, lli mx = 0): s(s), mx(mx) {};","  Node operator + (const Node& n) {","    return Node(s + n.s, max(mx, n.mx));","  }","};","struct ST {","	Node data;","	lli l, r;","  // ST(Node data = Node()): data(data), l(0), r(0) {}","};","ST st[MAXN];","lli curst = 1; // 0 = NULL","lli newST(){","  st[curst].data = Node();","  st[curst].l = 0;","  st[curst].r = 0;","  return curst++;","}","Node data(lli u){return u ? st[u].data : Node();}","void pull(lli u){st[u].data = data(st[u].l) + data(st[u].r);}","void update(lli u, lli l, lli r, lli kth, Node val){","  if(l == r){","    st[u].data = val;","    return;","  }","  if(kth <= mid){","    if(!st[u].l) st[u].l = newST();","    update(st[u].l, l, mid, kth, val);","  }","  else {","    if(!st[u].r) st[u].r = newST();","    update(st[u].r, mid + 1, r, kth, val);","  }","  pull(u);","}","Node query(lli u, lli l, lli r, lli ll, lli rr){","  if(!u or l > r or r < ll or l > rr) return Node();","  if(ll <= l and r <= rr) return st[u].data;","  return query(st[u].l, l, mid, ll, rr) + query(st[u].r, mid + 1, r, ll, rr);","}",]
},
"sqrt_descomposition.cpp": {
	"prefix": "sqrt_descomposition.cpp" ,
	"body": ["const int N = 1e5 + 5;","lli sq[320];","int a[N], who[N];","int block; // sqrt(N)","int n;","","template <class T>","T query(int l, int r){ // O(sqrtN)","  T ans = {};","  while( l <= r ){","    if( l % block == 0 && l + block - 1 <= r ){","      ans += sq[who[l]];","      l += block;","    }else{","      ans += a[l++];","    }","  }","  return ans;","}","","void do_sqrt_descomposition(){ // O(N)","  block = sqrt(n);","  Forn(i, n){","    who[i] = i / block;","    sq[who[i]] += a[i];","  }","}",]
},
"segtree.cpp": {
	"prefix": "segtree.cpp" ,
	"body": ["struct Segtree{","  #define mid (l + r) / 2","  #define left(u) (u + 1)","  #define right(u) (u + ((mid - l + 1) << 1))","  struct Node{","    lli s, mx;","    Node(lli s = 0, lli mx = -1): s(s), mx(mx) {}","    Node operator + (const Node &n){","      return Node(s + n.s, max(mx, n.mx));","    }","  };","  vector<Node> st;","  Segtree(int n): st(2 * n) {}","  void update(int u, int l, int r, int kth, lli val){ // O(logN)","    if(l == r){","      st[u].s = val;","      st[u].mx = val;","      return;","    }","    if(kth <= mid) update(left(u), l, mid, kth, val);","    else update(right(u), mid + 1, r, kth, val);","    st[u] = st[left(u)] + st[right(u)];","  }","  Node query(int u, int l, int r, int ll, int rr){ // O(logN)","    if(l > r or r < ll or l > rr) return Node();","    if(ll <= l and r <= rr) return st[u];","    return query(left(u), l, mid, ll, rr) + query(right(u), mid + 1, r, ll, rr);","  }","};",]
},
"lcp.cpp": {
	"prefix": "lcp.cpp" ,
	"body": ["vector<int> computeLCP(string& s, vector<int>& sa){","	int n=(int)s.size(),L=0;","	vector<int> lcp(n),plcp(n),phi(n);","	phi[sa[0]]=-1;","	for(int i = 1; i < n; ++i) phi[sa[i]]=sa[i-1];","	for(int i = 0; i < n; ++i){","		if(phi[i]<0){plcp[i]=0;continue;}","		while(s[i+L]==s[phi[i]+L])L++;","		plcp[i]=L;","		L=max(L-1,0);","	}","	for(int i = 0; i < n; ++i) lcp[i]=plcp[sa[i]];","	return lcp; // lcp[i]=LCP(sa[i-1],sa[i])","}",]
},
"manacher.cpp": {
	"prefix": "manacher.cpp" ,
	"body": ["const int MAXN = 1e6;","int d1[MAXN];//d1[i] = max odd palindrome centered on i","int d2[MAXN];//d2[i] = max even palindrome centered on i","//s  aabbaacaabbaa","//d1 1111117111111","//d2 0103010010301","void manacher(string& s){","	int l=0,r=-1,n=s.size();","	for(int i = 0; i < n; ++i){","		int k=i>r?1:min(d1[l+r-i],r-i);","		while(i+k<n&&i-k>=0&&s[i+k]==s[i-k])k++;","		d1[i]=k--;","		if(i+k>r)l=i-k,r=i+k;","	}","	l=0;r=-1;","	for(int i = 0; i < n; ++i){","		int k=i>r?0:min(d2[l+r-i+1],r-i+1);k++;","		while(i+k<=n&&i-k>=0&&s[i+k-1]==s[i-k])k++;","		d2[i]=--k;","		if(i+k-1>r)l=i-k,r=i+k-1;","	}","}",]
},
"hash_128.cpp": {
	"prefix": "hash_128.cpp" ,
	"body": ["#define bint __int128","struct Hash {","	bint MOD=212345678987654321LL,P=1777771,PI=106955741089659571LL;","	vector<bint> h,pi;","	Hash(string& s){","		assert((P*PI)%MOD==1);","		h.resize(s.size()+1);pi.resize(s.size()+1);","		h[0]=0;pi[0]=1;","		bint p=1;","		for(int i = 1; i < (int)(s.size()) + 1; ++i){","			h[i]=(h[i-1]+p*s[i-1])%MOD;","			pi[i]=(pi[i-1]*PI)%MOD;","			p=(p*P)%MOD;","		}","	}","	long long get(int s, int e){","		return (((h[e]-h[s]+MOD)%MOD)*pi[s])%MOD;","	}","};",]
},
"suffix_automaton.cpp": {
	"prefix": "suffix_automaton.cpp" ,
	"body": ["struct state {int len,link;map<char,int> next;}; //clear next!!","state st[100005];","int sz,last;","void sa_init(){","	last=st[0].len=0;sz=1;","	st[0].link=-1;","}","void sa_extend(char c){","	int k=sz++,p;","	st[k].len=st[last].len+1;","	for(p=last;p!=-1&&!st[p].next.count(c);p=st[p].link)st[p].next[c]=k;","	if(p==-1)st[k].link=0;","	else {","		int q=st[p].next[c];","		if(st[p].len+1==st[q].len)st[k].link=q;","		else {","			int w=sz++;","			st[w].len=st[p].len+1;","			st[w].next=st[q].next;st[w].link=st[q].link;","			for(;p!=-1&&st[p].next[c]==q;p=st[p].link)st[p].next[c]=w;","			st[q].link=st[k].link=w;","		}","	}","	last=k;","}",]
},
"aho_corasick.cpp": {
	"prefix": "aho_corasick.cpp" ,
	"body": ["struct vertex {","	map<char,int> next,go;","	int p,link;","	char pch;","	vector<int> leaf;","	vertex(int p=-1, char pch=-1):p(p),pch(pch),link(-1){}","};","vector<vertex> t;","void aho_init(){ //do not forget!!","	t.clear();t.push_back(vertex());","}","void add_string(string s, int id){","	int v=0;","	for(char c:s){","		if(!t[v].next.count(c)){","			t[v].next[c]=t.size();","			t.push_back(vertex(v,c));","		}","		v=t[v].next[c];","	}","	t[v].leaf.push_back(id);","}","int go(int v, char c);","int get_link(int v){","	if(t[v].link<0)","		if(!v||!t[v].p)t[v].link=0;","		else t[v].link=go(get_link(t[v].p),t[v].pch);","	return t[v].link;","}","int go(int v, char c){","	if(!t[v].go.count(c))","		if(t[v].next.count(c))t[v].go[c]=t[v].next[c];","		else t[v].go[c]=v==0?0:go(get_link(v),c);","	return t[v].go[c];","}",]
},
"suffix_array_slow.cpp": {
	"prefix": "suffix_array_slow.cpp" ,
	"body": ["const int MAXN = 1;","pair<int, int> sf[MAXN];","bool sacomp(int lhs, int rhs) {return sf[lhs]<sf[rhs];}","vector<int> constructSA(string& s){ // O(n log^2(n))","	int n=s.size();                   // (sometimes fast enough)","	vector<int> sa(n),r(n);","	for(int i = 0; i < n; ++i) r[i]=s[i];","	for(int m=1;m<n;m*=2){","		for(int i = 0; i < n; ++i) sa[i]=i,sf[i]={r[i],i+m<n?r[i+m]:-1};","		stable_sort(sa.begin(),sa.end(),sacomp);","		r[sa[0]]=0;","		for(int i = 1; i < n; ++i) r[sa[i]]=sf[sa[i]]!=sf[sa[i-1]]?i:r[sa[i-1]];","	}","	return sa;","}",]
},
"suffix_tree.cpp": {
	"prefix": "suffix_tree.cpp" ,
	"body": ["const int MAXN = 1e5;","int INF = 1e9;","struct SuffixTree {","	char s[MAXN];","	map<int,int> to[MAXN];","	int len[MAXN]={INF},fpos[MAXN],link[MAXN];","	int node,pos,sz=1,n=0;","	int make_node(int p, int l){","		fpos[sz]=p;len[sz]=l;return sz++;}","	void go_edge(){","		while(pos>len[to[node][s[n-pos]]]){","			node=to[node][s[n-pos]];","			pos-=len[node];","		}","	}","	void add(int c){","		s[n++]=c;pos++;","		int last=0;","		while(pos>0){","			go_edge();","			int edge=s[n-pos];","			int& v=to[node][edge];","			int t=s[fpos[v]+pos-1];","			if(v==0){","				v=make_node(n-pos,INF);","				link[last]=node;last=0;","			}","			else if(t==c){link[last]=node;return;}","			else {","				int u=make_node(fpos[v],pos-1);","				to[u][c]=make_node(n-1,INF);","				to[u][t]=v;","				fpos[v]+=pos-1;len[v]-=pos-1;","				v=u;link[last]=u;last=u;","			}","			if(node==0)pos--;","			else node=link[node];","		}","	}","};",]
},
"kmp.cpp": {
	"prefix": "kmp.cpp" ,
	"body": ["vector<int> kmppre(string& t){ // r[i]: longest border of t[0,i)","	vector<int> r(t.size()+1);r[0]=-1;","	int j=-1;","	for(int i = 0; i < (int)(t.size()); ++i){","		while(j>=0&&t[i]!=t[j])j=r[j];","		r[i+1]=++j;","	}","	return r;","}","void kmp(string& s, string& t){ // find t in s","	int j=0;vector<int> b=kmppre(t);","	for(int i = 0; i < (int)(s.size()); ++i){","		while(j>=0&&s[i]!=t[j])j=b[j];","		if(++j==(int)t.size())printf(\"Match at %d\n\",i-j+1),j=b[j];","	}","}",]
},
"hash.cpp": {
	"prefix": "hash.cpp" ,
	"body": ["struct Hash {","	int P=1777771,MOD[2],PI[2];","	vector<int> h[2],pi[2];","	Hash(string& s){","		MOD[0]=999727999;MOD[1]=1070777777;","		PI[0]=325255434;PI[1]=10018302;","		for(int k = 0; k < 2; ++k)h[k].resize(s.size()+1),pi[k].resize(s.size()+1);","		for(int k = 0; k < 2; ++k){","			h[k][0]=0;pi[k][0]=1;","			long long p=1;","			for(int i = 1; i < (int)(s.size()) + 1; ++i){","				h[k][i]=(h[k][i-1]+p*s[i-1])%MOD[k];","				pi[k][i]=(1LL*pi[k][i-1]*PI[k])%MOD[k];","				p=(p*P)%MOD[k];","			}","		}","	}","	long long get(int s, int e){","		long long h0=(h[0][e]-h[0][s]+MOD[0])%MOD[0];","		h0=(1LL*h0*pi[0][s])%MOD[0];","		long long h1=(h[1][e]-h[1][s]+MOD[1])%MOD[1];","		h1=(1LL*h1*pi[1][s])%MOD[1];","		return (h0<<32)|h1;","	}","};",]
},
"palindromic_tree.cpp": {
	"prefix": "palindromic_tree.cpp" ,
	"body": ["struct palindromic_tree{","    static const int SIGMA=26;","    struct Node{","        int len, link, to[SIGMA];","        long long cnt;","        Node(int len, int link=0, long long cnt=1):len(len),link(link),cnt(cnt){","            memset(to,0,sizeof(to));","        }","    };","    vector<Node> ns;","    int last;","    palindromic_tree():last(0){ns.push_back(Node(-1));ns.push_back(Node(0));}","    void add(int i, string &s){","        int p=last, c=s[i]-'a';","        while(s[i-ns[p].len-1]!=s[i])p=ns[p].link;","        if(ns[p].to[c]){","            last=ns[p].to[c];","            ns[last].cnt++;","        }else{","            int q=ns[p].link;","            while(s[i-ns[q].len-1]!=s[i])q=ns[q].link;","            q=max(1,ns[q].to[c]);","            last=ns[p].to[c]=(int)(ns.size());","            ns.push_back(Node(ns[p].len+2,q,1));","        }","    }","};",]
},
"z_function.cpp": {
	"prefix": "z_function.cpp" ,
	"body": ["vector<int> z_function(string& s){","	int l=0,r=0,n=s.size();","	vector<int> z(s.size(),0); // z[i] = max k: s[0,k) == s[i,i+k)","	for(int i = 1; i < n; ++i){","		if(i<=r)z[i]=min(r-i+1,z[i-l]);","		while(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;","		if(i+z[i]-1>r)l=i,r=i+z[i]-1;","	}","	return z;","}",]
},
"suffix_array.cpp": {
	"prefix": "suffix_array.cpp" ,
	"body": ["","#define RB(x) (x<n?r[x]:0)","void csort(vector<int>& sa, vector<int>& r, int k){","	int n=sa.size();","	vector<int> f(max(255,n),0),t(n);","	fore(i,0,n)f[RB(i+k)]++;","	int sum=0;","	fore(i,0,max(255,n))f[i]=(sum+=f[i])-f[i];","	fore(i,0,n)t[f[RB(sa[i]+k)]++]=sa[i];","	sa=t;","}","vector<int> constructSA(string& s){ // O(n logn)","	int n=s.size(),rank;","	vector<int> sa(n),r(n),t(n);","	fore(i,0,n)sa[i]=i,r[i]=s[i];","	for(int k=1;k<n;k*=2){","		csort(sa,r,k);csort(sa,r,0);","		t[sa[0]]=rank=0;","		fore(i,1,n){","			if(r[sa[i]]!=r[sa[i-1]]||RB(sa[i]+k)!=RB(sa[i-1]+k))rank++;","			t[sa[i]]=rank;","		}","		r=t;","		if(r[sa[n-1]]==n-1)break;","	}","	return sa;","}",]
},
"cpp_stuff.cpp": {
	"prefix": "cpp_stuff.cpp" ,
	"body": ["// double inf","const double DINF=numeric_limits<double>::infinity();","// Custom comparator for set/map","struct comp {","	bool operator()(const double& a, const double& b) const {","		return a+EPS<b;}","};","set<double,comp> w; // or map<double,int,comp>","// Iterate over non empty subsets of bitmask","for(int s=m;s;s=(s-1)&m) // Decreasing order","for (int s=0;s=s-m&m;) 	 // Increasing order","// Return the numbers the numbers of 1-bit in x","int __builtin_popcount (unsigned int x)","// Returns the number of trailing 0-bits in x. x=0 is undefined.","int __builtin_ctz (unsigned int x)","// Returns the number of leading 0-bits in x. x=0 is undefined.","int __builtin_clz (unsigned int x)","// x of type long long just add 'll' at the end of the function.","int __builtin_popcountll (unsigned long long x)","// Get the value of the least significant bit that is one.","v=(x&(-x))",]
},
"dates.cpp": {
	"prefix": "dates.cpp" ,
	"body": ["int dateToInt(int y, int m, int d){","	return 1461*(y+4800+(m-14)/12)/4+367*(m-2-(m-14)/12*12)/12-","		3*((y+4900+(m-14)/12)/100)/4+d-32075;","}","void intToDate(int jd, int& y, int& m, int& d){","	int x,n,i,j;x=jd+68569;","	n=4*x/146097;x-=(146097*n+3)/4;","	i=(4000*(x+1))/1461001;x-=1461*i/4-31;","	j=80*x/2447;d=x-2447*j/80;","	x=j/11;m=j+2-12*x;y=100*(n-49)+i+x;","}","int DayOfWeek(int d, int m, int y){	//starting on Sunday","	static int ttt[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};","	y-=m<3;","	return (y+y/4-y/100+y/400+ttt[m-1]+d)%7;","}",]
},
"cute_lis.cpp": {
	"prefix": "cute_lis.cpp" ,
	"body": ["//This assumes no duplicates in array.","set<lli> s; // multiset, for duplicate.","fore(i, 0, n){","  s.insert(a[i]);","  auto it = s.upper_bound(a[i]);","  if(it != s.end()) s.erase(it);","}","// Longest Strictly Increasing Subsequence.","multiset<lli> s;","fore(i, 0, n){","  s.insert(a[i]);","  auto it = s.lower_bound(a[i]);","  it++;","  if(it != s.end()) s.erase(it);","}","cout << s.size() << endl;",]
},
"matrix_chain_multiplication.cpp": {
	"prefix": "matrix_chain_multiplication.cpp" ,
	"body": ["lli calc(int l, int r){ // O(N ^ 3) // TODO: agregar version iterativa en O(N ^ 2)","  if( l >= r ){","    return 0ll;","  }","  lli &ans = dp[l][r];","  if( ans == -1 ){","    ans = inf;","    For(k, l, r, +1){","      ans = min(ans, calc(l, k) + calc(k + 1, r) + inc()));","    }","  }","  return ans;","}",]
},
"crt.cpp": {
	"prefix": "crt.cpp" ,
	"body": ["//Needs gcd","","pair<long long,long long> extendedEuclid (long long a, long long b){ //a * x + b * y = gcd(a,b)","	long long x,y;","	if (b==0) return {1,0};","	auto p=extendedEuclid(b,a%b);","	x=p.second;","	y=p.first-(a/b)*x;","	if(a*x+b*y==-gcd(a,b)) x=-x, y=-y;","	return {x,y};","}","pair<pair<long long,long long>,pair<long long,long long> > diophantine(long long a,long long b, long long r) {","	//a*x+b*y=r where r is multiple of gcd(a,b);","	long long d=gcd(a,b);","	a/=d; b/=d; r/=d;","	auto p = extendedEuclid(a,b);","	p.first*=r; p.second*=r;","	assert(a*p.first+b*p.second==r);","	return {p,{-b,a}}; // solutions: p+t*ans.snd","}","","long long inv(long long a, long long m) {","	assert(gcd(a,m)==1);","	long long x = diophantine(a,m,1).first.first;","	return ((x%m)+m)%m;","}","","#define mod(a,m) (((a)%m+m)%m)","pair<long long,long long> sol(tuple<long long,long long,long long> c){ //requires inv, diophantine","    long long a=get<0>(c), x1=get<1>(c), m=get<2>(c), d=gcd(a,m);","    if(d==1) return {mod(x1*inv(a,m),m), m};","    else return x1%d ? pair<long long, long long>({-1LL,-1LL}) : sol(make_tuple(a/d,x1/d,m/d));","}","pair<long long,long long> crt(vector< tuple<long long,long long,long long> > cond) { // returns: (sol, lcm)","	long long x1=0,m1=1,x2,m2;","	for(auto t:cond){","		tie(x2,m2)=sol(t);","		if((x1-x2)%gcd(m1,m2))return {-1,-1};","		if(m1==m2)continue;","		long long k=diophantine(m2,-m1,x1-x2).first.second,l=m1*(m2/gcd(m1,m2));","		x1=mod((__int128)m1*k+x1,l);m1=l;","	}","	return sol(make_tuple(1,x1,m1));","} //cond[i]={ai,bi,mi} ai*xi=bi (mi); assumes lcm fits in ll",]
},
"matrix_fast_pow.cpp": {
	"prefix": "matrix_fast_pow.cpp" ,
	"body": ["typedef vector<vector<long long> > Matrix;","long long mod = 1e9 + 7;","Matrix ones(int n) {","Matrix r(n,vector<long long>(n));","	for(int i = 0; i < n; ++i) r[i][i] = 1;","	return r;","}","Matrix operator*(Matrix &a, Matrix &b) {","	int n=(int)(a.size()),m=(int)(b[0].size()),z=(int)(a[0].size());","	Matrix r(n,vector<long long>(m));","	for(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) for(int k = 0; k < z; ++k)","		r[i][j]+=a[i][k]*b[k][j],r[i][j]%=mod;","	return r;","}","Matrix be(Matrix b, long long e) {","	Matrix r=ones((int)(b.size()));","	while(e){if(e&1LL)r=r*b;b=b*b;e/=2;}","	return r;","}",]
},
"simplex.cpp": {
	"prefix": "simplex.cpp" ,
	"body": ["vector<int> X,Y;","vector<vector<double> > A;","vector<double> b,c;","double z;","int n,m;","double EPS = 1e-6;","void pivot(int x,int y){","	swap(X[y],Y[x]);","	b[x]/=A[x][y];","	for(int i = 0; i < m; ++i)if(i!=y)A[x][i]/=A[x][y];","	A[x][y]=1/A[x][y];","	for(int i = 0; i < n; ++i)if(i!=x&&abs(A[i][y])>EPS){","		b[i]-=A[i][y]*b[x];","		for(int j = 0; j < m; ++j)if(j!=y)A[i][j]-=A[i][y]*A[x][j];","		A[i][y]=-A[i][y]*A[x][y];","	}","	z+=c[y]*b[x];","	for(int i = 0; i < m; ++i)if(i!=y)c[i]-=c[y]*A[x][i];","	c[y]=-c[y]*A[x][y];","}","pair<double,vector<double> > simplex( // maximize c^T x s.t. Ax<=b, x>=0","		vector<vector<double> > _A, vector<double> _b, vector<double> _c){","	// returns pair (maximum value, solution vector)","	A=_A;b=_b;c=_c;","	n=b.size();m=c.size();z=0.;","	X=vector<int>(m);Y=vector<int>(n);","	for(int i = 0; i < m; ++i) X[i]=i;","	for(int i = 0; i < n; ++i) Y[i]=i+m;","	while(1){","		int x=-1,y=-1;","		double mn=-EPS;","		for(int i = 0; i < n; ++i) if(b[i]<mn)mn=b[i],x=i;","		if(x<0)break;","		for(int i = 0; i < m; ++i) if(A[x][i]<-EPS){y=i;break;}","		assert(y>=0); // no solution to Ax<=b","		pivot(x,y);","	}","	while(1){","		double mx=EPS;","		int x=-1,y=-1;","		for(int i = 0; i < m; ++i) if(c[i]>mx)mx=c[i],y=i;","		if(y<0)break;","		double mn=1e200;","		for(int i = 0; i < n; ++i) if(A[i][y]>EPS&&b[i]/A[i][y]<mn)mn=b[i]/A[i][y],x=i;","		assert(x>=0); // c^T x is unbounded","		pivot(x,y);","	}","	vector<double> r(m);","	for(int i = 0; i < n; ++i) if(Y[i]<m)r[Y[i]]=b[i];","	return {z,r};","}",]
},
"matrix_reduce.cpp": {
	"prefix": "matrix_reduce.cpp" ,
	"body": ["double reduce(vector<vector<double> >& x){ // returns determinant","	int n=x.size(),m=x[0].size();","	int i=0,j=0;double r=1.;","	while(i<n&&j<m){","		int l=i;","		fore(k,i+1,n)if(abs(x[k][j])>abs(x[l][j]))l=k;","		if(abs(x[l][j])<EPS){j++;r=0.;continue;}","		if(l!=i){r=-r;swap(x[i],x[l]);}","		r*=x[i][j];","		for(int k=m-1;k>=j;k--)x[i][k]/=x[i][j];","		fore(k,0,n){","			if(k==i)continue;","			for(int l=m-1;l>=j;l--)x[k][l]-=x[k][j]*x[i][l];","		}","		i++;j++;","	}","	return r;","}",]
},
"linear_rec.cpp": {
	"prefix": "linear_rec.cpp" ,
	"body": ["//Needs MOD and LOG","struct LinearRec{","  typedef vector<int> vi;","  int n; vi terms, trans; vector<vi> bin;","  vi add(vi &a, vi &b){","    vi res(n*2+1);","    for(int i = 0; i < n + 1; ++i) for(int j = 0; j < n + 1; ++j) res[i+j]=(res[i+j]*1LL+(long long)a[i]*b[j])%MOD;","    for(int i=2*n; i>n; --i){","      for(int j = 0; j < n; ++j) res[i-1-j]=(res[i-1-j]*1LL+(long long)res[i]*trans[j])%MOD;","      res[i]=0;","    }","    res.erase(res.begin()+n+1,res.end());","    return res;","  }","  LinearRec(vi &terms, vi &trans):terms(terms),trans(trans){","    n=(int)(trans.size());vi a(n+1);a[1]=1;","    bin.push_back(a);","    for(int i = 1; i < LOG; ++i) bin.push_back(add(bin[i-1],bin[i-1]));","  }","  int calc(int k){","    vi a(n+1);a[0]=1;","    for(int i = 0; i < LOG; ++i) if((k>>i)&1)a=add(a,bin[i]);","    int ret=0;","    for(int i = 0 ; i < n ; ++i) ret=((long long)ret+(long long)a[i+1]*terms[i])%MOD;","    return ret;","  }","};",]
},
"number_theory.cpp": {
	"prefix": "number_theory.cpp" ,
	"body": ["struct number_theory{","	int SZ;","	vector<int> lpf, prime, mu, phi; // least prime factor, primes, mobius function, totient function, number of multiples","	number_theory(int SZ): SZ(SZ), lpf(SZ + 1), mu(SZ + 1, 1), phi(SZ + 1, 1){ // O(SZ)","		lpf[0] = lpf[1] = numeric_limits<int>::max() / 2;","		for(int i = 2; i <= SZ; ++ i){","			if(!lpf[i]) lpf[i] = i, prime.push_back(i);","			if(i / lpf[i] % lpf[i]) mu[i] = -mu[i / lpf[i]], phi[i] = phi[i / lpf[i]] * (lpf[i] - 1);","			else mu[i] = 0, phi[i] = phi[i / lpf[i]] * lpf[i];","			for(int j = 0; j < (int)prime.size() && prime[j] <= lpf[i] && prime[j] * i <= SZ; ++ j) lpf[prime[j] * i] = prime[j];","		}","	}","	int mu_large(long long x){ // O(sqrt(x))","		int res = 1;","		for(long long i = 2; i * i <= x; ++ i) if(x % i == 0){","			if(x / i % i) return 0;","			x /= i, res = -res;","		}","		if(x > 1) res = -res;","		return res;","	}","	long long phi_large(long long x){ // O(sqrt(x))","		long long res = x;","		for(long long i = 2; i * i <= x; ++ i) if(x % i == 0){","			while(x % i == 0) x /= i;","			res -= res / i;","		}","		if(x > 1) res -= res / x;","		return res;","	}","	template<class T> // O(n log n)","	vector<T> convolute(const vector<T> &a, const vector<T> &b){","		int n = (int)a.size();","		assert(n == (int)b.size());","		vector<T> res(n);","		for(int x = 1; x < n; ++ x) for(int y = 1; x * y < n; ++ y) res[x * y] += a[x] * b[y];","		return res;","	}","	template<class T> // O(n log n log k)","	vector<T> conv_exp(const vector<T> &a, long long e){","		int n = (int)a.size();","		vector<T> res(n), p(a.begin(), a.end());","		res[1] = 1;","		for(; e; e >>= 1, p = convolute(a, a)) if(e & 1) res = convolute(res, p);","		return res;","	}","	template<class T> // O(n log n)","	vector<T> mobius_transform(const vector<T> &a){","		int n = (int)a.size();","		vector<T> res(n);","		for(int x = 1; x < n; ++ x) for(int mx = x; mx < n; mx += x) res[mx] += a[x];","		return res;","	}","	template<class T> // O(n log n)","	vector<T> inverse_transform(const vector<T> &a){","		int n = (int)a.size();","		vector<T> res(n);","		for(int x = 1; x < n; ++ x) for(int y = 1; x * y < n; ++ y) res[x * y] += a[x] * mu[y];","		return res;","	}","	vector<int> mul_cnt;","	bool mul_cnt_ready = false;","	template<class T> // O(SZ log SZ)","	void init_mul_cnt(const vector<int> &a){","		mul_cnt_ready = true;","		vector<int> cnt(SZ + 1);","		mul_cnt.assign(SZ + 1, 0);","		for(auto x: a) ++ cnt[x];","		for(int x = 1; x <= SZ; ++ x) for(int mx = x; mx <= SZ; mx += x) mul_cnt[x] += cnt[mx];","	}","	template<class T> // Requires Z_p, O((SZ / g) log k)","	T count_tuples_with_gcd(int k, int g = 1){","		assert(mul_cnt_ready);","		T res = 0;","		for(int x = SZ / g; x >= 1; -- x) res += mu[x] * (T(mul_cnt[x * g]) ^ k);","		return res;","	}","};",]
},
"fft.cpp": {
	"prefix": "fft.cpp" ,
	"body": ["// MAXN must be power of 2 !!","// MOD-1 needs to be a multiple of MAXN !!","// big mod and primitive root for NTT:","typedef long long tf;","typedef vector<tf> poly;","const tf MOD=2305843009255636993,RT=5;","// FFT","struct CD {","	double r,i;","	CD(double r=0, double i=0):r(r),i(i){}","	double real()const{return r;}","	void operator/=(const int c){r/=c, i/=c;}","};","CD operator*(const CD& a, const CD& b){","	return CD(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}","CD operator+(const CD& a, const CD& b){return CD(a.r+b.r,a.i+b.i);}","CD operator-(const CD& a, const CD& b){return CD(a.r-b.r,a.i-b.i);}","const double pi=acos(-1.0);","// NTT","/*","struct CD {","	tf x;","	CD(tf x):x(x){}","	CD(){}","};","CD operator*(const CD& a, const CD& b){return CD(mulmod(a.x,b.x));}","CD operator+(const CD& a, const CD& b){return CD(addmod(a.x,b.x));}","CD operator-(const CD& a, const CD& b){return CD(submod(a.x,b.x));}","vector<tf> rts(MAXN+9,-1);","CD root(int n, bool inv){","	tf r=rts[n]<0?rts[n]=pm(RT,(MOD-1)/n):rts[n];","	return CD(inv?pm(r,MOD-2):r);","}","*/","const int MAXN = 1;","CD cp1[MAXN+9],cp2[MAXN+9];","int R[MAXN+9];","void dft(CD* a, int n, bool inv){","	for(int i = 0; i < n; ++i) if(R[i]<i)swap(a[R[i]],a[i]);","	for(int m=2;m<=n;m*=2){","		double z=2*pi/m*(inv?-1:1); // FFT","		CD wi=CD(cos(z),sin(z)); // FFT","		// CD wi=root(m,inv); // NTT","		for(int j=0;j<n;j+=m){","			CD w(1);","			for(int k=j,k2=j+m/2;k2<j+m;k++,k2++){","				CD u=a[k];CD v=a[k2]*w;a[k]=u+v;a[k2]=u-v;w=w*wi;","			}","		}","	}","	if(inv) for(int i = 0; i < n; ++i) a[i]/=n; // FFT","	//if(inv){ // NTT","	//	CD z(pm(n,MOD-2)); // pm: modular exponentiation","	//	fore(i,0,n)a[i]=a[i]*z;","	//}","}","poly multiply(poly& p1, poly& p2){","	int n=(int)p1.size()+(int)p2.size()+1;","	int m=1,cnt=0;","	while(m<=n)m+=m,cnt++;","	for(int i = 0; i < m; ++i){R[i]=0;for(int j = 0; j < cnt; ++j)R[i]=(R[i]<<1)|((i>>j)&1);}","	for(int i = 0; i < m; ++i)cp1[i]=0,cp2[i]=0;","	for(int i = 0; i < (int)(p1.size()); ++i)cp1[i]=p1[i];","	for(int i = 0; i < (int)(p2.size()); ++i)cp2[i]=p2[i];","	dft(cp1,m,false);dft(cp2,m,false);","	for(int i = 0; i < m; ++i)cp1[i]=cp1[i]*cp2[i];","	dft(cp1,m,true);","	poly res;","	n-=2;","	for(int i = 0; i < n; ++i)res.push_back((tf)floor(cp1[i].real()+0.5)); // FFT","	//fore(i,0,n)res.pb(cp1[i].x); // NTT","	return res;","}",]
},
"baby_step.cpp": {
	"prefix": "baby_step.cpp" ,
	"body": ["lli baby_step(lli a, lli b, lli p){","  a %= p;","  b %= p;","  if(b == 1) return 0;","  int cnt = 0;","  int tmp = 1;","  for(int g = gcd(a,p); g != 1; g = gcd(a,p)){","    if(b%g)return -1;","    p /= g; b /= g;","    tmp = tmp * a / g%p;","    cnt++;","    if(b == tmp)return cnt;","  }","","  unordered_map<lli, int> baby;","  lli N = ceil(sqrt(p));","  lli base = b;","  fore(i,0,N){","    baby[base]=i;","    base= base * a % p;","  }","  base = powm(a,N,p);","  lli key = tmp;","  fore(i,1,N+2){","    key = base * key % p;","    if(baby.count(key))return i*N-baby[key]+cnt;","  }","  return -1;","}",]
},
"karatsuba.cpp": {
	"prefix": "karatsuba.cpp" ,
	"body": ["typedef long long tp;","#define add(n,s,d,k) for(int i = 0; i < n; ++i) (d)[i]+=(s)[i]*k","tp* ini(int n){tp *r=new tp[n];fill(r,r+n,0);return r;}","void karatsura(int n, tp* p, tp* q, tp* r){","	if(n<=0)return;","	if(n<35)for(int i = 0; i < n; ++i)for(int j = 0; j < n; ++j)r[i+j]+=p[i]*q[j];","	else {","		int nac=n/2,nbd=n-n/2;","		tp *a=p,*b=p+nac,*c=q,*d=q+nac;","		tp *ab=ini(nbd+1),*cd=ini(nbd+1),*ac=ini(nac*2),*bd=ini(nbd*2);","		add(nac,a,ab,1);add(nbd,b,ab,1);","		add(nac,c,cd,1);add(nbd,d,cd,1);","		karatsura(nac,a,c,ac);karatsura(nbd,b,d,bd);","		add(nac*2,ac,r+nac,-1);add(nbd*2,bd,r+nac,-1);","		add(nac*2,ac,r,1);add(nbd*2,bd,r+nac*2,1);","		karatsura(nbd+1,ab,cd,r+nac);","		free(ab);free(cd);free(ac);free(bd);","	}","}","vector<tp> multiply(vector<tp> p0, vector<tp> p1){","	int n=max(p0.size(),p1.size());","	tp *p=ini(n),*q=ini(n),*r=ini(2*n);","	for(int i = 0; i < (int)(p0.size()); ++i) p[i]=p0[i];","	for(int i = 0; i < (int)(p1.size()); ++i) q[i]=p1[i];","	karatsura(n,p,q,r);","	vector<tp> rr(r,r+p0.size()+p1.size()-1);","	free(p);free(q);free(r);","	return rr;","}",]
},
"simpson.cpp": {
	"prefix": "simpson.cpp" ,
	"body": ["double integrate(double f(double), double a, double b, int n=10000){","	double r=0,h=(b-a)/n,fa=f(a),fb;","	for(int i = 0; i < n; ++i){fb=f(a+h*(i+1));r+=fa+4*f(a+h*(i+0.5))+fb;fa=fb;}","	return r*h/6.;","}",]
},
"bairsow.cpp": {
	"prefix": "bairsow.cpp" ,
	"body": ["// Needs a const ITER","typedef double tp; // type of polynomial","template<class T=tp>","struct poly {  // poly<> : 1 variable, poly<poly<>>: 2 variables, etc.","	vector<T> c;","	T& operator[](int k){return c[k];}","	poly(vector<T>& c):c(c){}","	poly(initializer_list<T> c):c(c){}","	poly(int k):c(k){}","	poly(){}","	poly operator+(poly<T> o){","		int m=c.size(),n=o.c.size();","		poly res(max(m,n));","		for(int i = 0; i < m; ++i)res[i]=res[i]+c[i];","		for(int i = 0; i < n; ++i)res[i]=res[i]+o.c[i];","		return res;","	}","	poly operator*(tp k){","		poly res(c.size());","		for(int i = 0; i < (int)c.size(); ++i)res[i]=c[i]*k;","		return res;","	}","	poly operator*(poly o){","		int m=c.size(),n=o.c.size();","		poly res(m+n-1);","		for(int i = 0; i < m; ++i)for(int j = 0; j < n; ++j)res[i+j]=res[i+j]+c[i]*o.c[j];","		return res;","	}","	poly operator-(poly<T> o){return *this+(o*-1);}","	T operator()(tp v){","		T sum(0);","		for(int i=c.size()-1;i>=0;--i)sum=sum*v+c[i];","		return sum;","	}","	void print(){","		while(!c.empty()&&abs(c.back())<EPS)c.pop_back();","		if(c.empty())puts(\" 0\");","		else {","			for(auto x:c)printf(\" %.6lf\",x);","			puts(\"\");","		}","	}","};","// only for double polynomials","pair<poly<>,poly<> > polydiv(poly<> p, poly<> q){ // returns pair (result,rem)","	int n=p.c.size()-q.c.size()+1;","	vector<tp> b(n);","	for(int k=n-1;k>=0;--k){","		b[k]=p.c.back()/q.c.back();","		for(int i = 0; i < (int)q.c.size(); ++i)p[i+k]-=b[k]*q[i];","		p.c.pop_back();","	}","	while(!p.c.empty()&&abs(p.c.back())<EPS)p.c.pop_back();","	return {poly<>(b),p};","}","","double pget(poly<>& p, int k){return k<p.c.size()?p[k]:0;}","poly<> bairstow(poly<> p){ // returns polynomial of degree 2 that","	int n=p.c.size()-1;    // divides p","	assert(n>=3&&abs(p.c.back())>EPS);","	double u=p[n-1]/p[n],v=p[n-2]/p[n];","	for(int iter = 0; iter < ITER; ++iter){","		auto w=polydiv(p,{v,u,1});","		poly<> q=w.first,r0=w.second;","		poly<> r1=polydiv(q,{v,u,1}).second;","		double c=pget(r0,1),d=pget(r0,0),g=pget(r1,1),h=pget(r1,0);","		double det=1/(v*g*g+h*(h-u*g)),uu=u;","		u-=det*(-h*c+g*d);v-=det*(-g*v*c+(g*uu-h)*d);","","	}","	return {v,u,1};","}","void addr(vector<double>& r, poly<>& p){","	assert(p.c.size()<=3);","	if(p.c.size()<=1)return;","	if(p.c.size()==2)r.push_back(-p[0]/p[1]);","	if(p.c.size()==3){","		double a=p[2],b=p[1],c=p[0];","		double d=b*b-4*a*c;","		if(d<-0.1)return; // huge epsilon because of bad precision","		d=d>0?sqrt(d):0;r.push_back((-b-d)/2/a);r.push_back((-b+d)/2/a);","	}","}","vector<double> roots(poly<> p){","	while(!p.c.empty()&&abs(p.c.back())<EPS)p.c.pop_back();","	for(int i = 0; i < (int)p.c.size(); ++i)p[i]/=p.c.back();","	vector<double> r;int n;","	while((n=p.c.size()-1)>=3){","		poly<> q=bairstow(p);addr(r,q);","		p=polydiv(p,q).first;","		while((int)p.c.size()>n-1)p.c.pop_back();","	}","	addr(r,p);","	return r;","}",]
},
"mobius.cpp": {
	"prefix": "mobius.cpp" ,
	"body": ["const int MAXN = 100;","short mu[MAXN] = {0,1};","void mobius(){","	for(int i = 1; i < MAXN; ++i) if(mu[i])for(int j=i+i;j<MAXN;j+=i)mu[j]-=mu[i];","}",]
},
"inversemod.cpp": {
	"prefix": "inversemod.cpp" ,
	"body": ["long long inv(long long a, long long mod) { //inverse of a modulo mod","	assert(gcd(a,mod)==1);","	pair<long long, long long> sol = extendedEuclid(a,mod);","	return ((sol.first%mod)+mod)%mod;","}",]
},
"discrete_log.cpp": {
	"prefix": "discrete_log.cpp" ,
	"body": ["long long powm(long long a, long long b, long long mod){","	long long res =1;","	while(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }","	return res;","}","long long discrete_log(long long a,long long b,long long m) {","    a%=m, b%=m;","    if(b == 1) return 0;","    int cnt=0;","    long long tmp=1;","    for(int g=__gcd(a,m);g!=1;g=__gcd(a,m)) {","        if(b%g) return -1;","        m/=g, b/=g;","        tmp = tmp*a/g%m;","        ++cnt;","        if(b == tmp) return cnt;","    }","    map<long long,int> w;","    int s = ceil(sqrt(m));","    long long base = b;","    for(int i = 0; i < s; ++i) {","        w[base] = i;","        base=base*a%m;","    }","    base=powm(a,s,m);","    long long key=tmp;","    for(int i = 1; i < s + 2; ++i) {","        key=base*key%m;","        if(w.count(key)) return i*s-w[key]+cnt;","    }","    return -1;","}",]
},
"pollard_rho.cpp": {
	"prefix": "pollard_rho.cpp" ,
	"body": ["long long gcd(long long a, long long b){return a?gcd(b%a,a):b;}","long long mulmod(long long a, long long b, long long m) {","	long long r=a*b-(long long)((long double)a*b/m+.5)*m;","	return r<0?r+m:r;","}","long long expmod(long long b, long long e, long long m){","	if(!e)return 1;","	long long q=expmod(b,e/2,m);q=mulmod(q,q,m);","	return e&1?mulmod(b,q,m):q;","}","bool is_prime_prob(long long n, long long a){","	if(n==a)return true;","	long long s=0,d=n-1;","	while(d%2==0)s++,d/=2;","	long long x=expmod(a,d,n);","	if((x==1)||(x+1==n))return true;","	for(int tt = 0; tt < s - 1; ++tt){","		x=mulmod(x,x,n);","		if(x==1)return false;","		if(x+1==n)return true;","	}","	return false;","}","bool rabin(long long n){ // true iff n is prime","	if(n==1)return false;","	int ar[]={2,3,5,7,11,13,17,19,23};","	for(int i = 0; i < 9; ++i)if(!is_prime_prob(n,ar[i]))return false;","	return true;","}","long long rho(long long n){","	if(!(n&1))return 2;","	long long x=2,y=2,d=1;","	long long c=rand()%n+1;","	while(d==1){","		x=(mulmod(x,x,n)+c)%n;","		y=(mulmod(y,y,n)+c)%n;","		y=(mulmod(y,y,n)+c)%n;","		if(x>=y)d=gcd(x-y,n);","		else d=gcd(y-x,n);","	}","	return d==n?rho(n):d;","}","void fact(long long n, map<long long,int>& f){ //O (lg n)^3","	if(n==1)return;","	if(rabin(n)){f[n]++;return;}","	long long q=rho(n);fact(q,f);fact(n/q,f);","}","// optimized version: replace rho and fact with the following:","const int MAXP=1e6+1; // sieve size","int sv[MAXP]; // sieve","long long add(long long a, long long b, long long m){return (a+=b)<m?a:a-m;}","long long rho(long long n){","	static long long s[MAXP];","	while(1){","		long long x=rand()%n,y=x,c=rand()%n;","		long long *px=s,*py=s,v=0,p=1;","		while(1){","			*py++=y=add(mulmod(y,y,n),c,n);","			*py++=y=add(mulmod(y,y,n),c,n);","			if((x=*px++)==y)break;","			long long t=p;","			p=mulmod(p,abs(y-x),n);","			if(!p)return gcd(t,n);","			if(++v==26){","				if((p=gcd(p,n))>1&&p<n)return p;","				v=0;","			}","		}","		if(v&&(p=gcd(p,n))>1&&p<n)return p;","	}","}","void init_sv(){","	for(int i = 2; i < MAXP; ++i)if(!sv[i])for(long long j=i;j<MAXP;j+=i)sv[j]=i;","}","void fact(long long n, map<long long,int>& f){ // call init_sv first!!!","	for(auto&& p:f){","		while(n%p.first==0){","			p.second++;","			n/=p.first;","		}","	}","	if(n<MAXP)while(n>1)f[sv[n]]++,n/=sv[n];","	else if(rabin(n))f[n]++;","	else {long long q=rho(n);fact(q,f);fact(n/q,f);}","}",]
},
"floor_division.cpp": {
	"prefix": "floor_division.cpp" ,
	"body": ["void floordiv(long long x, long long y, long long& q, long long& r) { // (for negative x)","	q=x/y;r=x%y;","	if((r!=0)&&((r<0)!=(y<0)))q--,r+=y;","}",]
},
"fht.cpp": {
	"prefix": "fht.cpp" ,
	"body": ["const int MAXN = 1;","long long c1[MAXN+9],c2[MAXN+9];  // MAXN must be power of 2 !!","void fht(long long* p, int n, bool inv){","	for(int l=1;2*l<=n;l*=2)for(int i=0;i<n;i+=2*l)for(int j = 0; j < l; ++j){","		long long u=p[i+j],v=p[i+l+j];","		if(!inv)p[i+j]=u+v,p[i+l+j]=u-v; // XOR","		else p[i+j]=(u+v)/2,p[i+l+j]=(u-v)/2;","		//if(!inv)p[i+j]=v,p[i+l+j]=u+v; // AND","		//else p[i+j]=-u+v,p[i+l+j]=u;","		//if(!inv)p[i+j]=u+v,p[i+l+j]=u; // OR","		//else p[i+j]=v,p[i+l+j]=u-v;","	}","}","// like polynomial multiplication, but XORing exponents","// instead of adding them (also ANDing, ORing)","vector<long long> multiply(vector<long long>& p1, vector<long long>& p2){","	int n=1<<(32-__builtin_clz(max((int)(p1.size()),(int)(p2.size())-1)));","	for(int i = 0; i < n; ++i)c1[i]=0,c2[i]=0;","	for(int i = 0; i < (int)(p1.size()); ++i) c1[i]=p1[i];","	for(int i = 0; i < (int)(p2.size()); ++i) c2[i]=p2[i];","	fht(c1,n,false);fht(c2,n,false);","	for(int i = 0; i < n; ++i) c1[i]*=c2[i];","	fht(c1,n,true);","	return vector<long long>(c1,c1+n);","}",]
},
"modulo.cpp": {
	"prefix": "modulo.cpp" ,
	"body": ["using uint=unsigned;","using ull=unsigned long long;","struct modinfo{uint mod,root;};","template<modinfo const&ref>","struct modular{","	static constexpr uint const &mod=ref.mod;","	static modular root(){return modular(ref.root);}","	uint v;","	//modular(initializer_list<uint>ls):v(*ls.bg){}","	modular(lli vv=0){s(vv%mod+mod);}","	modular& s(uint vv){","		v=vv<mod?vv:vv-mod;","		return *this;","	}","	modular operator-()const{return modular()-*this;}","	modular& operator+=(const modular&rhs){return s(v+rhs.v);}","	modular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}","	modular&operator*=(const modular&rhs){","		v=ull(v)*rhs.v%mod;","		return *this;","	}","	modular&operator/=(const modular&rhs){return *this*=rhs.inv();}","	modular operator+(const modular&rhs)const{return modular(*this)+=rhs;}","	modular operator-(const modular&rhs)const{return modular(*this)-=rhs;}","	modular operator*(const modular&rhs)const{return modular(*this)*=rhs;}","	modular operator/(const modular&rhs)const{return modular(*this)/=rhs;}","	modular pow(int n)const{","		modular res(1),x(*this);","		while(n){","			if(n&1)res*=x;","			x*=x;","			n>>=1;","		}","		return res;","	}","	modular inv()const{return pow(mod-2);}","","	friend modular operator+(int x,const modular&y){","		return modular(x)+y;","	}","	friend modular operator-(int x,const modular&y){","		return modular(x)-y;","	}","	friend modular operator*(int x,const modular&y){","		return modular(x)*y;","	}","	friend modular operator/(int x,const modular&y){","		return modular(x)/y;","	}","	friend ostream& operator<<(ostream&os,const modular&m){","		return os<<m.v;","	}","	friend istream& operator>>(istream&is,modular&m){","		lli x;is>>x;","		m=modular(x);","		return is;","	}","	bool operator<(const modular&r)const{return v<r.v;}","	bool operator==(const modular&r)const{return v==r.v;}","	bool operator!=(const modular&r)const{return v!=r.v;}","	explicit operator bool()const{","		return v;","	}","};","","//extern constexpr modinfo base{998244353,3};","extern constexpr modinfo base{1000000007,0};","//modinfo base{1,0};","using mint=modular<base>;",]
},
"matrices.cpp": {
	"prefix": "matrices.cpp" ,
	"body": ["","template<typename T>","struct Matrix{","	vector<vector<T>> a;","	Matrix(){}","	Matrix(size_t n, size_t m):a(n, vector<T>(m, 0)){}","	Matrix(size_t n):Matrix(n, n){}","	Matrix(vector<vector<T>> a):a(a){}","","	size_t height() const{ return a.size();}","	size_t width() const{return a[0].size();}","","	inline const vector<T> &operator[](size_t k) const{return a[k];}","	inline vector<T> &operator[](size_t k){return a[k];}","","	static Matrix I(size_t n){","		Matrix mat(n);","		for(int i=0; i<n; i++) mat[i][i]=1;","		return mat;","	}","","	Matrix &operator+=(const Matrix &b){","		size_t n=height(), m=width();","		for(int i=0; i<n; i++)for(int j=0; j<m; j++)(*this)[i][j]+=b[i][j];","		return (*this);","	}","	Matrix &operator-=(const Matrix &b){","		size_t n=height(), m=width();","		for(int i=0; i<n; i++)for(int j=0; j<m; j++)(*this)[i][j]-=b[i][j];","		return (*this);","	}","	Matrix &operator*=(const Matrix &b){","		size_t n=height(), m=width(), l=b.width();","		vector<vector<T>> c(n, vector<T>(l, 0));","		for(int i=0; i<n; i++)for(int j=0; j<l; j++)for(int k=0; k<m; k++)c[i][j]+=(*this)[i][k]*b[k][j];","		a.swap(c);","		return (*this);","	}","	Matrix operator+(const Matrix &b) const{return (Matrix(*this)+=b);}","	Matrix operator-(const Matrix &b) const{return (Matrix(*this)-=b);}","	Matrix operator*(const Matrix &b) const{return (Matrix(*this)*=b);}","","	Matrix pow(lli k) const{","		Matrix ap(a), ret=I(height());","		while(k){","			if(k&1) ret*=ap;","			ap*=ap;","			k>>=1;","		}","		return ret;","	}","","	static pair<Matrix, Matrix> Gauss_Jordan(const Matrix &a, const Matrix &b){","		size_t n=a.height(), m=a.width(), l=b.width();","		Matrix c(n, m+l);","		for(int i=0; i<n; i++) for(int j=0; j<m; j++) c[i][j]=a[i][j];","		for(int i=0; i<n; i++) for(int j=0; j<l; j++) c[i][j+m]=b[i][j];","		int d=0;","		for(int i=0; i<m; i++){","			int p=-1;","			for(int j=d; j<n; j++)if(c[j][i]!=0){p=j; break;}","			if(p==-1) continue;","			swap(c[p], c[d]);","			T invc=T(1)/c[d][i];","			for(int j=i; j<m+l; j++) c[d][j]*=invc;","			for(int j=0; j<n; j++){","				if(j==d) continue;","				T c0=c[j][i];","				for(int k=i; k<m+l; k++)c[j][k]-=c0*c[d][k];","			}","			d++;","		}","		Matrix reta(n, m), retb(n, l);","		for(int i=0; i<n; i++) for(int j=0; j<m; j++) reta[i][j]=c[i][j];","		for(int i=0; i<n; i++) for(int j=0; j<l; j++) retb[i][j]=c[i][j+m];","		return make_pair(reta, retb);","	}","","	static pair<vector<T>, vector<vector<T>>> linear_equations(const Matrix &a, const vector<T> &b){","		int n=a.height(), m=a.width();","		Matrix B(n, 1);","		for(int i=0; i<n; i++) B[i][0]=b[i];","		auto p=Gauss_Jordan(a, B);","		vector<int> myon(n,-1);","		vector<int> nuo(m, -1);","		for(int i=0; i<n; i++){","			bool allzero=1;","			for(int j=0; j<m; j++)if(p.first[i][j]!=0){","					allzero=0;","					myon[i]=j;","					nuo[j]=i;","					break;","				}","			if(allzero && p.second[i][0]!=0){","				vector<T> retc;","				vector<vector<T>> retd;","				return make_pair(retc, retd);","			}","		}","		vector<T> c(m);","		vector<vector<T>> d;","		for(int i=0; i<m; i++){","			if(nuo[i]==-1){","				vector<T> v(m);","				v[i]=1;","				for(int j=0; j<n; j++)if(myon[j]!=-1) v[myon[j]]=-p.first[j][i];","				d.push_back(v);","			}else c[i]=p.second[nuo[i]][0];","		}","		return make_pair(c, d);","	}","","	Matrix inv() const{","		int n=height();","		Matrix b=I(n);","		auto p=Gauss_Jordan(*this, b);","		if(p.first[n-1][n-1]==0){","			Matrix ret(0);","			return ret;","		}","		return p.second;","	}","","	int rank() const{","		int n=height(), m=width();","		Matrix b(n, 0);","		auto p=Gauss_Jordan(*this, b);","		for(int i=0; i<n; i++){","			bool allzero=1;","			for(int j=0; j<m; j++)if(p.first[i][j]!=0){","					allzero=0;","					break;","				}","			if(allzero) return i;","		}","		return n;","	}","","	T det() const{","		size_t n=height();","		Matrix A(a);","		T ret(1);","		for(int i=0; i<n; i++){","			int p=-1;","			for(int j=i; j<n; j++)if(A[j][i]!=0){","					p=j; break;","				}","			if(p==-1)return 0;","			if(p!=i) ret*=(-1);","			swap(A[p], A[i]);","			ret*=A[i][i];","			T inva=T(1)/A[i][i];","			for(int j=i+1; j<n; j++){","				T a0=A[j][i];","				for(int k=i; k<n; k++)A[j][k]-=inva*a0*A[i][k];","			}","		}","		return ret;","	}","};",]
},
"frac.cpp": {
	"prefix": "frac.cpp" ,
	"body": ["struct frac {","	template <typename T> static constexpr inline T gcd(const T a, const T b) { return (b == 0) ? a : gcd(b, a % b); }","	__int128_t q, p;","	inline constexpr void simplify() {","		if(p < 0) {","			p *= -1;","			q *= -1;","		}","		ll g = gcd(q < 0 ? -q : q, p);","		if(g) {","			p /= g;","			q /= g;","		}","	}","	constexpr frac(ll q = 0, ll p = 1) noexcept : q(q), p(p) { simplify(); }","","	constexpr bool operator<(const frac &r) const { return q * r.p < p * r.q; }","	constexpr bool operator<=(const frac &r) const { return q * r.p <= p * r.q; }","","	constexpr bool operator>(const frac &r) const { return q * r.p > p * r.q; }","	constexpr bool operator>=(const frac &r) const { return q * r.p >= p * r.q; }","","	template <class T> const bool operator<(const T &r) const { return *this < frac(r); }","	template <class T> const bool operator>(const T &r) const { return *this > frac(r); }","	constexpr bool operator!=(const frac &r) const { return q * r.p < p * r.q; }","	constexpr bool operator==(const frac &r) const { return q * r.p == p * r.q; }","	constexpr frac operator+(const frac r) const noexcept { return frac(*this) += r; }","	constexpr frac operator-(const frac r) const noexcept { return frac(*this) -= r; }","	constexpr frac operator*(const frac r) const noexcept { return frac(*this) *= r; }","	constexpr frac operator/(const frac r) const noexcept { return frac(*this) /= r; }","	constexpr frac &operator+=(const frac &r) noexcept {","		__int128_t g = 1;","		q = r.p / g * q + p / g * r.q;","		p = p / g * r.p;","		(*this).simplify();","		return *this;","	}","	constexpr frac &operator-=(const frac &r) noexcept {","		__int128_t g = 1;","		q = r.p / g * q - p / g * r.q;","		p = p / g * r.p;","		(*this).simplify();","		return *this;","	}","	constexpr frac &operator*=(const frac &r) noexcept {","		q *= r.q;","		p *= r.p;","		(*this).simplify();","		return *this;","	}","	constexpr frac &operator/=(const frac &r) noexcept {","		q *= r.p;","		p *= r.q;","		(*this).simplify();","		return *this;","	}","","	void print() {","		long double tmp = (long double)q / (long double)p;","		cout << tmp;","	}","};",]
},
"berlekamp_massey.cpp": {
	"prefix": "berlekamp_massey.cpp" ,
	"body": ["long long MOD = 1e9 + 7;","long long powm(long long a, long long b, long long mod){","	long long res =1;","	while(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }","	return res;","}","vector<int> BM(vector<int> x){","vector<int> ls,cur;int lf,ld;","for(int i = 0; i < (int)(x.size()); ++i){","	long long t=0;","	for(int j = 0; j < (int)(cur.size()); ++j) t=(t+x[i-j-1]*(long long)cur[j])%MOD;","	if((t-x[i])%MOD==0)continue;","	if(!(int)cur.size()){cur.resize(i+1);lf=i;ld=(t-x[i])%MOD;continue;}","	long long k=-(x[i]-t)*powm(ld,MOD-2, MOD)%MOD;","	vector<int> c(i-lf-1);c.push_back(k);","	for(int j = 0; j < (int)(ls.size()); ++j) c.push_back(-ls[j]*k%MOD);","	if((int)c.size()<(int)(cur.size()))c.resize((int)(cur.size()));","	for(int j = 0; j < (int)(cur.size()); ++j) c[j]=(c[j]+cur[j])%MOD;","	if(i-lf+(int)(ls.size())>=(int)(cur.size()))ls=cur,lf=i,ld=(t-x[i])%MOD;","	cur=c;","}","for(int i = 0; i < (int)(cur.size()); ++i) cur[i]=(cur[i]%MOD+MOD)%MOD;","return cur;","}",]
},
"points_under_line.cpp": {
	"prefix": "points_under_line.cpp" ,
	"body": ["long long f(long long a, long long b, long long c){","	if(c<=0) return 0;","	if(a<b) swap(a, b);","	long long m=c/a;","	if(a==b) return m*(m-1)/2;","	long long k=(a-1)/b, h=(c-a*m)/b;","	return f(b,a-b*k,c-b*(k*m+h))+k*m*(m-1)/2+m*h;","}","","// # of lattice points s.t. ax+by<=c, 0<x<=X, 0<y<=Y (a,b is positive integer)","long long g(long long a, long long b, long long c, long long X, long long Y){","	if(a*X+b*Y<=c) return X*Y;","	return f(a,b,c)-f(a,b,c-a*X)-f(a,b,c-b*Y)+f(a,b,c-a*X-b*Y);","}",]
},
"extended_euclid.cpp": {
	"prefix": "extended_euclid.cpp" ,
	"body": ["long long euclid(long long a, long long b, long long& x, long long& y){ // a*(x+k*(b/d))+b*(y-k*(a/d))=d","if(!b){x=1;y=0;return a;}          // (for any k)","long long d=euclid(b,a%b,x,y);","long long t=y;y=x-(a/b)*y;x=t;","return d;","}",]
},
"fft_operations.cpp": {
	"prefix": "fft_operations.cpp" ,
	"body": ["long long powm(long long a, long long b, long long mod){","	long long res =1;","	while(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }","	return res;","}","long long inv(long long a, long long mod) {","	return powm(a, mod - 2, mod);","}","// MAXN must be power of 2 !!","// MOD-1 needs to be a multiple of MAXN !!","// big mod and primitive root for NTT:","typedef long long tf;","typedef vector<tf> poly;","const tf MOD=2305843009255636993,RT=5;","// FFT","struct CD {","	double r,i;","	CD(double r=0, double i=0):r(r),i(i){}","	double real()const{return r;}","	void operator/=(const int c){r/=c, i/=c;}","};","CD operator*(const CD& a, const CD& b){","	return CD(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}","CD operator+(const CD& a, const CD& b){return CD(a.r+b.r,a.i+b.i);}","CD operator-(const CD& a, const CD& b){return CD(a.r-b.r,a.i-b.i);}","const double pi=acos(-1.0);","// NTT","/*","struct CD {","	tf x;","	CD(tf x):x(x){}","	CD(){}","};","CD operator*(const CD& a, const CD& b){return CD(mulmod(a.x,b.x));}","CD operator+(const CD& a, const CD& b){return CD(addmod(a.x,b.x));}","CD operator-(const CD& a, const CD& b){return CD(submod(a.x,b.x));}","vector<tf> rts(MAXN+9,-1);","CD root(int n, bool inv){","	tf r=rts[n]<0?rts[n]=pm(RT,(MOD-1)/n):rts[n];","	return CD(inv?pm(r,MOD-2):r);","}","*/","const int MAXN = 1;","CD cp1[MAXN+9],cp2[MAXN+9];","int R[MAXN+9];","void dft(CD* a, int n, bool inv){","	for(int i = 0; i < n; ++i) if(R[i]<i)swap(a[R[i]],a[i]);","	for(int m=2;m<=n;m*=2){","		double z=2*pi/m*(inv?-1:1); // FFT","		CD wi=CD(cos(z),sin(z)); // FFT","		// CD wi=root(m,inv); // NTT","		for(int j=0;j<n;j+=m){","			CD w(1);","			for(int k=j,k2=j+m/2;k2<j+m;k++,k2++){","				CD u=a[k];CD v=a[k2]*w;a[k]=u+v;a[k2]=u-v;w=w*wi;","			}","		}","	}","	if(inv) for(int i = 0; i < n; ++i) a[i]/=n; // FFT","	//if(inv){ // NTT","	//	CD z(pm(n,MOD-2)); // pm: modular exponentiation","	//	fore(i,0,n)a[i]=a[i]*z;","	//}","}","poly multiply(poly& p1, poly& p2){","	int n=(int)p1.size()+(int)p2.size()+1;","	int m=1,cnt=0;","	while(m<=n)m+=m,cnt++;","	for(int i = 0; i < m; ++i){R[i]=0;for(int j = 0; j < cnt; ++j)R[i]=(R[i]<<1)|((i>>j)&1);}","	for(int i = 0; i < m; ++i)cp1[i]=0,cp2[i]=0;","	for(int i = 0; i < (int)(p1.size()); ++i)cp1[i]=p1[i];","	for(int i = 0; i < (int)(p2.size()); ++i)cp2[i]=p2[i];","	dft(cp1,m,false);dft(cp2,m,false);","	for(int i = 0; i < m; ++i)cp1[i]=cp1[i]*cp2[i];","	dft(cp1,m,true);","	poly res;","	n-=2;","	for(int i = 0; i < n; ++i)res.push_back((tf)floor(cp1[i].real()+0.5)); // FFT","	//fore(i,0,n)res.pb(cp1[i].x); // NTT","	return res;","}","","//Polynomial division: O(n*log(n))","//Multi-point polynomial evaluation: O(n*log^2(n))","//Polynomial interpolation: O(n*log^2(n))","long long addmod(long long a, long long b) {","	if(a + b > MOD) return (a + b) - MOD;","	return a + b;","}","long long submod(long long a, long long b) {","	if(a - b < 0) return (a - b) + MOD;","	return a - b;","}","long long mulmod(long long a, long long b) {","	return (a * b) % MOD;","}","//Works with NTT. For FFT, just replace addmod,submod,mulmod,inv","poly add(poly &a, poly &b){","	int n=(int)a.size(),m=(int)b.size();","	poly ans(max(n,m));","	for(int i = 0; i < max(n, m); ++i){","		if(i<n) ans[i]=addmod(ans[i],a[i]);","		if(i<m) ans[i]=addmod(ans[i],b[i]);","	}","	while((int)(ans.size())>1&&!ans.back())ans.pop_back();","	return ans;","}","","poly invert(poly &b, int d){"," poly c = {inv(b[0], MOD)};"," while((int)(c.size())<=d){"," 	int j=2*(int)(c.size());","  auto bb=b; bb.resize(j);","  poly cb=multiply(c,bb);","  for(int i = 0; i < (int)(cb.size()); ++i) cb[i]=submod(0,cb[i]);","  cb[0]=addmod(cb[0],2);","  c=multiply(c,cb);","  c.resize(j);"," }"," c.resize(d+1);"," return c;","}","","pair<poly,poly> divslow(poly &a, poly &b){","	poly q,r=a;","	while((int)(r.size())>=(int)(b.size())){","		q.push_back(mulmod(r.back(),inv(b.back(), MOD)));","		if(q.back()) for(int i = 0; i < (int)(b.size()); ++i){","			r[(int)(r.size())-i-1]=submod(r[(int)(r.size())-i-1],mulmod(q.back(),b[(int)(b.size())-i-1]));","		}","		r.pop_back();","	}","	reverse(q.begin(), q.end());","	return {q,r};","}","","pair<poly,poly> divide(poly &a, poly &b){	//returns {quotient,remainder}","	int m=(int)(a.size()),n=(int)(b.size()),MAGIC=750;","	if(m<n) return {{0},a};","	if(min(m-n,n)<MAGIC)return divslow(a,b);","	poly ap=a; reverse(ap.begin(), ap.end());","	poly bp=b; reverse(bp.begin(), bp.end());","	bp=invert(bp,m-n);","	poly q=multiply(ap,bp);","	q.resize((int)(q.size())+m-n-(int)(q.size())+1,0);","	reverse(q.begin(), q.end());","	poly bq=multiply(b,q);","	for(int i = 0; i < (int)(bq.size()); ++i) bq[i]=submod(0,bq[i]);","	poly r=add(a,bq);","	return {q,r};","}","","vector<poly> tree;","","void filltree(vector<tf> &x){","	int k=(int)(x.size());","	tree.resize(2*k);","	for(int i = k; i < 2 * k; ++i)  tree[i]={submod(0,x[i-k]),1};","	for(int i=k-1;i;i--) tree[i]=multiply(tree[2*i],tree[2*i+1]);","}","","vector<tf> evaluate(poly &a, vector<tf> &x){","	filltree(x);","	int k=(int)(x.size());","	vector<poly> ans(2*k);","	ans[1]=divide(a,tree[1]).second;","	for(int i = 2; i < 2 * k; ++i) ans[i]=divide(ans[i>>1],tree[i]).second;","	vector<tf> r; for(int i = 0; i < k; ++i) r.push_back(ans[i+k][0]);","	return r;","}","","poly derivate(poly &p){","	poly ans((int)(p.size())-1);","	for(int i = 1; i < (int)(p.size()); ++i) ans[i-1]=mulmod(p[i],i);","	return ans;","}","","poly interpolate(vector<tf> &x, vector<tf> &y){","	filltree(x);","	poly p=derivate(tree[1]);","	int k=(int)(y.size());","	vector<tf> d=evaluate(p,x);","	vector<poly> intree(2*k);","	for(int i = k; i < 2 * k; ++i) intree[i]={mulmod(y[i-k],inv(d[i-k], MOD))};","	for(int i=k-1;i;i--){","		poly p1=multiply(tree[2*i],intree[2*i+1]);","		poly p2=multiply(tree[2*i+1],intree[2*i]);","		intree[i]=add(p1,p2);","	}","	return intree[1];","}",]
},
"double_cmp.cpp": {
	"prefix": "double_cmp.cpp" ,
	"body": ["typedef long double td;","const td eps = 1e-9, inf = numeric_limits<ld>::max(), pi = acos(-1);","// For use with integers, just set eps=0 and everything remains the same","bool geq(td a, td b){return a-b >= -eps;}     //a >= b","bool leq(td a, td b){return b-a >= -eps;}     //a <= b","bool ge(td a, td b){return a-b > eps;}        //a > b","bool le(td a, td b){return b-a > eps;}        //a < b","bool eq(td a, td b){return abs(a-b) <= eps;}  //a == b","bool neq(td a, td b){return abs(a-b) > eps;}  //a != b",]
},
"divisors.cpp": {
	"prefix": "divisors.cpp" ,
	"body": ["void div_rec(vector<long long>& r, vector<pair<long long,int> >& f, int k, long long c){","	if(k==(int)f.size()){r.push_back(c);return;}","	for(int i = 0; i < f[k].second + 1; ++i) div_rec(r,f,k+1,c),c*=f[k].first;","}","vector<long long> divisors(vector<pair<long long,int> > f){","	vector<long long> r; // returns divisors given factorization","	div_rec(r,f,0,1);","	return r;","}",]
},
"diophantine.cpp": {
	"prefix": "diophantine.cpp" ,
	"body": ["//Need gcd","pair<long long,long long> extendedEuclid (long long a, long long b){ //a * x + b * y = gcd(a,b)","	long long x,y;","	if (b==0) return {1,0};","	auto p=extendedEuclid(b,a%b);","	x=p.second;","	y=p.first-(a/b)*x;","	if(a*x+b*y==-gcd(a,b)) x=-x, y=-y;","	return {x,y};","}","pair<pair<long long,long long>,pair<long long,long long> > diophantine(long long a,long long b, long long r) {","	//a*x+b*y=r where r is multiple of gcd(a,b);","	long long d=gcd(a,b);","	a/=d; b/=d; r/=d;","	auto p = extendedEuclid(a,b);","	p.first*=r; p.second*=r;","	assert(a*p.first+b*p.second==r);","	return {p,{-b,a}}; // solutions: p+t*ans.snd","}",]
},
"tonelli_shanks.cpp": {
	"prefix": "tonelli_shanks.cpp" ,
	"body": ["mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());","long long rnd(long long a, long long b){return uniform_int_distribution<long long>(a, b)(rng);}","long long powm(long long a, long long b, long long mod){","	long long res =1;","	while(b){ if(b&1) res = (res * a) % mod; a = (a*a) % mod; b/=2; }","	return res;","}","long long legendre(long long a, long long p){","  if(a%p==0)return 0; if(p==2)return 1;","  return powm(a,(p-1)/2,p);","}","long long tonelli_shanks(long long n, long long p){	// sqrt(n) mod p (p must be a prime)","  assert(legendre(n,p)==1); if(p==2)return 1;","  long long s=__builtin_ctzll(p-1), q=(p-1LL)>>s, z=rnd(1,p-1);","  if(s==1)return powm(n,(p+1)/4LL,p);","  while(legendre(z,p)!=p-1)z=rnd(1,p-1);","  long long c=powm(z,q,p), r=powm(n,(q+1)/2,p), t=powm(n,q,p), m=s;","  while(t!=1){","    long long i=1, ts=(t*t)%p;","    while(ts!=1)i++,ts=(ts*ts)%p;","    long long b=c;","    for(int tt = 0; tt < m - i - 1; ++tt) b=(b*b)%p;","    r=r*b%p;c=b*b%p;t=t*c%p;m=i;","  }","  return r;","}",]
},
"polynomial.cpp": {
	"prefix": "polynomial.cpp" ,
	"body": ["///Needs a EPS","typedef int tp; // type of polynomial","template<class T=tp>","struct poly {  // poly<> : 1 variable, poly<poly<>>: 2 variables, etc.","	vector<T> c;","	T& operator[](int k){return c[k];}","	poly(vector<T>& c):c(c){}","	poly(initializer_list<T> c):c(c){}","	poly(int k):c(k){}","	poly(){}","	poly operator+(poly<T> o){","		int m=c.size(),n=o.c.size();","		poly res(max(m,n));","		for(int i = 0; i < m; ++i)res[i]=res[i]+c[i];","		for(int i = 0; i < n; ++i)res[i]=res[i]+o.c[i];","		return res;","	}","	poly operator*(tp k){","		poly res(c.size());","		for(int i = 0; i < (int)c.size(); ++i)res[i]=c[i]*k;","		return res;","	}","	poly operator*(poly o){","		int m=c.size(),n=o.c.size();","		poly res(m+n-1);","		for(int i = 0; i < m; ++i) for(int j = 0; j < n; ++j)res[i+j]=res[i+j]+c[i]*o.c[j];","		return res;","	}","	poly operator-(poly<T> o){return *this+(o*-1);}","	T operator()(tp v){","		T sum(0);","		for(int i=(int)c.size()-1;i>=0;--i)sum=sum*v+c[i];","		return sum;","	}","};","// example: p(x,y)=2*x^2+3*x*y-y+4","// poly<poly<>> p={{4,-1},{0,3},{2}}","// printf(\"%d\n\",p(2)(3)) // 27 (p(2,3))","set<tp> roots(poly<> p){ // only for integer polynomials","	set<tp> r;","	while(!p.c.empty()&&!p.c.back())p.c.pop_back();","	if(!p(0))r.insert(0);","	if(p.c.empty())return r;","	tp a0=0,an=abs(p[p.c.size()-1]);","	for(int k=0;!a0;a0=abs(p[k++]));","	vector<tp> ps,qs;","	for(int i = 1; i < sqrt(a0)+1; ++i)if(a0%i==0)ps.push_back(i),ps.push_back(a0/i);","	for(int i = 1; i < sqrt(an)+1; ++i)if(an%i==0)qs.push_back(i),qs.push_back(an/i);","	for(auto pt:ps)for(auto qt:qs)if(pt%qt==0){","		tp x=pt/qt;","		if(!p(x))r.insert(x);","		if(!p(-x))r.insert(-x);","	}","	return r;","}","pair<poly<>,tp> ruffini(poly<> p, tp r){ // returns pair (result,rem)","	int n=p.c.size()-1;","	vector<tp> b(n);","	b[n-1]=p[n];","	for(int k=n-2;k>=0;--k)b[k]=p[k+1]+r*b[k+1];","	return {poly<>(b),p[0]+r*b[0]};","}","// only for double polynomials","pair<poly<>,poly<> > polydiv(poly<> p, poly<> q){ // returns pair (result,rem)","	int n=p.c.size()-q.c.size()+1;","	vector<tp> b(n);","	for(int k=n-1;k>=0;--k){","		b[k]=p.c.back()/q.c.back();","		for(int i = 0; i < (int)q.c.size(); ++i)p[i+k]-=b[k]*q[i];","		p.c.pop_back();","	}","	while(!p.c.empty()&&abs(p.c.back())<EPS)p.c.pop_back();","	return {poly<>(b),p};","}","// only for double polynomials","poly<> interpolate(vector<tp> x, vector<tp> y){ //TODO TEST","	poly<> q={1},S={0};","	for(tp a:x)q=poly<>({-a,1})*q;","	for(int i = 0; i < (int)x.size(); ++i){","		poly<> Li=ruffini(q,x[i]).first;","		Li=Li*(1.0/Li(x[i])); // change for int polynomials","		S=S+Li*y[i];","	}","	return S;","}",]
},
"prueba.cpp": {
	"prefix": "prueba.cpp" ,
	"body": ["cout << \"Hola mundo\" << ENDL;",]
},
"numeros_catalan.cpp": {
	"prefix": "numeros_catalan.cpp" ,
	"body": ["// Python Solution","catalan = [0 for i in range(150 + 5)]","def fcatalan(n):","    catalan[0] = 1","    catalan[1] = 1","    for i in range(2, n + 1):","        catalan[i] = 0","        for j in range(i):","            catalan[i] = catalan[i] + catalan[j] * catalan[i - j - 1]","","fcatalan(151)",]
},
"chi_liu.cpp": {
	"prefix": "chi_liu.cpp" ,
	"body": ["typedef int tw;","tw INF=1ll<<30;","struct edge{int u,v,id;tw len;};","struct ChuLiu{","	int n;","    vector<edge> e;","	vector<int> inc,dec,take,pre,num,id,vis;","	vector<tw> inw;","	void add_edge(int x, int y, tw w){","		inc.pb(0); dec.pb(0); take.pb(0);","		e.pb({x,y,sz(e),w});","	}","	ChuLiu(int n):n(n),pre(n),num(n),id(n),vis(n),inw(n){}","	tw doit(int root){","		auto e2=e;","		tw ans=0; int eg=sz(e)-1,pos=sz(e)-1;","		while(1){","			fore(i,0,n) inw[i]=INF,id[i]=vis[i]=-1;","			for(auto ed:e2) if(ed.len<inw[ed.v]){","				inw[ed.v]=ed.len; pre[ed.v]=ed.u;","				num[ed.v]=ed.id;","			}","			inw[root]=0;","			fore(i,0,n) if(inw[i]==INF) return -1;","			int tot=-1;","			fore(i,0,n){","				ans+=inw[i];","				if(i!=root)take[num[i]]++;","				int j=i;","				while(vis[j]!=i&&j!=root&&id[j]<0)vis[j]=i,j=pre[j];","				if(j!=root&&id[j]<0){","					id[j]=++tot;","					for(int k=pre[j];k!=j;k=pre[k]) id[k]=tot;","				}","			}","			if(tot<0)break;","			fore(i,0,n) if(id[i]<0)id[i]=++tot;","			n=tot+1; int j=0;","			fore(i,0,sz(e2)){","				int v=e2[i].v;","				e2[j].v=id[e2[i].v];","				e2[j].u=id[e2[i].u];","				if(e2[j].v!=e2[j].u){","					e2[j].len=e2[i].len-inw[v];","					inc.pb(e2[i].id);","					dec.pb(num[v]);","					take.pb(0);","					e2[j++].id=++pos;","				}","			}","			e2.resize(j);","			root=id[root];","		}","		while(pos>eg){","			if(take[pos]>0) take[inc[pos]]++, take[dec[pos]]--;","			pos--;","		}","		return ans;","	}","};",]
},
"dijkstra.cpp": {
	"prefix": "dijkstra.cpp" ,
	"body": ["vector<pair<int,int> > g[MAXN];  // u->[(v,cost)]","long long dist[MAXN];","void dijkstra(int x){","	memset(dist,-1,sizeof(dist));","	priority_queue<pair<long long,int> > q;","	dist[x]=0;","    q.push({0,x});","	while(!q.empty()){","		x=q.top().s;","        long long c=-q.top().f;","        q.pop();","		if(dist[x]!=c)continue;","		fore(i,0,g[x].size()){","			int y=g[x][i].f; ll c=g[x][i].s;","			if(dist[y]<0||dist[x]+c<dist[y])","				dist[y]=dist[x]+c,q.push({-dist[y],y});","		}","	}","}",]
},
"parallel_dfs.cpp": {
	"prefix": "parallel_dfs.cpp" ,
	"body": ["struct Tree {","	int n,z[2];","	vector<vector<int>> g;","	vector<int> ex,ey,p,w,f,v[2];","	Tree(int n):g(n),w(n),f(n){}","	void add_edge(int x, int y){","		p.pb(g[x].size());g[x].pb(ex.size());ex.pb(x);ey.pb(y);","		p.pb(g[y].size());g[y].pb(ex.size());ex.pb(y);ey.pb(x);","	}","	bool go(int k){ // returns true if it finds new node","		int& x=z[k];","		while(x>=0&&","			(w[x]==g[x].size()||w[x]==g[x].size()-1&&(g[x].back()^1)==f[x]))","			x=f[x]>=0?ex[f[x]]:-1;","		if(x<0)return false;","		if((g[x][w[x]]^1)==f[x])w[x]++;","		int e=g[x][w[x]],y=ey[e];","		f[y]=e;w[x]++;w[y]=0;x=y;","		v[k].pb(x);","		return true;","	}","	vector<int> erase_edge(int e){","		e*=2; // erases eth edge, returns smaller component","		int x=ex[e],y=ey[e];","		p[g[x].back()]=p[e];","		g[x][p[e]]=g[x].back();g[x].pop_back();","		p[g[y].back()]=p[e^1];","		g[y][p[e^1]]=g[y].back();g[y].pop_back();","		f[x]=f[y]=-1;","		w[x]=w[y]=0;","		z[0]=x;z[1]=y;","		v[0]={x};v[1]={y};","		bool d0=true,d1=true;","		while(d0 and d1)d0=go(0),d1=go(1);","		if(d1)return v[0];","		return v[1];","	}","};",]
},
"tarjan_2sat.cpp": {
	"prefix": "tarjan_2sat.cpp" ,
	"body": ["// MAXN: max number of nodes or 2 * max number of variables (2SAT)","bool truth[MAXN]; // truth[cmp[i]]=value of variable i (2SAT)","int nvar;int neg(int x){return MAXN-1-x;} // (2SAT)","vector<int> g[MAXN];","int n,lw[MAXN],idx[MAXN],qidx,cmp[MAXN],qcmp;","stack<int> st;","void tjn(int u){","	lw[u]=idx[u]=++qidx;","	st.push(u);cmp[u]=-2;","	for(int v:g[u]){","		if(!idx[v]||cmp[v]==-2){","			if(!idx[v]) tjn(v);","			lw[u]=min(lw[u],lw[v]);","		}","	}","	if(lw[u]==idx[u]){","		int x,l=-1;","		do{x=st.top();st.pop();cmp[x]=qcmp;if(min(x,neg(x))<nvar)l=x;}","		while(x!=u);","		if(l!=-1)truth[qcmp]=(cmp[neg(l)]<0); // (2SAT)","		qcmp++;","	}","}","void scc(){","	memset(idx,0,sizeof(idx));qidx=0;","	memset(cmp,-1,sizeof(cmp));qcmp=0;","	fore(i,0,n)if(!idx[i])tjn(i);","}","// Only for 2SAT:","void addor(int a, int b){g[neg(a)].pb(b);g[neg(b)].pb(a);}","bool satisf(int _nvar){","	nvar=_nvar;n=MAXN;scc();","	fore(i,0,nvar)if(cmp[i]==cmp[neg(i)])return false;","	return true;","}",]
},
"lca.cpp": {
	"prefix": "lca.cpp" ,
	"body": ["vector<int> g[1<<K];int n;  // K such that 2^K>=n","int F[K][1<<K],D[1<<K];","void lca_dfs(int x){","	fore(i,0,g[x].size()){","		int y=g[x][i];if(y==F[0][x])continue;","		F[0][y]=x;D[y]=D[x]+1;lca_dfs(y);","	}","}","void lca_init(){","	D[0]=0;F[0][0]=-1;","	lca_dfs(0);","	fore(k,1,K)fore(x,0,n)","		if(F[k-1][x]<0)F[k][x]=-1;","		else F[k][x]=F[k-1][F[k-1][x]];","}","int lca(int x, int y){","	if(D[x]<D[y])swap(x,y);","	for(int k=K-1;k>=0;--k)if(D[x]-(1<<k)>=D[y])x=F[k][x];","	if(x==y)return x;","	for(int k=K-1;k>=0;--k)if(F[k][x]!=F[k][y])x=F[k][x],y=F[k][y];","	return F[0][x];","}",]
},
"bellman.cpp": {
	"prefix": "bellman.cpp" ,
	"body": ["int n;","vector<pair<int,int> > g[MAXN]; // u->[(v,cost)]","long long dist[MAXN];","void bford(int src){ // O(nm)","	fill(dist,dist+n,INF);dist[src]=0;","	for(int i = 0; i<n; i+=1)fore(x,0,n)if(dist[x]!=INF)for(auto t:g[x]){","		dist[t.f]=min(dist[t.f],dist[x]+t.s);","	}","	fore(x,0,n)if(dist[x]!=INF)for(auto t:g[x]){","		if(dist[t.f]>dist[x]+t.s){","			// neg cycle: all nodes reachable from t.fst have -INF distance","			// to reconstruct neg cycle: save \"prev\" of each node, go up from t.fst until repeating a node. this node and all nodes between the two occurences form a neg cycle","		}","	}","}",]
},
"eulerian_path.cpp": {
	"prefix": "eulerian_path.cpp" ,
	"body": ["// Directed version (uncomment commented code for undirected)","struct edge {","	int y;","//	list<edge>::iterator rev;","	edge(int y):y(y){}","};","list<edge> g[MAXN];","void add_edge(int a, int b){","	g[a].push_front(edge(b));//auto ia=g[a].begin();","//	g[b].push_front(edge(a));auto ib=g[b].begin();","//	ia->rev=ib;ib->rev=ia;","}","vector<int> p;","void go(int x){","	while(g[x].size()){","		int y=g[x].front().y;","		//g[y].erase(g[x].front().rev);","		g[x].pop_front();","		go(y);","	}","	p.push_back(x);","}","vector<int> get_path(int x){ // get a path that begins in x","// check that a path exists from x before calling to get_path!","	p.clear();go(x);","    reverse(p.begin(),p.end());","	return p;","}",]
},
"kruskal.cpp": {
	"prefix": "kruskal.cpp" ,
	"body": ["int uf[MAXN];","void uf_init(){memset(uf,-1,sizeof(uf));}","int uf_find(int x){return uf[x]<0?x:uf[x]=uf_find(uf[x]);}","bool uf_join(int x, int y){","	x=uf_find(x);y=uf_find(y);","	if(x==y)return false;","	if(uf[x]>uf[y])swap(x,y);","	uf[x]+=uf[y];uf[y]=x;","	return true;","}","vector<pair<long long,pair<int,int> > > es; // edges (cost,(u,v))","long long kruskal(){  // assumes graph is connected","	sort(es.begin(),es.end());","    uf_init();","	long long r=0;","	fore(i,0,es.size()){","		int x=es[i].s.f,y=es[i].s.s;","		if(uf_join(x,y))r+=es[i].f; // (x,y,c) belongs to mst","	}","	return r; // total cost","}",]
},
"art_bri_bic.cpp": {
	"prefix": "art_bri_bic.cpp" ,
	"body": ["vector<int> g[MAXN];int n;","struct edge {int u,v,comp;bool bridge;};","vector<edge> e;","void add_edge(int u, int v){","	g[u].pb(e.size());g[v].pb(e.size());","	e.pb((edge){u,v,-1,false});","}","int D[MAXN],B[MAXN],T;","int nbc;  // number of biconnected components","int art[MAXN];  // articulation point iff !=0","stack<int> st;  // only for biconnected","void dfs(int u,int pe){","	B[u]=D[u]=T++;","	for(int ne:g[u])if(ne!=pe){","		int v=e[ne].u^e[ne].v^u;","		if(D[v]<0){","			st.push(ne);dfs(v,ne);","			if(B[v]>D[u])e[ne].bridge = true; // bridge","			if(B[v]>=D[u]){","				art[u]++; // articulation","				int last; // start biconnected","				do {","					last=st.top();st.pop();","					e[last].comp=nbc;","				} while(last!=ne);","				nbc++;    // end biconnected","			}","			B[u]=min(B[u],B[v]);","		}","		else if(D[v]<D[u])st.push(ne),B[u]=min(B[u],D[v]);","	}","}","void doit(){","	memset(D,-1,sizeof(D));","    memset(art,0,sizeof(art));","	nbc=T=0;","	fore(i,0,n)if(D[i]<0)dfs(i,-1),art[i]--;","}",]
},
"floyd.cpp": {
	"prefix": "floyd.cpp" ,
	"body": ["// g[i][j]: weight of edge (i, j) or INF if there's no edge","// g[i][i]=0","long long g[MAXN][MAXN];","int n;","void floyd(){ // O(n^3) . Replaces g with min distances","	fore(k,0,n)fore(i,0,n)if(g[i][k]<INF)fore(j,0,n)if(g[k][j]<INF)","		g[i][j]=min(g[i][j],g[i][k]+g[k][j]);","}","bool inNegCycle(int v){return g[v][v]<0;}","bool hasNegCycle(int a, int b){ // true iff there's neg cycle in between","	fore(i,0,n)if(g[a][i]<INF&&g[i][b]<INF&&g[i][i]<0)return true;","	return false;","}",]
},
"topo_sort.cpp": {
	"prefix": "topo_sort.cpp" ,
	"body": ["vector<int> g[MAXN];int n;","vector<int> tsort(){  // lexicographically smallest topological sort","	vector<int> r;","    priority_queue<int> q;","	vector<int> d(2*n,0);","	fore(i,0,n)fore(j,0,g[i].size())d[g[i][j]]++;","	fore(i,0,n)if(!d[i])q.push(-i);","	while(!q.empty()){","		int x=-q.top();q.pop();r.pb(x);","		fore(i,0,g[x].size()){","			d[g[x][i]]--;","			if(!d[g[x][i]])q.push(-g[x][i]);","		}","	}","	return r;  // if not DAG it will have less than n elements","}",]
},
"bic_comp.cpp": {
	"prefix": "bic_comp.cpp" ,
	"body": ["struct Biconnected{","	// articulation point iff B[i] !=0","	// nbc = number of biconnected components","	struct edge {int u,v,comp;bool bridge;};","	vector<edge> e;","	vector<vector<int>>g;","	int n,nbc,T;","	void add_edge(int u, int v){","		g[u].pb(sz(e));","		g[v].pb(sz(e));","		e.pb({u,v,-1,0});","	}","	vector<int>D,B,art;","	stack<int> st;","	void dfs(int u,int pe){","		B[u]=D[u]=T++;","		for(int ne:g[u])if(ne!=pe){","			int v=e[ne].u^e[ne].v^u;","			if(D[v]<0){","				st.push(ne);","				dfs(v,ne);","				if(B[v]>D[u])e[ne].bridge = true;","				if(B[v]>=D[u]){","					while(1){","						int last=st.top();st.pop();","						e[last].comp=nbc;","						if(last==ne)break;","					}","					nbc++; art[u]++;","				}","				B[u]=min(B[u],B[v]);","			}","			else if(D[v]<D[u])st.push(ne),B[u]=min(B[u],D[v]);","		}","	}","","	Biconnected(int n):n(n),nbc(0),T(0){","		D = vector<int>(n,-1);","		art = B = vector<int>(n,0);","		g = vector<int>(n);","	}","","	void run(){","		fore(i,0,n)if(D[i]<0)dfs(i,-1),art[i]--;","	}","","	auto get_cmp(){","		vector<vector<int>>v(nbc);","		for(auto i:e)v[i.comp].pb(i.u), v[i.comp].pb(i.v);","		return v;","	}","","};",]
},
"dominator.cpp": {
	"prefix": "dominator.cpp" ,
	"body": ["//idom[i]=parent of i in dominator tree with root=rt, or -1 if not exists","int n,rnk[MAXN],pre[MAXN],anc[MAXN],idom[MAXN],semi[MAXN],low[MAXN];","vector<int> g[MAXN],rev[MAXN],dom[MAXN],ord;","void dfspre(int pos){","	rnk[pos]=sz(ord); ord.pb(pos);","	for(auto x:g[pos]){","		rev[x].pb(pos);","		if(rnk[x]==n) pre[x]=pos,dfspre(x);","	}","}","int eval(int v){","	if(anc[v]<n and anc[anc[v]]<n){","		int x=eval(anc[v]);","		if(rnk[semi[low[v]]]>rnk[semi[x]]) low[v]=x;","		anc[v]=anc[anc[v]];","	}","	return low[v];","}","void dominators(int rt){","	fore(i,0,n){","		dom[i].clear(); rev[i].clear();","		rnk[i]=pre[i]=anc[i]=idom[i]=n;","		semi[i]=low[i]=i;","	}","	ord.clear();","    dfspre(rt);","	for(int i=sz(ord)-1;i;i--){","		int w=ord[i];","		for(int v:rev[w]){","			int u=eval(v);","			if(rnk[semi[w]]>rnk[semi[u]])semi[w]=semi[u];","		}","		dom[semi[w]].pb(w); anc[w]=pre[w];","		for(int v:dom[pre[w]]){","			int u=eval(v);","			idom[v]=(rnk[pre[w]]>rnk[semi[u]]?u:pre[w]);","		}","		dom[pre[w]].clear();","	}","	for(int w:ord) if(w!=rt&&idom[w]!=semi[w]) idom[w]=idom[idom[w]];","	fore(i,0,n) if(idom[i]==n)idom[i]=-1;","}",]
},
"hld.cpp": {
	"prefix": "hld.cpp" ,
	"body": ["vector<int> g[MAXN];","int wg[MAXN],dad[MAXN],dep[MAXN]; // weight,father,depth","void dfs1(int x){","	wg[x]=1;","	for(int y:g[x])if(y!=dad[x]){","		dad[y]=x;dep[y]=dep[x]+1;","        dfs1(y);","		wg[x]+=wg[y];","	}","}","int curpos,pos[MAXN],head[MAXN];","void hld(int x, int c){","	if(c<0)c=x;","	pos[x]=curpos++;head[x]=c;","	int mx=-1;","	for(int y:g[x])if(y!=dad[x]&&(mx<0||wg[mx]<wg[y]))mx=y;","	if(mx>=0)hld(mx,c);","	for(int y:g[x])if(y!=mx&&y!=dad[x])hld(y,-1);","}","void hld_init(){dad[0]=-1;dep[0]=0;dfs1(0);curpos=0;hld(0,-1);}","int query(int x, int y, STree& rmq){","	int r=NEUT;","	while(head[x]!=head[y]){","		if(dep[head[x]]>dep[head[y]])swap(x,y);","		r=oper(r,rmq.query(pos[head[y]],pos[y]+1));","		y=dad[head[y]];","	}","	if(dep[x]>dep[y])swap(x,y); // now x is lca","	r=oper(r,rmq.query(pos[x],pos[y]+1));","	return r;","}","// for updating: rmq.upd(pos[x],v);","// queries on edges: - assign values of edges to \"child\" node","//                   - change pos[x] to pos[x]+1 in query (line 28)",]
},
"centroid.cpp": {
	"prefix": "centroid.cpp" ,
	"body": ["vector<int> g[MAXN];int n;","bool tk[MAXN];","int fat[MAXN]; // father in centroid decomposition","int szt[MAXN]; // size of subtree","int calcsz(int x, int f){","	szt[x]=1;","	for(auto y:g[x])if(y!=f&&!tk[y])szt[x]+=calcsz(y,x);","	return szt[x];","}","void cdfs(int x=0, int f=-1, int sz=-1){ // O(nlogn)","	if(sz<0)sz=calcsz(x,-1);","	for(auto y:g[x])if(!tk[y]&&szt[y]*2>=sz){","		szt[x]=0;cdfs(y,f,sz);return;","	}","	tk[x]=true;fat[x]=f;","	for(auto y:g[x])if(!tk[y])cdfs(y,x);","}","void centroid(){memset(tk,false,sizeof(tk));cdfs();}",]
},
"dynamic_conn.cpp": {
	"prefix": "dynamic_conn.cpp" ,
	"body": ["struct UnionFind {","	int n,comp;","	vector<int> uf,si,c;","	UnionFind(int n=0):n(n),comp(n),uf(n),si(n,1){","		fore(i,0,n)uf[i]=i;}","	int find(int x){return x==uf[x]?x:find(uf[x]);}","	bool join(int x, int y){","		if((x=find(x))==(y=find(y)))return false;","		if(si[x]<si[y])swap(x,y);","		si[x]+=si[y];uf[y]=x;comp--;c.pb(y);","		return true;","	}","	int snap(){return c.size();}","	void rollback(int snap){","		while(c.size()>snap){","			int x=c.back();c.pop_back();","			si[uf[x]]-=si[x];uf[x]=x;comp++;","		}","	}","};","enum {ADD,DEL,QUERY};","struct Query {int type,x,y;};","struct DynCon {","	vector<Query> q;","	UnionFind dsu;","	vector<int> mt;","	map<pair<int,int>,int> last;","	DynCon(int n):dsu(n){}","	void add(int x, int y){","		if(x>y)swap(x,y);","		q.pb((Query){ADD,x,y});mt.pb(-1);","        last[{x,y}]=q.size()-1;","	}","	void remove(int x, int y){","		if(x>y)swap(x,y);","		q.pb((Query){DEL,x,y});","		int pr=last[{x,y}];mt[pr]=q.size()-1;mt.pb(pr);","	}","	void query(){q.pb((Query){QUERY,-1,-1});","    mt.pb(-1);}","	void process(){ // answers all queries in order","		if(!q.size())return;","		fore(i,0,q.size())if(q[i].type==ADD&&mt[i]<0)mt[i]=q.size();","		go(0,q.size());","	}","	void go(int s, int e){","		if(s+1==e){","			if(q[s].type==QUERY) // answer query using DSU","            cout<<dsu.comp<<ENDL;","			return;","		}","		int k=dsu.snap(),m=(s+e)/2;","		for(int i=e-1;i>=m;--i)if(mt[i]>=0&&mt[i]<s)dsu.join(q[i].x,q[i].y);","		go(s,m);","        dsu.rollback(k);","		for(int i=m-1;i>=s;--i)if(mt[i]>=e)dsu.join(q[i].x,q[i].y);","		go(m,e);","        dsu.rollback(k);","	}","};",]
},
"edmon_blossom.cpp": {
	"prefix": "edmon_blossom.cpp" ,
	"body": ["vector<int> g[MAXN];","int n,m,mt[MAXN],qh,qt,q[MAXN],ft[MAXN],bs[MAXN];","bool inq[MAXN],inb[MAXN],inp[MAXN];","int lca(int root, int x, int y){","	memset(inp,0,sizeof(inp));","	while(1){","		inp[x=bs[x]]=true;","		if(x==root)break;","		x=ft[mt[x]];","	}","	while(1){","		if(inp[y=bs[y]])return y;","		else y=ft[mt[y]];","	}","}","void mark(int z, int x){","	while(bs[x]!=z){","		int y=mt[x];","		inb[bs[x]]=inb[bs[y]]=true;","		x=ft[y];","		if(bs[x]!=z)ft[x]=y;","	}","}","void contr(int s, int x, int y){","	int z=lca(s,x,y);","	memset(inb,0,sizeof(inb));","	mark(z,x);mark(z,y);","	if(bs[x]!=z)ft[x]=y;","	if(bs[y]!=z)ft[y]=x;","	fore(x,0,n)if(inb[bs[x]]){","		bs[x]=z;","		if(!inq[x])inq[q[++qt]=x]=true;","	}","}","int findp(int s){","	memset(inq,0,sizeof(inq));","	memset(ft,-1,sizeof(ft));","	fore(i,0,n)bs[i]=i;","	inq[q[qh=qt=0]=s]=true;","	while(qh<=qt){","		int x=q[qh++];","		for(int y:g[x])if(bs[x]!=bs[y]&&mt[x]!=y){","			if(y==s||mt[y]>=0&&ft[mt[y]]>=0)contr(s,x,y);","			else if(ft[y]<0){","				ft[y]=x;","				if(mt[y]<0)return y;","				else if(!inq[mt[y]])inq[q[++qt]=mt[y]]=true;","			}","		}","	}","	return -1;","}","int aug(int s, int t){","	int x=t,y,z;","	while(x>=0){","		y=ft[x];","		z=mt[y];","		mt[y]=x;mt[x]=y;","		x=z;","	}","	return t>=0;","}","int edmonds(){ // O(n^2 m)","	int r=0;","	memset(mt,-1,sizeof(mt));","	fore(x,0,n)if(mt[x]<0)r+=aug(x,findp(x));","	return r;","}vector<int> g[MAXN];","","int n,m,mt[MAXN],qh,qt,q[MAXN],ft[MAXN],bs[MAXN];","bool inq[MAXN],inb[MAXN],inp[MAXN];","","int lca(int root, int x, int y){","	memset(inp,0,sizeof(inp));","	while(1){","		inp[x=bs[x]]=true;","		if(x==root)break;","		x=ft[mt[x]];","	}","	while(1){","		if(inp[y=bs[y]])return y;","		else y=ft[mt[y]];","	}","}","void mark(int z, int x){","	while(bs[x]!=z){","		int y=mt[x];","		inb[bs[x]]=inb[bs[y]]=true;","		x=ft[y];","		if(bs[x]!=z)ft[x]=y;","	}","}","void contr(int s, int x, int y){","	int z=lca(s,x,y);","	memset(inb,0,sizeof(inb));","	mark(z,x);mark(z,y);","	if(bs[x]!=z)ft[x]=y;","	if(bs[y]!=z)ft[y]=x;","	fore(x,0,n)if(inb[bs[x]]){","		bs[x]=z;","		if(!inq[x])inq[q[++qt]=x]=true;","	}","}","int findp(int s){","	memset(inq,0,sizeof(inq));","	memset(ft,-1,sizeof(ft));","	fore(i,0,n)bs[i]=i;","	inq[q[qh=qt=0]=s]=true;","	while(qh<=qt){","		int x=q[qh++];","		for(int y:g[x])if(bs[x]!=bs[y]&&mt[x]!=y){","			if(y==s||mt[y]>=0&&ft[mt[y]]>=0)contr(s,x,y);","			else if(ft[y]<0){","				ft[y]=x;","				if(mt[y]<0)return y;","				else if(!inq[mt[y]])inq[q[++qt]=mt[y]]=true;","			}","		}","	}","	return -1;","}","int aug(int s, int t){","	int x=t,y,z;","	while(x>=0){","		y=ft[x];","		z=mt[y];","		mt[y]=x;mt[x]=y;","		x=z;","	}","	return t>=0;","}","int edmonds(){ // O(n^2 m)","	int r=0;","	memset(mt,-1,sizeof(mt));","	fore(x,0,n)if(mt[x]<0)r+=aug(x,findp(x));","	return r;","}",]
},
"line.cpp": {
	"prefix": "line.cpp" ,
	"body": ["//Needs EPS, INF and DINF","","struct ln {","	pt p,pq;","	ln(pt p, pt q):p(p),pq(q-p){}","	ln(){}","	bool has(pt r){return dist(r)<=EPS;}","	bool seghas(pt r){return has(r)&&(r-p)*(r-(p+pq))<=EPS;}","//	bool operator /(ln l){return (pq.unit()^l.pq.unit()).norm()<=EPS;} // 3D","	bool operator/(ln l){return abs(pq.unit()%l.pq.unit())<=EPS;} // 2D","	bool operator==(ln l){return *this/l&&has(l.p);}","	pt operator^(ln l){ // intersection","		if(*this/l)return pt(DINF,DINF);","		pt r=l.p+l.pq*((p-l.p)%pq/(l.pq%pq));","//		if(!has(r)){return pt(NAN,NAN,NAN);} // check only for 3D","		return r;","	}","	double angle(ln l){return pq.angle(l.pq);}","	int side(pt r){return has(r)?0:sgn2(pq%(r-p));} // 2D","	pt proj(pt r){return p+pq*((r-p)*pq/pq.norm2());}","	pt ref(pt r){return proj(r)*2-r;}","	double dist(pt r){return (r-proj(r)).norm();}","//	double dist(ln l){ // only 3D","//		if(*this/l)return dist(l.p);","//		return abs((l.p-p)*(pq^l.pq))/(pq^l.pq).norm();","//	}","	ln rot(double a){return ln(p,p+pq.rot(a));} // 2D","	ln rot(pt a){return ln(p,p+pq.rot(a));}","};","ln bisector(ln l, ln m){ // angle bisector","	pt p=l^m;","	return ln(p,p+l.pq.unit()+m.pq.unit());","}","ln bisector(pt p, pt q){ // segment bisector (2D)","	return ln((p+q)*.5,p).rot(ccw90);","}",]
},
"intercircles.cpp": {
	"prefix": "intercircles.cpp" ,
	"body": ["//Need radial order","vector<double> intercircles(vector<circle> c){","	vector<double> r(c.size() + 1); // r[k]: area covered by at least k circles","	for(int i = 0; i < c.size(); ++i){           // O(n^2 log n) (high constant)","		int k=1;Cmp s(c[i].o);","		vector<pair<pt,int> > p={","			{c[i].o+pt(1,0)*c[i].r,0},","			{c[i].o-pt(1,0)*c[i].r,0}};","		for(int j = 0; j < c.size(); ++j)if(j!=i){","			bool b0=c[i].in(c[j]),b1=c[j].in(c[i]);","			if(b0&&(!b1||i<j))k++;","			else if(!b0&&!b1){","				auto v=c[i]^c[j];","				if(v.size()==2){","					p.push_back({v[0],1});p.push_back({v[1],-1});","					if(s(v[1],v[0]))k++;","				}","			}","		}","		sort(p.begin(),p.end(),","			[&](pair<pt,int> a, pair<pt,int> b){return s(a.first,b.first);});","		for(int j = 0; j < (int)p.size(); ++j){","			pt p0=p[j?j-1:(int)p.size()-1].first,p1=p[j].first;","			double a=(p0-c[i].o).angle(p1-c[i].o);","			r[k]+=(p0.x-p1.x)*(p0.y+p1.y)/2+c[i].r*c[i].r*(a-sin(a))/2;","			k+=p[j].second;","		}","	}","	return r;","}",]
},
"halfplanes.cpp": {
	"prefix": "halfplanes.cpp" ,
	"body": ["struct halfplane:public ln{","	double angle;","	halfplane(){}","	halfplane(pt a,pt b){p=a; pq=b-a; angle=atan2(pq.y,pq.x);}","	bool operator<(halfplane b)const{return angle<b.angle;}","	bool out(pt q){return pq%(q-p)<-EPS;}","};","vector<pt> intersect(vector<halfplane> b){","	vector<pt>bx={{DINF,DINF},{-DINF,DINF},{-DINF,-DINF},{DINF,-DINF}};","	for(int i = 0; i < 4; ++i) b.push_back(halfplane(bx[i],bx[(i+1)%4]));","	sort(b.begin(), b.end());","	int n=(int)b.size(),q=1,h=0;","	vector<halfplane> c((int)b.size()+10);","	for(int i = 0; i < n; ++i){","		while(q<h&&b[i].out(c[h]^c[h-1])) h--;","		while(q<h&&b[i].out(c[q]^c[q+1])) q++;","		c[++h]=b[i];","		if(q<h&&abs(c[h].pq%c[h-1].pq)<EPS){","			if(c[h].pq*c[h-1].pq<=0) return {};","			h--;","			if(b[i].out(c[h].p)) c[h]=b[i];","		}","	}","	while(q<h-1&&c[q].out(c[h]^c[h-1]))h--;","	while(q<h-1&&c[h].out(c[q]^c[q+1]))q++;","	if(h-q<=1)return {};","	c[h+1]=c[q];","	vector<pt> s;","	for(int i = q; i < h+1; ++i) s.push_back(c[i]^c[i+1]);","	return s;","}",]
},
"radial_order.cpp": {
	"prefix": "radial_order.cpp" ,
	"body": ["struct Cmp { // IMPORTANT: add const in pt operator -","	pt r;","	Cmp(pt r):r(r){}","	int cuad(const pt &a)const {","		if(a.x>0&&a.y>=0)return 0;","		if(a.x<=0&&a.y>0)return 1;","		if(a.x<0&&a.y<=0)return 2;","		if(a.x>=0&&a.y<0)return 3;","		assert(a.x==0&&a.y==0);","		return -1;","	}","	bool cmp(const pt& p1, const pt& p2)const {","		int c1=cuad(p1),c2=cuad(p2);","		if(c1==c2)return p1.y*p2.x<p1.x*p2.y;","		return c1<c2;","	}","	bool operator()(const pt& p1, const pt& p2)const {","		return cmp(pt(p1)-pt(r),pt(p2)-pt(r));","	}","};",]
},
"planar_graph_dual.cpp": {
	"prefix": "planar_graph_dual.cpp" ,
	"body": ["const int MAXN = 1;","vector<int> g[MAXN];int n; // input graph (must be connected)","vector<int> gd[MAXN];int nd; // output graph","vector<int> nodes[MAXN]; // nodes delimiting region (in CW order)","map<pair<int,int>,int> ps,es;","void get_dual(vector<pt> p){ // p: points corresponding to nodes","	ps.clear();es.clear();","	for(int x = 0; x < n; ++x){","		Cmp pc(p[x]); // (radial order of points)","		auto comp=[&](int a, int b){return pc(p[a],p[b]);};","		sort(g[x].begin(),g[x].end(),comp);","		for(int i = 0; i < (int)g[x].size(); ++i)ps[{x,g[x][i]}]=i;","	}","	nd=0;","	for(int xx = 0; xx < n; ++xx)for(auto yy:g[xx])if(!es.count({xx,yy})){","		int x=xx,y=yy;gd[nd].clear();nodes[nd].clear();","		while(!es.count({x,y})){","			es[{x,y}]=nd;nodes[nd].push_back(y);","			int z=g[y][(ps[{y,x}]+1)%g[y].size()];x=y;y=z;","		}","		nd++;","	}","	for(auto p:es){","		pair<int,int> q={p.first.second,p.first.first};","		assert(es.count(q));","		if(es[q]!=p.second)gd[p.second].push_back(es[q]);","	}","	for(int i = 0; i < nd; ++i){","		sort(gd[i].begin(),gd[i].end());","		gd[i].erase(unique(gd[i].begin(),gd[i].end()),gd[i].end());","	}","}",]
},
"point.cpp": {
	"prefix": "point.cpp" ,
	"body": ["//Needs a EPS","","struct pt {  // for 3D add z coordinate","	double x,y;","	pt(double x, double y):x(x),y(y){}","	pt(){}","	double norm2(){return *this**this;}","	double norm(){return sqrt(norm2());}","	bool operator==(pt p){return abs(x-p.x)<=EPS&&abs(y-p.y)<=EPS;}","	pt operator+(pt p){return pt(x+p.x,y+p.y);}","	pt operator-(pt p){return pt(x-p.x,y-p.y);}","	pt operator*(double t){return pt(x*t,y*t);}","	pt operator/(double t){return pt(x/t,y/t);}","	double operator*(pt p){return x*p.x+y*p.y;}","//	pt operator^(pt p){ // only for 3D","//		return pt(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);}","	double angle(pt p){ // redefine acos for values out of range","		return acos(*this*p/(norm()*p.norm()));}","	pt unit(){return *this/norm();}","	double operator%(pt p){return x*p.y-y*p.x;}","	// 2D from now on","	bool operator<(pt p)const{ // for convex hull","		return x<p.x-EPS||(abs(x-p.x)<=EPS&&y<p.y-EPS);}","	bool left(pt p, pt q){ // is it to the left of directed line pq?","		return (q-p)%(*this-p)>EPS;}","	pt rot(pt r){return pt(*this%r,*this*r);}","	pt rot(double a){return rot(pt(sin(a),cos(a)));}","};","pt ccw90(1,0);","pt cw90(-1,0);",]
},
"polygon.cpp": {
	"prefix": "polygon.cpp" ,
	"body": ["//Need CHULL","int sgn(double x){return x<-EPS?-1:x>EPS;}","struct pol {","	int n;vector<pt> p;","	pol(){}","	pol(vector<pt> _p){p=_p;n=p.size();}","	double area(){","		double r=0.;","		for(int i = 0; i < n; ++i)r+=p[i]%p[(i+1)%n];","		return abs(r)/2; // negative if CW, positive if CCW","	}","	pt centroid(){ // (barycenter)","		pt r(0,0);double t=0;","		for(int i = 0; i < n; ){","			r=r+(p[i]+p[(i+1)%n])*(p[i]%p[(i+1)%n]);","			t+=p[i]%p[(i+1)%n];","		}","		return r/t/3;","	}","	bool has(pt q){ // O(n)","		for(int i = 0; i < n; ++i)if(ln(p[i],p[(i+1)%n]).seghas(q))return true;","		int cnt=0;","		for(int i = 0; i < n; ++i){","			int j=(i+1)%n;","			int k=sgn((q-p[j])%(p[i]-p[j]));","			int u=sgn(p[i].y-q.y),v=sgn(p[j].y-q.y);","			if(k>0&&u<0&&v>=0)cnt++;","			if(k<0&&v<0&&u>=0)cnt--;","		}","		return cnt!=0;","	}","	void normalize(){ // (call before haslog, remove collinear first)","		if(p[2].left(p[0],p[1]))reverse(p.begin(),p.end());","		int pi=min_element(p.begin(),p.end())-p.begin();","		vector<pt> s(n);","		for(int i = 0; i < n; ++i) s[i]=p[(pi+i)%n];","		p.swap(s);","	}","	bool haslog(pt q){ // O(log(n)) only CONVEX. Call normalize first","		if(q.left(p[0],p[1])||q.left(p.back(),p[0]))return false;","		int a=1,b=p.size()-1;  // returns true if point on boundary","		while(b-a>1){          // (change sign of EPS in left","			int c=(a+b)/2;       //  to return false in such case)","			if(!q.left(p[0],p[c]))a=c;","			else b=c;","		}","		return !q.left(p[a],p[a+1]);","	}","	pt farthest(pt v){ // O(log(n)) only CONVEX","		if(n<10){","			int k=0;","			for(int i = 1; i < n; ++i)if(v*(p[i]-p[k])>EPS)k=i;","			return p[k];","		}","		if(n==(int)p.size()) p.push_back(p[0]);","		pt a=p[1]-p[0];","		int s=0,e=n,ua=v*a>EPS;","		if(!ua&&v*(p[n-1]-p[0])<=EPS)return p[0];","		while(1){","			int m=(s+e)/2;pt c=p[m+1]-p[m];","			int uc=v*c>EPS;","			if(!uc&&v*(p[m-1]-p[m])<=EPS)return p[m];","			if(ua&&(!uc||v*(p[s]-p[m])>EPS))e=m;","			else if(ua||uc||v*(p[s]-p[m])>=-EPS)s=m,a=c,ua=uc;","			else e=m;","			assert(e>s+1);","		}","	}","	pol cut(ln l){   // cut CONVEX polygon by line l","		vector<pt> q;  // returns part at left of l.pq","		for(int i = 0; i < n; ++i){","			int d0=sgn(l.pq%(p[i]-l.p)),d1=sgn(l.pq%(p[(i+1)%n]-l.p));","			if(d0>=0)q.push_back(p[i]);","			ln m(p[i],p[(i+1)%n]);","			if(d0*d1<0&&!(l/m))q.push_back(l^m);","		}","		return pol(q);","	}","	double intercircle(circle c){ // area of intersection with circle","		double r=0.;","		for(int i = 0; i < n; ++i){","			int j=(i+1)%n;double w=c.intertriangle(p[i],p[j]);","			if((p[j]-c.o)%(p[i]-c.o)>0)r+=w;","			else r-=w;","		}","		return abs(r);","	}","	double callipers(){ // square distance of most distant points","		double r=0;     // prereq: convex, ccw, NO COLLINEAR POINTS","		for(int i=0,j=n<2?0:1;i<j;++i){","			for(;;j=(j+1)%n){","				r=max(r,(p[i]-p[j]).norm2());","				if((p[(i+1)%n]-p[i])%(p[(j+1)%n]-p[j])<=EPS)break;","			}","		}","		return r;","	}","};","// Dynamic convex hull trick","vector<pol> w;","void add(pt q){ // add(q), O(log^2(n))","	vector<pt> p={q};","	while(!w.empty()&&(int)(w.back().p).size() <2*(int)p.size()){","		for(pt v:w.back().p)p.push_back(v);","		w.pop_back();","	}","	w.push_back(pol(chull(p)));","}","long long query(pt v){ // max(q*v:q in w), O(log^2(n))","	long long r=-INF;","	for(auto& p:w)r=max(r,(long long)(p.farthest(v)*v));","	return r;","}",]
},
"circle.cpp": {
	"prefix": "circle.cpp" ,
	"body": ["struct circle {","	pt o;double r;","	circle(pt o, double r):o(o),r(r){}","	circle(pt x, pt y, pt z){o=bisector(x,y)^bisector(x,z);r=(o-x).norm();}","	bool has(pt p){return (o-p).norm()<=r+EPS;}","	vector<pt> operator^(circle c){ // ccw","		vector<pt> s;","		double d=(o-c.o).norm();","		if(d>r+c.r+EPS||d+min(r,c.r)+EPS<max(r,c.r))return s;","		double x=(d*d-c.r*c.r+r*r)/(2*d);","		double y=sqrt(r*r-x*x);","		pt v=(c.o-o)/d;","		s.push_back(o+v*x-v.rot(ccw90)*y);","		if(y>EPS)s.push_back(o+v*x+v.rot(ccw90)*y);","		return s;","	}","	vector<pt> operator^(ln l){","		vector<pt> s;","		pt p=l.proj(o);","		double d=(p-o).norm();","		if(d-EPS>r)return s;","		if(abs(d-r)<=EPS){s.push_back(p);return s;}","		d=sqrt(r*r-d*d);","		s.push_back(p+l.pq.unit()*d);","		s.push_back(p-l.pq.unit()*d);","		return s;","	}","	vector<pt> tang(pt p){","		double d=sqrt((p-o).norm2()-r*r);","		return *this^circle(p,d);","	}","	bool in(circle c){ // non strict","		double d=(o-c.o).norm();","		return d+r<=c.r+EPS;","	}","	double intertriangle(pt a, pt b){ // area of intersection with oab","		if(abs((o-a)%(o-b))<=EPS)return 0.;","		vector<pt> q={a},w=*this^ln(a,b);","		if(w.size()==2)for(auto p:w)if((a-p)*(b-p)<-EPS)q.push_back(p);","		q.push_back(b);","		if(q.size()==4&&(q[0]-q[1])*(q[2]-q[1])>EPS)swap(q[1],q[2]);","		double s=0;","		for(int i = 0; i < (int)q.size() - 1; ++i) {","			if(!has(q[i])||!has(q[i+1]))s+=r*r*(q[i]-o).angle(q[i+1]-o)/2;","			else s+=abs((q[i]-o)%(q[i+1]-o)/2);","		}","		return s;","	}","};",]
},
"plane.cpp": {
	"prefix": "plane.cpp" ,
	"body": ["struct plane {","	pt a,n; // n: normal unit vector","	plane(pt a, pt b, pt c):a(a),n(((b-a)^(c-a)).unit()){}","	plane(){}","	bool has(pt p){return abs((p-a)*n)<=EPS;}","	double angle(plane w){return acos(n*w.n);}","	double dist(pt p){return abs((p-a)*n);}","	pt proj(pt p){inter(ln(p,p+n),p);return p;}","	bool inter(ln l, pt& r){","		double x=n*(l.p+l.pq-a),y=n*(l.p-a);","		if(abs(x-y)<=EPS)return false;","		r=(l.p*x-(l.p+l.pq)*y)/(x-y);","		return true;","	}","	bool inter(plane w, ln& r){","		pt nn=n^w.n;pt v=n^nn;double d=w.n*v;","		if(abs(d)<=EPS)return false;","		pt p=a+v*(w.n*(w.a-a)/d);","		r=ln(p,p+nn);","		return true;","	}","};",]
},
"kdtree.cpp": {
	"prefix": "kdtree.cpp" ,
	"body": ["bool onx(pt a, pt b){return a.x<b.x;}","bool ony(pt a, pt b){return a.y<b.y;}","","struct Node {","	pt pp;","	long long x0=INF, x1=-INF, y0=INF, y1=-INF;","	Node *first=0, *second=0;","	long long distance(pt p){","		long long x=min(max(x0,(long long)p.x),x1);","		long long y=min(max(y0,(long long)p.y),y1);","		return (pt(x,y)-p).norm2();","	}","	Node(vector<pt>&& vp):pp(vp[0]){","		for(pt p:vp){","			x0=min(x0,(long long)p.x); x1=max(x1,(long long)p.x);","			y0=min(y0,(long long)p.y); y1=max(y1,(long long)p.y);","		}","		if(vp.size() > 1){","			sort(vp.begin(), vp.end(),x1-x0>=y1-y0?onx:ony);","			int m=(int)(vp.size())/2;","			first=new Node({vp.begin(),vp.begin()+m});","			second=new Node({vp.begin()+m,vp.end()});","		}","	}","};","struct KDTree {","	Node* root;","	KDTree(const vector<pt>& vp):root(new Node({vp.begin(), vp.end()})) {}","	pair<long long,pt> search(pt p, Node *node){","		if(!node->first){","			//avoid query point as answer","			//if(p==node->pp) {INF,pt()};","			return {(p-node->pp).norm2(),node->pp};","		}","		Node *f=node->first, *s=node->second;","		long long bf=f->distance(p), bs=s->distance(p);","		if(bf>bs)swap(bf,bs),swap(f,s);","		auto best=search(p,f);","		if(bs<best.first) best=min(best,search(p,s));","		return best;","	}","	pair<long long,pt> nearest(pt p){return search(p,root);}","};",]
},
"convex_hull.cpp": {
	"prefix": "convex_hull.cpp" ,
	"body": ["vector<pt> chull(vector<pt> p){","	if(p.size()<3)return p;","	vector<pt> r;","	sort(p.begin(),p.end()); // first x, then y","	for(int i = 0; i < (int)p.size(); ++i){ // lower hull","		while(r.size()>=2&&r.back().left(r[r.size()-2],p[i]))r.pop_back();","		r.push_back(p[i]);","	}","	r.pop_back();","	int k=r.size();","	for(int i=p.size()-1;i>=0;--i){ // upper hull","		while((int)r.size()>=k+2&&r.back().left(r[(int)r.size()-2],p[i]))r.pop_back();","		r.push_back(p[i]);","	}","	r.pop_back();","	return r;","}",]
},
"tem-comp.cpp": {
	"prefix": "tem-comp.cpp" ,
	"body": ["/*"," © $%Y%$-$%M%$-$%D%$ $%h%$:$%m%$:$%s%$ $%U%$ All Rights Reserved","*/","","//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")","//#pragma GCC target(\"avx,avx2,fma\")","#include <bits/stdc++.h>","#define f first","#define s second","#define fore(i,a,b) for(int i = (a), ThxMK = (b); i < ThxMK; ++i)","#define pb push_back","#define all(s) begin(s), end(s)","#define _ ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);","#define sz(s) int(s.size())","#define ENDL '\n'","using namespace std;","// #include <ext/pb_ds/assoc_container.hpp>","// #include <ext/pb_ds/trie_policy.hpp>","// using namespace __gnu_pbds;","// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;","typedef long double ld;","typedef long long lli;","typedef pair<lli,lli> ii;","typedef vector<lli> vi;","#define deb(x) cout << #x\": \" << (x) << endl;","template <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;","// unsigned int","// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());","// long long","// mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());","// int en rango [L,R]","// auto rnd=bind(uniform_int_distribution<int>(L,R), mt19937(time(0)));","// long long en rango [L,R]","// auto rnd=bind(uniform_int_distribution<long long>(L,R), mt19937(time(0)));","// double en rango [L, R)","// auto rnd=bind(uniform_real_distribution<double>(L,R), mt19937(time(0)));","lli MOD = 1e9 + 7;","lli gcd(lli a, lli b){return (b?gcd(b,a%b):a);}","lli lcm(lli a, lli b){ if(!a || !b) return 0; return a * b / gcd(a, b); }","int popcount(lli x) { return __builtin_popcountll(x); }","lli powm(lli a, lli b){","    lli res =1;","    while(b){ if(b&1) res = (res * a) % MOD; a = (a*a) % MOD; b/=2; }","    return res;","}","lli invm(lli a) {","  return powm(a, MOD - 2);","}","lli poww(lli a, lli b){","    lli res =1;","    while(b){ if(b&1) res = res * a; a = a*a; b/=2; }","    return res;","}","vi sieve(int N){","    vi m(N+1,0);","    vi primes(1,2);","    for(int i = 4; i < N; i += 2) m[i]=1;","    for(int i = 3; i*i <= N; i +=2) if(!m[i]) for(int j = i*i; j < N; j += i) m[j]=1;","    for(int i = 3; i < N; i += 2) if(!m[i]) primes.pb(i);","    return primes;","}","int main(){ _","  return 0;","}",]
},
"tem.cpp": {
	"prefix": "tem.cpp" ,
	"body": ["/*"," © $%Y%$-$%M%$-$%D%$ $%h%$:$%m%$:$%s%$ $%U%$ All Rights Reserved","*/","","// #pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")","// #pragma GCC target(\"avx,avx2,fma\")","#include <bits/stdc++.h>","#define f first","#define s second","#define fore(i,a,b) for(int i = (a), ThxMK = (b); i < ThxMK; ++i)","#define pb push_back","#define all(s) begin(s), end(s)","#define _ ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);","#define sz(s) int(s.size())","#define ENDL '\n'","using namespace std;","typedef long double ld;","typedef long long lli;","typedef pair<lli,lli> ii;","typedef vector<lli> vi;","#define deb(x) cout << #x\": \" << (x) << endl;","","int main(){ _","  // freopen(\"file.in\",\"r\",stdin);","  // freopen(\"file.out\",\"w\",stdout);","  return 0;","}",]
},
"hungarian.cpp": {
	"prefix": "hungarian.cpp" ,
	"body": ["typedef long double td;","typedef vector<int> vi;","typedef vector<td> vd;","const td INF=1e10;//for maximum set INF to 0, and negate costs","bool zero(td x){return fabs(x)<1e-9;}//change to x==0, for ints/ll","struct Hungarian{","    int n; vector<vd> cs; vi L, R;","    Hungarian(int N, int M):n(max(N,M)),cs(n,vd(n)),L(n),R(n){","        fore(x,0,N)fore(y,0,M)cs[x][y]=INF;","    }","    void set(int x,int y,td c){cs[x][y]=c;}","	td assign() {","		int mat = 0; vd ds(n), u(n), v(n); vi dad(n), sn(n);","		fore(i,0,n)u[i]=*min_element(all(cs[i]));","		fore(j,0,n){","            v[j]=cs[0][j]-u[0];","            fore(i,1,n)v[j]=min(v[j],cs[i][j]-u[i]);","        }","		L=R=vector<int>(n, -1);","		fore(i,0,n)fore(j,0,n)","			if(R[j]==-1&&zero(cs[i][j]-u[i]-v[j])){","                L[i]=j;R[j]=i;","                mat++;","                break;","            }","		for(;mat<n;mat++){","		    int s=0, j=0, i;","		    while(L[s] != -1)s++;","		    fill(all(dad),-1);","            fill(all(sn),0);","		    fore(k,0,n)ds[k]=cs[s][k]-u[s]-v[k];","		    for(;;){","		        j = -1;","		        fore(k,0,n)if(!sn[k]&&(j==-1||ds[k]<ds[j]))j=k;","		        sn[j] = 1; i = R[j];","		        if(i == -1) break;","		        fore(k,0,n)if(!sn[k]){","		            auto new_ds=ds[j]+cs[i][k]-u[i]-v[k];","		            if(ds[k] > new_ds){ds[k]=new_ds;dad[k]=j;}","		        }","		    }","		    fore(k,0,n)if(k!=j&&sn[k]){","                auto w=ds[k]-ds[j];","                v[k]+=w,u[R[k]]-=w;","            }","		    u[s] += ds[j];","		    while(dad[j]>=0){","                int d = dad[j];","                R[j]=R[d];","                L[R[j]]=j;j=d;","            }","		    R[j]=s;L[s]=j;","		}","		td value=0;","        fore(i,0,n)value+=cs[i][L[i]];","		return value;","	}","};",]
},
"matching-bip.cpp": {
	"prefix": "matching-bip.cpp" ,
	"body": ["struct Bipartite_Matching {","  vector<vector<int>> graph;","  vector<int> dist, match, used;","  vector<bool> vv;","","  Bipartite_Matching(int n, int m) {","    graph.resize(n);","    match.assign(m, -1);","    used.assign(n, -1);","  }","","  void add(int u, int v) { graph[u].push_back(v);}","","  void bfs() {","    dist.assign(graph.size(), -1);","    queue< int > que;","    for(int i = 0; i < graph.size(); i++) {","      if(used[i] == -1) {","        que.emplace(i);","        dist[i] = 0;","      }","    }","","    while(!que.empty()) {","      int a = que.front();","      que.pop();","      for(auto &b : graph[a]) {","        int c = match[b];","        if(c >= 0 && dist[c] == -1) {","          dist[c] = dist[a] + 1;","          que.emplace(c);","        }","      }","    }","  }","","  bool dfs(int a) {","    vv[a] = true;","    for(auto &b : graph[a]) {","      int c = match[b];","      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {","        match[b] = a;","        used[a] = b;","        return (true);","      }","    }","    return (false);","  }","","  int bipartite_matching() {","    int ret = 0;","    while(true) {","      bfs();","      vv.assign(graph.size(), false);","      int flow = 0;","      for(int i = 0; i < graph.size(); i++) {","        if(used[i] == -1 && dfs(i)) ++flow;","      }","      if(flow == 0) return (ret);","      ret += flow;","    }","  }","};",]
},
"MCMF.cpp": {
	"prefix": "MCMF.cpp" ,
	"body": ["template <typename tf, typename tc>struct MCF{","int n;","  tf INFFLOW;","  tc INFCOST;","  vector<tc> prio, pot;","  vector<tf> curflow;","  vector<int> prevedge,prevnode;","	priority_queue<pair<tc, int>, vector<pair<tc, int>>, greater<pair<tc, int>>> q;","	struct edge{int to, rev; tf f, cap; tc cost;};","	vector<vector<edge>> g;","	MCF(int n):n(n),prio(n),curflow(n),prevedge(n),prevnode(n),pot(n),g(n){","    INFFLOW=numeric_limits<tf>::max() / 2;","    INFCOST=numeric_limits<tc>::max() / 2;","  }","	void add(int s, int t, tf cap, tc cost) {","		g[s].pb((edge){t,sz(g[t]),0,cap,cost});","		g[t].pb((edge){s,sz(g[s])-1,0,0,-cost});","	}","	pair<tf,tc> get_flow(int s, int t) {","		tf flow=0; tc flowcost=0;","		while(1){","			q.push({0, s});","			fill(all(prio),INFCOST);","			prio[s]=0; curflow[s]=INFFLOW;","			while(!q.empty()) {","				auto cur=q.top();","				tc d=cur.f;","				int u=cur.s;","				q.pop();","				if(d!=prio[u]) continue;","				for(int i=0; i<sz(g[u]); ++i) {","					edge &e=g[u][i];","					int v=e.to;","					if(e.cap<=e.f) continue;","					tc nprio=prio[u]+e.cost+pot[u]-pot[v];","					if(prio[v]>nprio) {","						prio[v]=nprio;","						q.push({nprio, v});","						prevnode[v]=u; prevedge[v]=i;","						curflow[v]=min(curflow[u], e.cap-e.f);","					}","				}","			}","			if(prio[t]==INFCOST) break;","			fore(i,0,n) pot[i]+=prio[i];","			tf df=min(curflow[t], INFFLOW-flow);","			flow+=df;","			for(int v=t; v!=s; v=prevnode[v]) {","				edge &e=g[prevnode[v]][prevedge[v]];","				e.f+=df; g[v][e.rev].f-=df;","				flowcost+=df*e.cost;","			}","		}","		return {flow,flowcost};","	}","};",]
},
"dinic.cpp": {
	"prefix": "dinic.cpp" ,
	"body": ["// Min cut: nodes with dist>=0 vs nodes with dist<0","// Matching MVC: left nodes with dist<0 + right nodes with dist>0","struct Dinic{","	int nodes,src,dst;","	vector<int> dist,q,work;","	struct edge {int to,rev;lli f,cap;};","	vector<vector<edge>> g;","	Dinic(int x):nodes(x),g(x),dist(x),q(x),work(x){}","	void add_edge(int s, int t, lli cap){","		g[s].pb((edge){t,sz(g[t]),0,cap});","		g[t].pb((edge){s,sz(g[s])-1,0,0});","	}","	bool dinic_bfs(){","		fill(all(dist),-1);dist[src]=0;","		int qt=0;q[qt++]=src;","		for(int qh=0;qh<qt;qh++){","			int u=q[qh];","			fore(i,0,sz(g[u])){","				edge &e=g[u][i];int v=g[u][i].to;","				if(dist[v]<0&&e.f<e.cap)dist[v]=dist[u]+1,q[qt++]=v;","			}","		}","		return dist[dst]>=0;","	}","	lli dinic_dfs(int u, lli f){","		if(u==dst)return f;","		for(int &i=work[u];i<sz(g[u]);i++){","			edge &e=g[u][i];","			if(e.cap<=e.f)continue;","			int v=e.to;","			if(dist[v]==dist[u]+1){","				lli df=dinic_dfs(v,min(f,e.cap-e.f));","				if(df>0){e.f+=df;g[v][e.rev].f-=df;return df;}","			}","		}","		return 0;","	}","	lli max_flow(int _src, int _dst){","		src=_src;dst=_dst;","		lli result=0;","		while(dinic_bfs()){","			fill(all(work),0);","			while(lli delta=dinic_dfs(src,INF))result+=delta;","		}","		return result;","	}","};",]
},
"dinic_crystal.cpp": {
	"prefix": "dinic_crystal.cpp" ,
	"body": ["template <typename flow_t> struct Dinic {","    const flow_t INF;","","    struct edge {","        int to;","        flow_t cap;","        int rev;","        bool isrev;","        int idx;","    };","","    vector<vector<edge>> graph;","    vector<int> min_cost, iter;","","    Dinic(int V) : INF(numeric_limits<flow_t>::max()), graph(V) {}","","    void add(int from, int to, flow_t cap, int idx = -1) {","        graph[from].emplace_back((edge){to, cap, (int)graph[to].size(), false, idx});","        graph[to].emplace_back((edge){from, 0, (int)graph[from].size() - 1, true, idx});","    }","","    bool bfs(int s, int t) {","        min_cost.assign(graph.size(), -1);","        queue<int> que;","        min_cost[s] = 0;","        que.push(s);","        while(!que.empty() && min_cost[t] == -1) {","            int p = que.front();","            que.pop();","            for(auto &e : graph[p]) {","                if(e.cap > 0 && min_cost[e.to] == -1) {","                    min_cost[e.to] = min_cost[p] + 1;","                    que.push(e.to);","                }","            }","        }","        return min_cost[t] != -1;","    }","","    flow_t dfs(int idx, const int t, flow_t flow) {","        if(idx == t) return flow;","        for(int &i = iter[idx]; i < graph[idx].size(); i++) {","            edge &e = graph[idx][i];","            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {","                flow_t d = dfs(e.to, t, min(flow, e.cap));","                if(d > 0) {","                    e.cap -= d;","                    graph[e.to][e.rev].cap += d;","                    return d;","                }","            }","        }","        return 0;","    }","","    flow_t max_flow(int s, int t) {","        flow_t flow = 0;","        while(bfs(s, t)) {","            iter.assign(graph.size(), 0);","            flow_t f = 0;","            while((f = dfs(s, t, INF)) > 0) flow += f;","        }","        return flow;","    }","","    void output() {","        for(int i = 0; i < graph.size(); i++) {","            for(auto &e : graph[i]) {","                if(e.isrev) continue;","                auto &rev_e = graph[e.to][e.rev];","                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << ENDL;","            }","        }","    }","};",]
},
}
